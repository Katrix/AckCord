//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.requests

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/requests/ChannelRequests.yaml

import java.time.OffsetDateTime

import ackcord.data._
import ackcord.data.base._
import io.circe.Json
import sttp.model.Method

object ChannelRequests {

  /**
    * Get a channel by ID. Returns a channel object. If the channel is a thread,
    * a thread member object is included in the returned result.
    */
  def getChannel(channelId: ChannelId): Request[Unit, Channel] =
    Request.restRequest(
      route =
        (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true)).toRequest(Method.GET)
    )

  /**
    * Update a channel's settings. Returns a channel on success, and a 400 BAD
    * REQUEST on invalid parameters. All JSON parameters are optional.
    */
  def modifyChannel(
      channelId: ChannelId,
      body: ModifyChannelBody,
      reason: Option[String]
  ): Request[ModifyChannelBody, Channel] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true))
        .toRequest(Method.PATCH),
      params = body,
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  sealed trait ModifyChannelBody extends DiscordObject

  object ModifyChannelBody {

    import io.circe.syntax._
    import io.circe.{Codec, HCursor}
    implicit val codec: Codec[ModifyChannelBody] = Codec.from(
      (c: HCursor) =>
        c.as[ModifyGroupDMBody].orElse(c.as[ModifyGuildChannelBody]).orElse(c.as[ModifyThreadChannelBody]),
      {
        case m: ModifyGroupDMBody       => m.asJson
        case m: ModifyGuildChannelBody  => m.asJson
        case m: ModifyThreadChannelBody => m.asJson
      }
    )

    /** Fires a Channel Update Gateway event. */
    class ModifyGroupDMBody(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache)
        with ModifyChannelBody {

      /** 1-100 character channel name */
      @inline def name: UndefOr[String] = selectDynamic[UndefOr[String]]("name")

      @inline def withName(newValue: UndefOr[String]): ModifyGroupDMBody =
        objWithUndef(ModifyGroupDMBody, "name", newValue)

      /** Base64 encoded icon */
      @inline def icon: UndefOr[ImageData] = selectDynamic[UndefOr[ImageData]]("icon")

      @inline def withIcon(newValue: UndefOr[ImageData]): ModifyGroupDMBody =
        objWithUndef(ModifyGroupDMBody, "icon", newValue)

      override def values: Seq[() => Any] = Seq(() => name, () => icon)
    }
    object ModifyGroupDMBody extends DiscordObjectCompanion[ModifyGroupDMBody] {
      def makeRaw(json: Json, cache: Map[String, Any]): ModifyGroupDMBody =
        new ModifyGroupDMBody(json, cache)

      /**
        * @param name
        *   1-100 character channel name
        * @param icon
        *   Base64 encoded icon
        */
      def make20(
          name: UndefOr[String] = UndefOrUndefined(Some("name")),
          icon: UndefOr[ImageData] = UndefOrUndefined(Some("icon"))
      ): ModifyGroupDMBody = makeRawFromFields("name" :=? name, "icon" :=? icon)
    }

    /**
      * Requires the MANAGE_CHANNELS permission for the guild. Fires a Channel
      * Update Gateway event. If modifying a category, individual Channel Update
      * events will fire for each child channel that also changes. If modifying
      * permission overwrites, the MANAGE_ROLES permission is required. Only
      * permissions your bot has in the guild or parent channel (if applicable)
      * can be allowed/denied (unless your bot has a MANAGE_ROLES overwrite in
      * the channel).
      */
    class ModifyGuildChannelBody(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache)
        with ModifyChannelBody {

      /** 1-100 character channel name */
      @inline def name: UndefOr[String] = selectDynamic[UndefOr[String]]("name")

      @inline def withName(newValue: UndefOr[String]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "name", newValue)

      /**
        * The type of channel; only conversion between text and announcement is
        * supported and only in guilds with the "NEWS" feature
        */
      @inline def tpe: UndefOr[Channel.ChannelType] = selectDynamic[UndefOr[Channel.ChannelType]]("type")

      @inline def withTpe(newValue: UndefOr[Channel.ChannelType]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "type", newValue)

      /** The position of the channel in the left-hand listing */
      @inline def position: JsonOption[Int] = selectDynamic[JsonOption[Int]]("position")

      @inline def withPosition(newValue: JsonOption[Int]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "position", newValue)

      /**
        * 0-1024 character channel topic (0-4096 characters for GUILD_FORUM and
        * GUILD_MEDIA channels)
        */
      @inline def topic: JsonOption[String] = selectDynamic[JsonOption[String]]("topic")

      @inline def withTopic(newValue: JsonOption[String]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "topic", newValue)

      /** Whether the channel is nsfw */
      @inline def nsfw: JsonOption[Boolean] = selectDynamic[JsonOption[Boolean]]("nsfw")

      @inline def withNsfw(newValue: JsonOption[Boolean]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "nsfw", newValue)

      /**
        * Amount of seconds a user has to wait before sending another message
        * (0-21600); bots, as well as users with the permission manage_messages
        * or manage_channel, are unaffected
        */
      @inline def rateLimitPerUser: JsonOption[Int] = selectDynamic[JsonOption[Int]]("rate_limit_per_user")

      @inline def withRateLimitPerUser(newValue: JsonOption[Int]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "rate_limit_per_user", newValue)

      /** The bitrate (in bits) of the voice or stage channel; min 8000 */
      @inline def bitrate: JsonOption[Int] = selectDynamic[JsonOption[Int]]("bitrate")

      @inline def withBitrate(newValue: JsonOption[Int]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "bitrate", newValue)

      /**
        * The user limit of the voice or stage channel, max 99 for voice
        * channels and 10,000 for stage channels (0 refers to no limit)
        */
      @inline def userLimit: JsonOption[Int] = selectDynamic[JsonOption[Int]]("user_limit")

      @inline def withUserLimit(newValue: JsonOption[Int]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "user_limit", newValue)

      /** Channel or category-specific permissions */
      @inline def permissionOverwrites: JsonOption[ModifyGuildChannelBody.EditChannelPartialOverwrite] =
        selectDynamic[JsonOption[ModifyGuildChannelBody.EditChannelPartialOverwrite]]("permission_overwrites")

      @inline def withPermissionOverwrites(
          newValue: JsonOption[ModifyGuildChannelBody.EditChannelPartialOverwrite]
      ): ModifyGuildChannelBody = objWithUndef(ModifyGuildChannelBody, "permission_overwrites", newValue)

      /** Id of the new parent category for a channel */
      @inline def parentId: JsonOption[GuildCategoryId] = selectDynamic[JsonOption[GuildCategoryId]]("parent_id")

      @inline def withParentId(newValue: JsonOption[GuildCategoryId]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "parent_id", newValue)

      /** Channel voice region id, automatic when set to null */
      @inline def rtcRegion: JsonOption[VoiceRegion] = selectDynamic[JsonOption[VoiceRegion]]("rtc_region")

      @inline def withRtcRegion(newValue: JsonOption[VoiceRegion]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "rtc_region", newValue)

      /** The camera video quality mode of the voice channel */
      @inline def videoQualityMode: JsonOption[Channel.VideoQualityMode] =
        selectDynamic[JsonOption[Channel.VideoQualityMode]]("video_quality_mode")

      @inline def withVideoQualityMode(newValue: JsonOption[Channel.VideoQualityMode]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "video_quality_mode", newValue)

      /**
        * The default duration that the clients use (not the API) for newly
        * created threads in the channel, in minutes, to automatically archive
        * the thread after recent activity
        */
      @inline def defaultAutoArchiveDuration: JsonOption[Int] =
        selectDynamic[JsonOption[Int]]("default_auto_archive_duration")

      @inline def withDefaultAutoArchiveDuration(newValue: JsonOption[Int]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "default_auto_archive_duration", newValue)

      /**
        * Channel flags combined as a bitfield. Currently only REQUIRE_TAG (1 <<
        * 4) is supported by GUILD_FORUM and GUILD_MEDIA channels.
        * HIDE_MEDIA_DOWNLOAD_OPTIONS (1 << 15) is supported only by GUILD_MEDIA
        * channels
        */
      @inline def flags: UndefOr[Channel.ChannelFlags] = selectDynamic[UndefOr[Channel.ChannelFlags]]("flags")

      @inline def withFlags(newValue: UndefOr[Channel.ChannelFlags]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "flags", newValue)

      /**
        * The set of tags that can be used in a GUILD_FORUM or a GUILD_MEDIA
        * channel; limited to 20
        */
      @inline def availableTags: UndefOr[Seq[Channel.ForumTag]] =
        selectDynamic[UndefOr[Seq[Channel.ForumTag]]]("available_tags")

      @inline def withAvailableTags(newValue: UndefOr[Seq[Channel.ForumTag]]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "available_tags", newValue)

      /**
        * The emoji to show in the add reaction button on a thread in a
        * GUILD_FORUM or a GUILD_MEDIA channel
        */
      @inline def defaultReactionEmoji: JsonOption[Channel.DefaultReaction] =
        selectDynamic[JsonOption[Channel.DefaultReaction]]("default_reaction_emoji")

      @inline def withDefaultReactionEmoji(newValue: JsonOption[Channel.DefaultReaction]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "default_reaction_emoji", newValue)

      /**
        * The initial rate_limit_per_user to set on newly created threads in a
        * channel. This field is copied to the thread at creation time and does
        * not live update
        */
      @inline def defaultThreadRateLimitPerUser: UndefOr[Int] =
        selectDynamic[UndefOr[Int]]("default_thread_rate_limit_per_user")

      @inline def withDefaultThreadRateLimitPerUser(newValue: UndefOr[Int]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "default_thread_rate_limit_per_user", newValue)

      /**
        * The default sort order type used to order posts in GUILD_FORUM and
        * GUILD_MEDIA channels
        */
      @inline def defaultSortOrder: JsonOption[Channel.ForumSortOrder] =
        selectDynamic[JsonOption[Channel.ForumSortOrder]]("default_sort_order")

      @inline def withDefaultSortOrder(newValue: JsonOption[Channel.ForumSortOrder]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "default_sort_order", newValue)

      /**
        * The default forum layout type used to display posts in GUILD_FORUM
        * channels
        */
      @inline def defaultForumLayout: UndefOr[Channel.ForumLayout] =
        selectDynamic[UndefOr[Channel.ForumLayout]]("default_forum_layout")

      @inline def withDefaultForumLayout(newValue: UndefOr[Channel.ForumLayout]): ModifyGuildChannelBody =
        objWithUndef(ModifyGuildChannelBody, "default_forum_layout", newValue)

      override def values: Seq[() => Any] = Seq(
        () => name,
        () => tpe,
        () => position,
        () => topic,
        () => nsfw,
        () => rateLimitPerUser,
        () => bitrate,
        () => userLimit,
        () => permissionOverwrites,
        () => parentId,
        () => rtcRegion,
        () => videoQualityMode,
        () => defaultAutoArchiveDuration,
        () => flags,
        () => availableTags,
        () => defaultReactionEmoji,
        () => defaultThreadRateLimitPerUser,
        () => defaultSortOrder,
        () => defaultForumLayout
      )
    }
    object ModifyGuildChannelBody extends DiscordObjectCompanion[ModifyGuildChannelBody] {
      def makeRaw(json: Json, cache: Map[String, Any]): ModifyGuildChannelBody =
        new ModifyGuildChannelBody(json, cache)

      /**
        * @param name
        *   1-100 character channel name
        * @param tpe
        *   The type of channel; only conversion between text and announcement
        *   is supported and only in guilds with the "NEWS" feature
        * @param position
        *   The position of the channel in the left-hand listing
        * @param topic
        *   0-1024 character channel topic (0-4096 characters for GUILD_FORUM
        *   and GUILD_MEDIA channels)
        * @param nsfw
        *   Whether the channel is nsfw
        * @param rateLimitPerUser
        *   Amount of seconds a user has to wait before sending another message
        *   (0-21600); bots, as well as users with the permission
        *   manage_messages or manage_channel, are unaffected
        * @param bitrate
        *   The bitrate (in bits) of the voice or stage channel; min 8000
        * @param userLimit
        *   The user limit of the voice or stage channel, max 99 for voice
        *   channels and 10,000 for stage channels (0 refers to no limit)
        * @param permissionOverwrites
        *   Channel or category-specific permissions
        * @param parentId
        *   Id of the new parent category for a channel
        * @param rtcRegion
        *   Channel voice region id, automatic when set to null
        * @param videoQualityMode
        *   The camera video quality mode of the voice channel
        * @param defaultAutoArchiveDuration
        *   The default duration that the clients use (not the API) for newly
        *   created threads in the channel, in minutes, to automatically archive
        *   the thread after recent activity
        * @param flags
        *   Channel flags combined as a bitfield. Currently only REQUIRE_TAG (1
        *   << 4) is supported by GUILD_FORUM and GUILD_MEDIA channels.
        *   HIDE_MEDIA_DOWNLOAD_OPTIONS (1 << 15) is supported only by
        *   GUILD_MEDIA channels
        * @param availableTags
        *   The set of tags that can be used in a GUILD_FORUM or a GUILD_MEDIA
        *   channel; limited to 20
        * @param defaultReactionEmoji
        *   The emoji to show in the add reaction button on a thread in a
        *   GUILD_FORUM or a GUILD_MEDIA channel
        * @param defaultThreadRateLimitPerUser
        *   The initial rate_limit_per_user to set on newly created threads in a
        *   channel. This field is copied to the thread at creation time and
        *   does not live update
        * @param defaultSortOrder
        *   The default sort order type used to order posts in GUILD_FORUM and
        *   GUILD_MEDIA channels
        * @param defaultForumLayout
        *   The default forum layout type used to display posts in GUILD_FORUM
        *   channels
        */
      def make20(
          name: UndefOr[String] = UndefOrUndefined(Some("name")),
          tpe: UndefOr[Channel.ChannelType] = UndefOrUndefined(Some("tpe")),
          position: JsonOption[Int] = JsonUndefined(Some("position")),
          topic: JsonOption[String] = JsonUndefined(Some("topic")),
          nsfw: JsonOption[Boolean] = JsonUndefined(Some("nsfw")),
          rateLimitPerUser: JsonOption[Int] = JsonUndefined(Some("rate_limit_per_user")),
          bitrate: JsonOption[Int] = JsonUndefined(Some("bitrate")),
          userLimit: JsonOption[Int] = JsonUndefined(Some("user_limit")),
          permissionOverwrites: JsonOption[ModifyGuildChannelBody.EditChannelPartialOverwrite] = JsonUndefined(
            Some("permission_overwrites")
          ),
          parentId: JsonOption[GuildCategoryId] = JsonUndefined(Some("parent_id")),
          rtcRegion: JsonOption[VoiceRegion] = JsonUndefined(Some("rtc_region")),
          videoQualityMode: JsonOption[Channel.VideoQualityMode] = JsonUndefined(Some("video_quality_mode")),
          defaultAutoArchiveDuration: JsonOption[Int] = JsonUndefined(Some("default_auto_archive_duration")),
          flags: UndefOr[Channel.ChannelFlags] = UndefOrUndefined(Some("flags")),
          availableTags: UndefOr[Seq[Channel.ForumTag]] = UndefOrUndefined(Some("available_tags")),
          defaultReactionEmoji: JsonOption[Channel.DefaultReaction] = JsonUndefined(Some("default_reaction_emoji")),
          defaultThreadRateLimitPerUser: UndefOr[Int] = UndefOrUndefined(Some("default_thread_rate_limit_per_user")),
          defaultSortOrder: JsonOption[Channel.ForumSortOrder] = JsonUndefined(Some("default_sort_order")),
          defaultForumLayout: UndefOr[Channel.ForumLayout] = UndefOrUndefined(Some("default_forum_layout"))
      ): ModifyGuildChannelBody = makeRawFromFields(
        "name"                               :=? name,
        "type"                               :=? tpe,
        "position"                           :=? position,
        "topic"                              :=? topic,
        "nsfw"                               :=? nsfw,
        "rate_limit_per_user"                :=? rateLimitPerUser,
        "bitrate"                            :=? bitrate,
        "user_limit"                         :=? userLimit,
        "permission_overwrites"              :=? permissionOverwrites,
        "parent_id"                          :=? parentId,
        "rtc_region"                         :=? rtcRegion,
        "video_quality_mode"                 :=? videoQualityMode,
        "default_auto_archive_duration"      :=? defaultAutoArchiveDuration,
        "flags"                              :=? flags,
        "available_tags"                     :=? availableTags,
        "default_reaction_emoji"             :=? defaultReactionEmoji,
        "default_thread_rate_limit_per_user" :=? defaultThreadRateLimitPerUser,
        "default_sort_order"                 :=? defaultSortOrder,
        "default_forum_layout"               :=? defaultForumLayout
      )

      class EditChannelPartialOverwrite(json: Json, cache: Map[String, Any] = Map.empty)
          extends DiscordObject(json, cache) {

        /** Role or user id */
        @inline def id: UserOrRoleId = selectDynamic[UserOrRoleId]("id")

        @inline def withId(newValue: UserOrRoleId): EditChannelPartialOverwrite =
          objWith(EditChannelPartialOverwrite, "id", newValue)

        /** Either 0 (role) or 1 (member) */
        @inline def tpe: Channel.PermissionOverwrite.PermissionOverwriteType =
          selectDynamic[Channel.PermissionOverwrite.PermissionOverwriteType]("type")

        @inline def withTpe(
            newValue: Channel.PermissionOverwrite.PermissionOverwriteType
        ): EditChannelPartialOverwrite = objWith(EditChannelPartialOverwrite, "type", newValue)

        /** Permission bit set */
        @inline def allow: JsonOption[Permissions] = selectDynamic[JsonOption[Permissions]]("allow")

        @inline def withAllow(newValue: JsonOption[Permissions]): EditChannelPartialOverwrite =
          objWithUndef(EditChannelPartialOverwrite, "allow", newValue)

        /** Permission bit set */
        @inline def deny: JsonOption[Permissions] = selectDynamic[JsonOption[Permissions]]("deny")

        @inline def withDeny(newValue: JsonOption[Permissions]): EditChannelPartialOverwrite =
          objWithUndef(EditChannelPartialOverwrite, "deny", newValue)

        override def values: Seq[() => Any] = Seq(() => id, () => tpe, () => allow, () => deny)
      }
      object EditChannelPartialOverwrite extends DiscordObjectCompanion[EditChannelPartialOverwrite] {
        def makeRaw(json: Json, cache: Map[String, Any]): EditChannelPartialOverwrite =
          new EditChannelPartialOverwrite(json, cache)

        /**
          * @param id
          *   Role or user id
          * @param tpe
          *   Either 0 (role) or 1 (member)
          * @param allow
          *   Permission bit set
          * @param deny
          *   Permission bit set
          */
        def make20(
            id: UserOrRoleId,
            tpe: Channel.PermissionOverwrite.PermissionOverwriteType,
            allow: JsonOption[Permissions] = JsonUndefined(Some("allow")),
            deny: JsonOption[Permissions] = JsonUndefined(Some("deny"))
        ): EditChannelPartialOverwrite =
          makeRawFromFields("id" := id, "type" := tpe, "allow" :=? allow, "deny" :=? deny)
      }
    }

    class ModifyThreadChannelBody(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache)
        with ModifyChannelBody {

      /** 1-100 character channel name */
      @inline def name: UndefOr[String] = selectDynamic[UndefOr[String]]("name")

      @inline def withName(newValue: UndefOr[String]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "name", newValue)

      /** Whether the thread is archived */
      @inline def archived: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("archived")

      @inline def withArchived(newValue: UndefOr[Boolean]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "archived", newValue)

      /**
        * The thread will stop showing in the channel list after
        * auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
        * 4320, 10080
        */
      @inline def autoArchiveDuration: UndefOr[Int] = selectDynamic[UndefOr[Int]]("auto_archive_duration")

      @inline def withAutoArchiveDuration(newValue: UndefOr[Int]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "auto_archive_duration", newValue)

      /**
        * Whether the thread is locked; when a thread is locked, only users with
        * MANAGE_THREADS can unarchive it
        */
      @inline def locked: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("locked")

      @inline def withLocked(newValue: UndefOr[Boolean]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "locked", newValue)

      /**
        * Whether non-moderators can add other non-moderators to a thread; only
        * available on private threads
        */
      @inline def invitable: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("invitable")

      @inline def withInvitable(newValue: UndefOr[Boolean]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "invitable", newValue)

      /**
        * Amount of seconds a user has to wait before sending another message
        * (0-21600); bots, as well as users with the permission manage_messages,
        * manage_thread, or manage_channel, are unaffected
        */
      @inline def rateLimitPerUser: JsonOption[Int] = selectDynamic[JsonOption[Int]]("rate_limit_per_user")

      @inline def withRateLimitPerUser(newValue: JsonOption[Int]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "rate_limit_per_user", newValue)

      /**
        * Channel flags combined as a bitfield; PINNED can only be set for
        * threads in forum and media channels
        */
      @inline def flags: UndefOr[Channel.ChannelFlags] = selectDynamic[UndefOr[Channel.ChannelFlags]]("flags")

      @inline def withFlags(newValue: UndefOr[Channel.ChannelFlags]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "flags", newValue)

      /**
        * The IDs of the set of tags that have been applied to a thread in a
        * GUILD_FORUM or a GUILD_MEDIA channel; limited to 5
        */
      @inline def appliedTags: UndefOr[Seq[Snowflake[Channel.ForumTag]]] =
        selectDynamic[UndefOr[Seq[Snowflake[Channel.ForumTag]]]]("applied_tags")

      @inline def withAppliedTags(newValue: UndefOr[Seq[Snowflake[Channel.ForumTag]]]): ModifyThreadChannelBody =
        objWithUndef(ModifyThreadChannelBody, "applied_tags", newValue)

      override def values: Seq[() => Any] = Seq(
        () => name,
        () => archived,
        () => autoArchiveDuration,
        () => locked,
        () => invitable,
        () => rateLimitPerUser,
        () => flags,
        () => appliedTags
      )
    }
    object ModifyThreadChannelBody extends DiscordObjectCompanion[ModifyThreadChannelBody] {
      def makeRaw(json: Json, cache: Map[String, Any]): ModifyThreadChannelBody =
        new ModifyThreadChannelBody(json, cache)

      /**
        * @param name
        *   1-100 character channel name
        * @param archived
        *   Whether the thread is archived
        * @param autoArchiveDuration
        *   The thread will stop showing in the channel list after
        *   auto_archive_duration minutes of inactivity, can be set to: 60,
        *   1440, 4320, 10080
        * @param locked
        *   Whether the thread is locked; when a thread is locked, only users
        *   with MANAGE_THREADS can unarchive it
        * @param invitable
        *   Whether non-moderators can add other non-moderators to a thread;
        *   only available on private threads
        * @param rateLimitPerUser
        *   Amount of seconds a user has to wait before sending another message
        *   (0-21600); bots, as well as users with the permission
        *   manage_messages, manage_thread, or manage_channel, are unaffected
        * @param flags
        *   Channel flags combined as a bitfield; PINNED can only be set for
        *   threads in forum and media channels
        * @param appliedTags
        *   The IDs of the set of tags that have been applied to a thread in a
        *   GUILD_FORUM or a GUILD_MEDIA channel; limited to 5
        */
      def make20(
          name: UndefOr[String] = UndefOrUndefined(Some("name")),
          archived: UndefOr[Boolean] = UndefOrUndefined(Some("archived")),
          autoArchiveDuration: UndefOr[Int] = UndefOrUndefined(Some("auto_archive_duration")),
          locked: UndefOr[Boolean] = UndefOrUndefined(Some("locked")),
          invitable: UndefOr[Boolean] = UndefOrUndefined(Some("invitable")),
          rateLimitPerUser: JsonOption[Int] = JsonUndefined(Some("rate_limit_per_user")),
          flags: UndefOr[Channel.ChannelFlags] = UndefOrUndefined(Some("flags")),
          appliedTags: UndefOr[Seq[Snowflake[Channel.ForumTag]]] = UndefOrUndefined(Some("applied_tags"))
      ): ModifyThreadChannelBody = makeRawFromFields(
        "name"                  :=? name,
        "archived"              :=? archived,
        "auto_archive_duration" :=? autoArchiveDuration,
        "locked"                :=? locked,
        "invitable"             :=? invitable,
        "rate_limit_per_user"   :=? rateLimitPerUser,
        "flags"                 :=? flags,
        "applied_tags"          :=? appliedTags
      )
    }
  }

  /**
    * Delete a channel, or close a private message. Requires the MANAGE_CHANNELS
    * permission for the guild, or MANAGE_THREADS if the channel is a thread.
    * Deleting a category does not delete its child channels; they will have
    * their parent_id removed and a Channel Update Gateway event will fire for
    * each of them. Returns a channel object on success. Fires a Channel Delete
    * Gateway event (or Thread Delete if the channel was a thread).
    */
  def deleteCloseChannel(channelId: ChannelId, reason: Option[String]): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true))
        .toRequest(Method.DELETE),
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  /**
    * Retrieves a specific message in the channel. Returns a message object on
    * success.
    *
    * If operating on a guild channel, this endpoint requires the current user
    * to have the VIEW_CHANNEL and READ_MESSAGE_HISTORY permissions. If the
    * channel is a voice channel, they must also have the CONNECT permission.
    */
  def getChannelMessage(channelId: ChannelId, messageId: MessageId): Request[Unit, Message] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.GET)
    )

  class CreateMessageBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Message contents (up to 2000 characters) */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    @inline def withContent(newValue: UndefOr[String]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "content", newValue)

    /**
      * Can be used to verify a message was sent (up to 25 characters). Value
      * will appear in the Message Create event.
      */
    @inline def nonce: UndefOr[IntOrString] = selectDynamic[UndefOr[IntOrString]]("nonce")

    @inline def withNonce(newValue: UndefOr[IntOrString]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "nonce", newValue)

    /** true if this is a TTS message */
    @inline def tts: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("tts")

    @inline def withTts(newValue: UndefOr[Boolean]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "tts", newValue)

    /** Up to 10 rich embeds (up to 6000 characters) */
    @inline def embeds: UndefOr[Seq[OutgoingEmbed]] = selectDynamic[UndefOr[Seq[OutgoingEmbed]]]("embeds")

    @inline def withEmbeds(newValue: UndefOr[Seq[OutgoingEmbed]]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "embeds", newValue)

    /** Allowed mentions for the message */
    @inline def allowedMentions: UndefOr[AllowedMentions] = selectDynamic[UndefOr[AllowedMentions]]("allowed_mentions")

    @inline def withAllowedMentions(newValue: UndefOr[AllowedMentions]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "allowed_mentions", newValue)

    /** Include to make your message a reply */
    @inline def messageReference: UndefOr[MessageReference] =
      selectDynamic[UndefOr[MessageReference]]("message_reference")

    @inline def withMessageReference(newValue: UndefOr[MessageReference]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "message_reference", newValue)

    /** Components to include with the message */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    @inline def withComponents(newValue: UndefOr[Seq[Component]]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "components", newValue)

    /** IDs of up to 3 stickers in the server to send in the message */
    @inline def stickerIds: UndefOr[Seq[RawSnowflake]] = selectDynamic[UndefOr[Seq[RawSnowflake]]]("sticker_ids")

    @inline def withStickerIds(newValue: UndefOr[Seq[RawSnowflake]]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "sticker_ids", newValue)

    /** Attachment objects with filename and description */
    @inline def attachments: UndefOr[Seq[MessageCreateEditAttachment]] =
      selectDynamic[UndefOr[Seq[MessageCreateEditAttachment]]]("attachments")

    @inline def withAttachments(newValue: UndefOr[Seq[MessageCreateEditAttachment]]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "attachments", newValue)

    /**
      * Message flags combined as a bitfield (only SUPPRESS_EMBEDS and
      * SUPPRESS_NOTIFICATIONS can be set)
      */
    @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

    @inline def withFlags(newValue: UndefOr[Message.MessageFlags]): CreateMessageBody =
      objWithUndef(CreateMessageBody, "flags", newValue)

    override def values: Seq[() => Any] = Seq(
      () => content,
      () => nonce,
      () => tts,
      () => embeds,
      () => allowedMentions,
      () => messageReference,
      () => components,
      () => stickerIds,
      () => attachments,
      () => flags
    )
  }
  object CreateMessageBody
      extends DiscordObjectCompanion[CreateMessageBody]
      with CreateMessageLikeMixin[CreateMessageBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): CreateMessageBody =
      new CreateMessageBody(json, cache)

    /**
      * @param content
      *   Message contents (up to 2000 characters)
      * @param nonce
      *   Can be used to verify a message was sent (up to 25 characters). Value
      *   will appear in the Message Create event.
      * @param tts
      *   true if this is a TTS message
      * @param embeds
      *   Up to 10 rich embeds (up to 6000 characters)
      * @param allowedMentions
      *   Allowed mentions for the message
      * @param messageReference
      *   Include to make your message a reply
      * @param components
      *   Components to include with the message
      * @param stickerIds
      *   IDs of up to 3 stickers in the server to send in the message
      * @param attachments
      *   Attachment objects with filename and description
      * @param flags
      *   Message flags combined as a bitfield (only SUPPRESS_EMBEDS and
      *   SUPPRESS_NOTIFICATIONS can be set)
      */
    def make20(
        content: UndefOr[String] = UndefOrUndefined(Some("content")),
        nonce: UndefOr[IntOrString] = UndefOrUndefined(Some("nonce")),
        tts: UndefOr[Boolean] = UndefOrUndefined(Some("tts")),
        embeds: UndefOr[Seq[OutgoingEmbed]] = UndefOrUndefined(Some("embeds")),
        allowedMentions: UndefOr[AllowedMentions] = UndefOrUndefined(Some("allowed_mentions")),
        messageReference: UndefOr[MessageReference] = UndefOrUndefined(Some("message_reference")),
        components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
        stickerIds: UndefOr[Seq[RawSnowflake]] = UndefOrUndefined(Some("sticker_ids")),
        attachments: UndefOr[Seq[MessageCreateEditAttachment]] = UndefOrUndefined(Some("attachments")),
        flags: UndefOr[Message.MessageFlags] = UndefOrUndefined(Some("flags"))
    ): CreateMessageBody = makeRawFromFields(
      "content"           :=? content,
      "nonce"             :=? nonce,
      "tts"               :=? tts,
      "embeds"            :=? embeds,
      "allowed_mentions"  :=? allowedMentions,
      "message_reference" :=? messageReference,
      "components"        :=? components,
      "sticker_ids"       :=? stickerIds,
      "attachments"       :=? attachments,
      "flags"             :=? flags
    )
  }

  /**
    * Post a message to a guild text or DM channel. Returns a message object.
    * Fires a Message Create Gateway event. See message formatting for more
    * information on how to properly format messages.
    *
    * To create a message as a reply to another message, apps can include a
    * message_reference with a message_id. The channel_id and guild_id in the
    * message_reference are optional, but will be validated if provided.
    *
    * Files must be attached using a multipart/form-data body as described in
    * Uploading Files. **Limitations:**
    *
    *   - When operating on a guild channel, the current user must have the
    *     SEND_MESSAGES permission.
    *   - When sending a message with tts (text-to-speech) set to true, the
    *     current user must have the SEND_TTS_MESSAGES permission.
    *   - When creating a message as a reply to another message, the current
    *     user must have the READ_MESSAGE_HISTORY permission.
    *   - - The referenced message must exist and cannot be a system message.
    *   - The maximum request size when sending a message is 25 MiB
    *   - For the embed object, you can set every field except type (it will be
    *     rich regardless of if you try to set it), provider, video, and any
    *     height, width, or proxy_url values for images.
    */
  def createMessage[MPR](
      channelId: ChannelId,
      body: CreateMessageBody,
      parts: Seq[EncodeBody.Multipart[_, MPR]] = Nil
  ): ComplexRequest[CreateMessageBody, Message, MPR, Any] =
    Request.complexRestRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "messages")
        .toRequest(Method.POST),
      params = body,
      requestBody = Some(
        EncodeBody.MultipartBody(
          EncodeBody.Multipart.EncodeJson(body, "payload_json"),
          parts.zipWithIndex.map(t => t._1.withName(s"files[${t._2}]"))
        )
      )
    )

  class MessageCreateEditAttachment(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** Attachment id */
    @inline def id: Snowflake[Attachment] = selectDynamic[Snowflake[Attachment]]("id")

    @inline def withId(newValue: Snowflake[Attachment]): MessageCreateEditAttachment =
      objWith(MessageCreateEditAttachment, "id", newValue)

    /** Name of file attached */
    @inline def filename: UndefOr[String] = selectDynamic[UndefOr[String]]("filename")

    @inline def withFilename(newValue: UndefOr[String]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "filename", newValue)

    /** Description for the file (max 1024 characters) */
    @inline def description: UndefOr[String] = selectDynamic[UndefOr[String]]("description")

    @inline def withDescription(newValue: UndefOr[String]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "description", newValue)

    /** The attachment's media type */
    @inline def contentType: UndefOr[String] = selectDynamic[UndefOr[String]]("content_type")

    @inline def withContentType(newValue: UndefOr[String]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "content_type", newValue)

    /** Size of file in bytes */
    @inline def size: UndefOr[Int] = selectDynamic[UndefOr[Int]]("size")

    @inline def withSize(newValue: UndefOr[Int]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "size", newValue)

    /** Source url of file */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    @inline def withUrl(newValue: UndefOr[String]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "url", newValue)

    /** A proxied url of file */
    @inline def proxyUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_url")

    @inline def withProxyUrl(newValue: UndefOr[String]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "proxy_url", newValue)

    /** Height of file (if image) */
    @inline def height: JsonOption[Int] = selectDynamic[JsonOption[Int]]("height")

    @inline def withHeight(newValue: JsonOption[Int]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "height", newValue)

    /** Width of file (if image) */
    @inline def width: JsonOption[Int] = selectDynamic[JsonOption[Int]]("width")

    @inline def withWidth(newValue: JsonOption[Int]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "width", newValue)

    /** Whether this attachment is ephemeral */
    @inline def ephemeral: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("ephemeral")

    @inline def withEphemeral(newValue: UndefOr[Boolean]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "ephemeral", newValue)

    /** The duration of the audio file (currently for voice messages) */
    @inline def durationSecs: UndefOr[Float] = selectDynamic[UndefOr[Float]]("duration_secs")

    @inline def withDurationSecs(newValue: UndefOr[Float]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "duration_secs", newValue)

    /**
      * Base64 encoded bytearray representing a sampled waveform (currently for
      * voice messages)
      */
    @inline def waveform: UndefOr[String] = selectDynamic[UndefOr[String]]("waveform")

    @inline def withWaveform(newValue: UndefOr[String]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "waveform", newValue)

    /** Attachment flags combined as a bitfield */
    @inline def flags: UndefOr[Attachment.AttachmentFlags] = selectDynamic[UndefOr[Attachment.AttachmentFlags]]("flags")

    @inline def withFlags(newValue: UndefOr[Attachment.AttachmentFlags]): MessageCreateEditAttachment =
      objWithUndef(MessageCreateEditAttachment, "flags", newValue)

    override def values: Seq[() => Any] = Seq(
      () => id,
      () => filename,
      () => description,
      () => contentType,
      () => size,
      () => url,
      () => proxyUrl,
      () => height,
      () => width,
      () => ephemeral,
      () => durationSecs,
      () => waveform,
      () => flags
    )
  }
  object MessageCreateEditAttachment extends DiscordObjectCompanion[MessageCreateEditAttachment] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageCreateEditAttachment =
      new MessageCreateEditAttachment(json, cache)

    /**
      * @param id
      *   Attachment id
      * @param filename
      *   Name of file attached
      * @param description
      *   Description for the file (max 1024 characters)
      * @param contentType
      *   The attachment's media type
      * @param size
      *   Size of file in bytes
      * @param url
      *   Source url of file
      * @param proxyUrl
      *   A proxied url of file
      * @param height
      *   Height of file (if image)
      * @param width
      *   Width of file (if image)
      * @param ephemeral
      *   Whether this attachment is ephemeral
      * @param durationSecs
      *   The duration of the audio file (currently for voice messages)
      * @param waveform
      *   Base64 encoded bytearray representing a sampled waveform (currently
      *   for voice messages)
      * @param flags
      *   Attachment flags combined as a bitfield
      */
    def make20(
        id: Snowflake[Attachment],
        filename: UndefOr[String] = UndefOrUndefined(Some("filename")),
        description: UndefOr[String] = UndefOrUndefined(Some("description")),
        contentType: UndefOr[String] = UndefOrUndefined(Some("content_type")),
        size: UndefOr[Int] = UndefOrUndefined(Some("size")),
        url: UndefOr[String] = UndefOrUndefined(Some("url")),
        proxyUrl: UndefOr[String] = UndefOrUndefined(Some("proxy_url")),
        height: JsonOption[Int] = JsonUndefined(Some("height")),
        width: JsonOption[Int] = JsonUndefined(Some("width")),
        ephemeral: UndefOr[Boolean] = UndefOrUndefined(Some("ephemeral")),
        durationSecs: UndefOr[Float] = UndefOrUndefined(Some("duration_secs")),
        waveform: UndefOr[String] = UndefOrUndefined(Some("waveform")),
        flags: UndefOr[Attachment.AttachmentFlags] = UndefOrUndefined(Some("flags"))
    ): MessageCreateEditAttachment = makeRawFromFields(
      "id"             := id,
      "filename"      :=? filename,
      "description"   :=? description,
      "content_type"  :=? contentType,
      "size"          :=? size,
      "url"           :=? url,
      "proxy_url"     :=? proxyUrl,
      "height"        :=? height,
      "width"         :=? width,
      "ephemeral"     :=? ephemeral,
      "duration_secs" :=? durationSecs,
      "waveform"      :=? waveform,
      "flags"         :=? flags
    )
  }

  /**
    * Crosspost a message in an Announcement Channel to following channels. This
    * endpoint requires the SEND_MESSAGES permission, if the current user sent
    * the message, or additionally the MANAGE_MESSAGES permission, for all other
    * messages, to be present for the current user.
    *
    * Returns a message object. Fires a Message Update Gateway event.
    */
  def crosspostMessage(channelId: ChannelId, messageId: MessageId): Request[Unit, Message] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "crosspost").toRequest(Method.POST)
    )

  /**
    * Create a reaction for the message. This endpoint requires the
    * READ_MESSAGE_HISTORY permission to be present on the current user.
    * Additionally, if nobody else has reacted to the message using this emoji,
    * this endpoint requires the ADD_REACTIONS permission to be present on the
    * current user. Returns a 204 empty response on success. Fires a Message
    * Reaction Add Gateway event. The emoji must be URL Encoded or the request
    * will fail with 10014: Unknown Emoji. To use custom emoji, you must encode
    * it in the format name:id with the emoji name and emoji id.
    */
  def createReaction(channelId: ChannelId, messageId: MessageId, emoji: Emoji): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "reactions" / Parameters[Emoji](
        "emoji",
        emoji
      ) / "@me").toRequest(Method.PUT)
    )

  /**
    * Delete a reaction the current user has made for the message. Returns a 204
    * empty response on success. Fires a Message Reaction Remove Gateway event.
    * The emoji must be URL Encoded or the request will fail with 10014: Unknown
    * Emoji. To use custom emoji, you must encode it in the format name:id with
    * the emoji name and emoji id.
    */
  def deleteOwnReaction(channelId: ChannelId, messageId: MessageId, emoji: Emoji): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "reactions" / Parameters[Emoji](
        "emoji",
        emoji
      ) / "@me").toRequest(Method.DELETE)
    )

  /**
    * Deletes another user's reaction. This endpoint requires the
    * MANAGE_MESSAGES permission to be present on the current user. Returns a
    * 204 empty response on success. Fires a Message Reaction Remove Gateway
    * event. The emoji must be URL Encoded or the request will fail with 10014:
    * Unknown Emoji. To use custom emoji, you must encode it in the format
    * name:id with the emoji name and emoji id.
    */
  def deleteUserReaction(
      channelId: ChannelId,
      messageId: MessageId,
      emoji: Emoji,
      userId: UserId
  ): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "reactions" / Parameters[Emoji](
        "emoji",
        emoji
      ) / Parameters[UserId]("userId", userId)).toRequest(Method.DELETE)
    )

  class GetReactionsQuery(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Get users after this user ID */
    @inline def after: UndefOr[RawSnowflake] = selectDynamic[UndefOr[RawSnowflake]]("after")

    @inline def withAfter(newValue: UndefOr[RawSnowflake]): GetReactionsQuery =
      objWithUndef(GetReactionsQuery, "after", newValue)

    /** Max number of users to return (1-100) */
    @inline def limit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("limit")

    @inline def withLimit(newValue: UndefOr[Int]): GetReactionsQuery =
      objWithUndef(GetReactionsQuery, "limit", newValue)

    override def values: Seq[() => Any] = Seq(() => after, () => limit)
  }
  object GetReactionsQuery extends DiscordObjectCompanion[GetReactionsQuery] {
    def makeRaw(json: Json, cache: Map[String, Any]): GetReactionsQuery =
      new GetReactionsQuery(json, cache)

    /**
      * @param after
      *   Get users after this user ID
      * @param limit
      *   Max number of users to return (1-100)
      */
    def make20(
        after: UndefOr[RawSnowflake] = UndefOrUndefined(Some("after")),
        limit: UndefOr[Int] = UndefOrUndefined(Some("limit"))
    ): GetReactionsQuery = makeRawFromFields("after" :=? after, "limit" :=? limit)
  }

  /**
    * Get a list of users that reacted with this emoji. Returns an array of user
    * objects on success. The emoji must be URL Encoded or the request will fail
    * with 10014: Unknown Emoji. To use custom emoji, you must encode it in the
    * format name:id with the emoji name and emoji id.
    */
  def getReactions(
      channelId: ChannelId,
      messageId: MessageId,
      emoji: Emoji,
      query: GetReactionsQuery = GetReactionsQuery.make20()
  ): Request[Unit, Seq[User]] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "reactions" / Parameters[Emoji](
        "emoji",
        emoji
      ) +? Parameters.query("after", query.after) +? Parameters.query("limit", query.limit)).toRequest(Method.GET)
    )

  /**
    * Deletes all reactions on a message. This endpoint requires the
    * MANAGE_MESSAGES permission to be present on the current user. Fires a
    * Message Reaction Remove All Gateway event.
    */
  def deleteAllReactions(channelId: ChannelId, messageId: MessageId): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "reactions").toRequest(Method.DELETE)
    )

  /**
    * Deletes all the reactions for a given emoji on a message. This endpoint
    * requires the MANAGE_MESSAGES permission to be present on the current user.
    * Fires a Message Reaction Remove Emoji Gateway event. The emoji must be URL
    * Encoded or the request will fail with 10014: Unknown Emoji. To use custom
    * emoji, you must encode it in the format name:id with the emoji name and
    * emoji id.
    */
  def deleteAllReactionsForEmoji(channelId: ChannelId, messageId: MessageId, emoji: Emoji): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "reactions" / Parameters[Emoji]("emoji", emoji))
        .toRequest(Method.DELETE)
    )

  class EditMessageBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Message contents (up to 2000 characters) */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    @inline def withContent(newValue: UndefOr[String]): EditMessageBody =
      objWithUndef(EditMessageBody, "content", newValue)

    /** Up to 10 rich embeds (up to 6000 characters) */
    @inline def embeds: UndefOr[Seq[OutgoingEmbed]] = selectDynamic[UndefOr[Seq[OutgoingEmbed]]]("embeds")

    @inline def withEmbeds(newValue: UndefOr[Seq[OutgoingEmbed]]): EditMessageBody =
      objWithUndef(EditMessageBody, "embeds", newValue)

    /**
      * Edit the flags of a message (only SUPPRESS_EMBEDS can currently be
      * set/unset)
      */
    @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

    @inline def withFlags(newValue: UndefOr[Message.MessageFlags]): EditMessageBody =
      objWithUndef(EditMessageBody, "flags", newValue)

    /** Allowed mentions for the message */
    @inline def allowedMentions: UndefOr[AllowedMentions] = selectDynamic[UndefOr[AllowedMentions]]("allowed_mentions")

    @inline def withAllowedMentions(newValue: UndefOr[AllowedMentions]): EditMessageBody =
      objWithUndef(EditMessageBody, "allowed_mentions", newValue)

    /** Components to include with the message */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    @inline def withComponents(newValue: UndefOr[Seq[Component]]): EditMessageBody =
      objWithUndef(EditMessageBody, "components", newValue)

    /**
      * Attached files to keep and possible descriptions for new files. See
      * Uploading Files
      */
    @inline def attachments: UndefOr[Seq[MessageCreateEditAttachment]] =
      selectDynamic[UndefOr[Seq[MessageCreateEditAttachment]]]("attachments")

    @inline def withAttachments(newValue: UndefOr[Seq[MessageCreateEditAttachment]]): EditMessageBody =
      objWithUndef(EditMessageBody, "attachments", newValue)

    override def values: Seq[() => Any] =
      Seq(() => content, () => embeds, () => flags, () => allowedMentions, () => components, () => attachments)
  }
  object EditMessageBody extends DiscordObjectCompanion[EditMessageBody] with CreateMessageLikeMixin[EditMessageBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): EditMessageBody =
      new EditMessageBody(json, cache)

    /**
      * @param content
      *   Message contents (up to 2000 characters)
      * @param embeds
      *   Up to 10 rich embeds (up to 6000 characters)
      * @param flags
      *   Edit the flags of a message (only SUPPRESS_EMBEDS can currently be
      *   set/unset)
      * @param allowedMentions
      *   Allowed mentions for the message
      * @param components
      *   Components to include with the message
      * @param attachments
      *   Attached files to keep and possible descriptions for new files. See
      *   Uploading Files
      */
    def make20(
        content: UndefOr[String] = UndefOrUndefined(Some("content")),
        embeds: UndefOr[Seq[OutgoingEmbed]] = UndefOrUndefined(Some("embeds")),
        flags: UndefOr[Message.MessageFlags] = UndefOrUndefined(Some("flags")),
        allowedMentions: UndefOr[AllowedMentions] = UndefOrUndefined(Some("allowed_mentions")),
        components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
        attachments: UndefOr[Seq[MessageCreateEditAttachment]] = UndefOrUndefined(Some("attachments"))
    ): EditMessageBody = makeRawFromFields(
      "content"          :=? content,
      "embeds"           :=? embeds,
      "flags"            :=? flags,
      "allowed_mentions" :=? allowedMentions,
      "components"       :=? components,
      "attachments"      :=? attachments
    )
  }

  /**
    * Edit a previously sent message. The fields content, embeds, and flags can
    * be edited by the original message author. Other users can only edit flags
    * and only if they have the MANAGE_MESSAGES permission in the corresponding
    * channel. When specifying flags, ensure to include all previously set
    * flags/bits in addition to ones that you are modifying. Only flags
    * documented in the table below may be modified by users (unsupported flag
    * changes are currently ignored without error).
    *
    * When the content field is edited, the mentions array in the message object
    * will be reconstructed from scratch based on the new content. The
    * allowed_mentions field of the edit request controls how this happens. If
    * there is no explicit allowed_mentions in the edit request, the content
    * will be parsed with default allowances, that is, without regard to whether
    * or not an allowed_mentions was present in the request that originally
    * created the message.
    *
    * Returns a message object. Fires a Message Update Gateway event.
    *
    * Refer to Uploading Files for details on attachments and
    * multipart/form-data requests. Any provided files will be appended to the
    * message. To remove or replace files you will have to supply the
    * attachments field which specifies the files to retain on the message after
    * edit.
    */
  def editMessage[MPR](
      channelId: ChannelId,
      messageId: MessageId,
      body: EditMessageBody,
      parts: Seq[EncodeBody.Multipart[_, MPR]] = Nil
  ): ComplexRequest[EditMessageBody, Message, MPR, Any] =
    Request.complexRestRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.PATCH),
      params = body,
      requestBody = Some(
        EncodeBody.MultipartBody(
          EncodeBody.Multipart.EncodeJson(body, "payload_json"),
          parts.zipWithIndex.map(t => t._1.withName(s"files[${t._2}]"))
        )
      )
    )

  /**
    * Delete a message. If operating on a guild channel and trying to delete a
    * message that was not sent by the current user, this endpoint requires the
    * MANAGE_MESSAGES permission. Returns a 204 empty response on success. Fires
    * a Message Delete Gateway event.
    */
  def deleteMessage(
      channelId: ChannelId,
      messageId: MessageId,
      reason: Option[String]
  ): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.DELETE),
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  class BulkDeleteMessagesBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** An array of message ids to delete (2-100) */
    @inline def messages: Seq[MessageId] = selectDynamic[Seq[MessageId]]("messages")

    @inline def withMessages(newValue: Seq[MessageId]): BulkDeleteMessagesBody =
      objWith(BulkDeleteMessagesBody, "messages", newValue)

    override def values: Seq[() => Any] = Seq(() => messages)
  }
  object BulkDeleteMessagesBody extends DiscordObjectCompanion[BulkDeleteMessagesBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): BulkDeleteMessagesBody =
      new BulkDeleteMessagesBody(json, cache)

    /**
      * @param messages
      *   An array of message ids to delete (2-100)
      */
    def make20(messages: Seq[MessageId]): BulkDeleteMessagesBody = makeRawFromFields("messages" := messages)
  }

  /**
    * Delete multiple messages in a single request. This endpoint can only be
    * used on guild channels and requires the MANAGE_MESSAGES permission.
    * Returns a 204 empty response on success. Fires a Message Delete Bulk
    * Gateway event.
    *
    * Any message IDs given that do not exist or are invalid will count towards
    * the minimum and maximum message count (currently 2 and 100 respectively).
    */
  def bulkDeleteMessages(
      channelId: ChannelId,
      body: BulkDeleteMessagesBody,
      reason: Option[String]
  ): Request[BulkDeleteMessagesBody, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / "bulk-delete").toRequest(Method.POST),
      params = body,
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  class EditChannelPermissionsBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The bitwise value of all allowed permissions (default "0") */
    @inline def allow: JsonOption[String] = selectDynamic[JsonOption[String]]("allow")

    @inline def withAllow(newValue: JsonOption[String]): EditChannelPermissionsBody =
      objWithUndef(EditChannelPermissionsBody, "allow", newValue)

    /** The bitwise value of all disallowed permissions (default "0") */
    @inline def deny: JsonOption[String] = selectDynamic[JsonOption[String]]("deny")

    @inline def withDeny(newValue: JsonOption[String]): EditChannelPermissionsBody =
      objWithUndef(EditChannelPermissionsBody, "deny", newValue)

    /** 0 for a role or 1 for a member */
    @inline def tpe: Channel.PermissionOverwrite.PermissionOverwriteType =
      selectDynamic[Channel.PermissionOverwrite.PermissionOverwriteType]("type")

    @inline def withTpe(
        newValue: Channel.PermissionOverwrite.PermissionOverwriteType
    ): EditChannelPermissionsBody = objWith(EditChannelPermissionsBody, "type", newValue)

    override def values: Seq[() => Any] = Seq(() => allow, () => deny, () => tpe)
  }
  object EditChannelPermissionsBody extends DiscordObjectCompanion[EditChannelPermissionsBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): EditChannelPermissionsBody =
      new EditChannelPermissionsBody(json, cache)

    /**
      * @param allow
      *   The bitwise value of all allowed permissions (default "0")
      * @param deny
      *   The bitwise value of all disallowed permissions (default "0")
      * @param tpe
      *   0 for a role or 1 for a member
      */
    def make20(
        allow: JsonOption[String] = JsonUndefined(Some("allow")),
        deny: JsonOption[String] = JsonUndefined(Some("deny")),
        tpe: Channel.PermissionOverwrite.PermissionOverwriteType
    ): EditChannelPermissionsBody = makeRawFromFields("allow" :=? allow, "deny" :=? deny, "type" := tpe)
  }

  /**
    * Edit the channel permission overwrites for a user or role in a channel.
    * Only usable for guild channels. Requires the MANAGE_ROLES permission. Only
    * permissions your bot has in the guild or parent channel (if applicable)
    * can be allowed/denied (unless your bot has a MANAGE_ROLES overwrite in the
    * channel). Returns a 204 empty response on success. Fires a Channel Update
    * Gateway event. For more information about permissions, see permissions.
    */
  def editChannelPermissions(
      channelId: ChannelId,
      overwriteId: Snowflake[UserOrRoleId],
      body: EditChannelPermissionsBody,
      reason: Option[String]
  ): Request[EditChannelPermissionsBody, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "permissions" / Parameters[Snowflake[UserOrRoleId]]("overwriteId", overwriteId)).toRequest(Method.PUT),
      params = body,
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  /**
    * Returns a list of invite objects (with invite metadata) for the channel.
    * Only usable for guild channels. Requires the MANAGE_CHANNELS permission.
    */
  def getChannelInvites(channelId: ChannelId): Request[Unit, Seq[Invite]] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "invites")
        .toRequest(Method.GET)
    )

  class CreateChannelInviteBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /**
      * Duration of invite in seconds before expiry, or 0 for never. between 0
      * and 604800 (7 days)
      */
    @inline def maxAge: UndefOr[Int] = selectDynamic[UndefOr[Int]]("max_age")

    @inline def withMaxAge(newValue: UndefOr[Int]): CreateChannelInviteBody =
      objWithUndef(CreateChannelInviteBody, "max_age", newValue)

    /** Max number of uses or 0 for unlimited. between 0 and 100 */
    @inline def maxUses: UndefOr[Int] = selectDynamic[UndefOr[Int]]("max_uses")

    @inline def withMaxUses(newValue: UndefOr[Int]): CreateChannelInviteBody =
      objWithUndef(CreateChannelInviteBody, "max_uses", newValue)

    /** Whether this invite only grants temporary membership */
    @inline def temporary: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("temporary")

    @inline def withTemporary(newValue: UndefOr[Boolean]): CreateChannelInviteBody =
      objWithUndef(CreateChannelInviteBody, "temporary", newValue)

    /**
      * If true, don't try to reuse a similar invite (useful for creating many
      * unique one time use invites)
      */
    @inline def unique: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("unique")

    @inline def withUnique(newValue: UndefOr[Boolean]): CreateChannelInviteBody =
      objWithUndef(CreateChannelInviteBody, "unique", newValue)

    /** The type of target for this voice channel invite */
    @inline def targetType: UndefOr[Invite.InviteTargetType] =
      selectDynamic[UndefOr[Invite.InviteTargetType]]("target_type")

    @inline def withTargetType(newValue: UndefOr[Invite.InviteTargetType]): CreateChannelInviteBody =
      objWithUndef(CreateChannelInviteBody, "target_type", newValue)

    /**
      * The id of the user whose stream to display for this invite, required if
      * target_type is 1, the user must be streaming in the channel
      */
    @inline def targetUserId: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("target_user_id")

    @inline def withTargetUserId(newValue: UndefOr[UserId]): CreateChannelInviteBody =
      objWithUndef(CreateChannelInviteBody, "target_user_id", newValue)

    /**
      * The id of the embedded application to open for this invite, required if
      * target_type is 2, the application must have the EMBEDDED flag
      */
    @inline def targetApplicationId: UndefOr[ApplicationId] =
      selectDynamic[UndefOr[ApplicationId]]("target_application_id")

    @inline def withTargetApplicationId(newValue: UndefOr[ApplicationId]): CreateChannelInviteBody =
      objWithUndef(CreateChannelInviteBody, "target_application_id", newValue)

    override def values: Seq[() => Any] = Seq(
      () => maxAge,
      () => maxUses,
      () => temporary,
      () => unique,
      () => targetType,
      () => targetUserId,
      () => targetApplicationId
    )
  }
  object CreateChannelInviteBody extends DiscordObjectCompanion[CreateChannelInviteBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): CreateChannelInviteBody =
      new CreateChannelInviteBody(json, cache)

    /**
      * @param maxAge
      *   Duration of invite in seconds before expiry, or 0 for never. between 0
      *   and 604800 (7 days)
      * @param maxUses
      *   Max number of uses or 0 for unlimited. between 0 and 100
      * @param temporary
      *   Whether this invite only grants temporary membership
      * @param unique
      *   If true, don't try to reuse a similar invite (useful for creating many
      *   unique one time use invites)
      * @param targetType
      *   The type of target for this voice channel invite
      * @param targetUserId
      *   The id of the user whose stream to display for this invite, required
      *   if target_type is 1, the user must be streaming in the channel
      * @param targetApplicationId
      *   The id of the embedded application to open for this invite, required
      *   if target_type is 2, the application must have the EMBEDDED flag
      */
    def make20(
        maxAge: UndefOr[Int] = UndefOrUndefined(Some("max_age")),
        maxUses: UndefOr[Int] = UndefOrUndefined(Some("max_uses")),
        temporary: UndefOr[Boolean] = UndefOrUndefined(Some("temporary")),
        unique: UndefOr[Boolean] = UndefOrUndefined(Some("unique")),
        targetType: UndefOr[Invite.InviteTargetType] = UndefOrUndefined(Some("target_type")),
        targetUserId: UndefOr[UserId] = UndefOrUndefined(Some("target_user_id")),
        targetApplicationId: UndefOr[ApplicationId] = UndefOrUndefined(Some("target_application_id"))
    ): CreateChannelInviteBody = makeRawFromFields(
      "max_age"               :=? maxAge,
      "max_uses"              :=? maxUses,
      "temporary"             :=? temporary,
      "unique"                :=? unique,
      "target_type"           :=? targetType,
      "target_user_id"        :=? targetUserId,
      "target_application_id" :=? targetApplicationId
    )
  }

  /**
    * Create a new invite object for the channel. Only usable for guild
    * channels. Requires the CREATE_INSTANT_INVITE permission. All JSON
    * parameters for this route are optional, however the request body is not.
    * If you are not sending any fields, you still have to send an empty JSON
    * object ({}). Returns an invite object. Fires an Invite Create Gateway
    * event.
    */
  def createChannelInvite(
      channelId: ChannelId,
      body: CreateChannelInviteBody,
      reason: Option[String]
  ): Request[CreateChannelInviteBody, Invite] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "invites")
        .toRequest(Method.POST),
      params = body,
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  /**
    * Delete a channel permission overwrite for a user or role in a channel.
    * Only usable for guild channels. Requires the MANAGE_ROLES permission.
    * Returns a 204 empty response on success. Fires a Channel Update Gateway
    * event. For more information about permissions, see permissions
    */
  def deleteChannelPermission(
      channelId: ChannelId,
      overwriteId: Snowflake[UserOrRoleId],
      reason: Option[String]
  ): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "permissions" / Parameters[Snowflake[UserOrRoleId]]("overwriteId", overwriteId)).toRequest(Method.DELETE),
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  class FollowAnnouncementChannelBody(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** Id of target channel */
    @inline def webhookChannelId: ChannelId = selectDynamic[ChannelId]("webhook_channel_id")

    @inline def withWebhookChannelId(newValue: ChannelId): FollowAnnouncementChannelBody =
      objWith(FollowAnnouncementChannelBody, "webhook_channel_id", newValue)

    override def values: Seq[() => Any] = Seq(() => webhookChannelId)
  }
  object FollowAnnouncementChannelBody extends DiscordObjectCompanion[FollowAnnouncementChannelBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): FollowAnnouncementChannelBody =
      new FollowAnnouncementChannelBody(json, cache)

    /**
      * @param webhookChannelId
      *   Id of target channel
      */
    def make20(webhookChannelId: ChannelId): FollowAnnouncementChannelBody =
      makeRawFromFields("webhook_channel_id" := webhookChannelId)
  }

  /**
    * Follow an Announcement Channel to send messages to a target channel.
    * Requires the MANAGE_WEBHOOKS permission in the target channel. Returns a
    * followed channel object. Fires a Webhooks Update Gateway event for the
    * target channel.
    */
  def followAnnouncementChannel(
      channelId: ChannelId,
      body: FollowAnnouncementChannelBody
  ): Request[FollowAnnouncementChannelBody, FollowedChannel] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "followers")
        .toRequest(Method.POST),
      params = body
    )

  /**
    * Post a typing indicator for the specified channel, which expires after 10
    * seconds. Returns a 204 empty response on success. Fires a Typing Start
    * Gateway event. Generally bots should not use this route. However, if a bot
    * is responding to a command and expects the computation to take a few
    * seconds, this endpoint may be called to let the user know that the bot is
    * processing their message.
    */
  def triggerTypingIndicator(channelId: ChannelId): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "typing")
        .toRequest(Method.POST)
    )

  /**
    * Returns all pinned messages in the channel as an array of message objects.
    */
  def getPinnedMessages(channelId: ChannelId): Request[Unit, Seq[Message]] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "pins")
        .toRequest(Method.GET)
    )

  /**
    * Pin a message in a channel. Requires the MANAGE_MESSAGES permission.
    * Returns a 204 empty response on success. Fires a Channel Pins Update
    * Gateway event.
    */
  def pinMessage(
      channelId: ChannelId,
      messageId: MessageId,
      reason: Option[String]
  ): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "pins" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.PUT),
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  /**
    * Unpin a message in a channel. Requires the MANAGE_MESSAGES permission.
    * Returns a 204 empty response on success. Fires a Channel Pins Update
    * Gateway event.
    */
  def unpinMessage(
      channelId: ChannelId,
      messageId: MessageId,
      reason: Option[String]
  ): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "pins" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.DELETE),
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  class GroupDMAddRecipientBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Access token of a user that has granted your app the gdm.join scope */
    @inline def accessToken: String = selectDynamic[String]("access_token")

    @inline def withAccessToken(newValue: String): GroupDMAddRecipientBody =
      objWith(GroupDMAddRecipientBody, "access_token", newValue)

    /** Nickname of the user being added */
    @inline def nick: String = selectDynamic[String]("nick")

    @inline def withNick(newValue: String): GroupDMAddRecipientBody = objWith(GroupDMAddRecipientBody, "nick", newValue)

    override def values: Seq[() => Any] = Seq(() => accessToken, () => nick)
  }
  object GroupDMAddRecipientBody extends DiscordObjectCompanion[GroupDMAddRecipientBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): GroupDMAddRecipientBody =
      new GroupDMAddRecipientBody(json, cache)

    /**
      * @param accessToken
      *   Access token of a user that has granted your app the gdm.join scope
      * @param nick
      *   Nickname of the user being added
      */
    def make20(accessToken: String, nick: String): GroupDMAddRecipientBody =
      makeRawFromFields("access_token" := accessToken, "nick" := nick)
  }

  /** Adds a recipient to a Group DM using their access token. */
  def groupDMAddRecipient(
      channelId: ChannelId,
      userId: UserId,
      body: GroupDMAddRecipientBody
  ): Request[GroupDMAddRecipientBody, Json] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "recipients" / Parameters[UserId]("userId", userId)).toRequest(Method.PUT),
      params = body
    )

  /** Removes a recipient from a Group DM. */
  def groupDMRemoveRecipient(channelId: ChannelId, userId: UserId): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "recipients" / Parameters[UserId]("userId", userId)).toRequest(Method.DELETE)
    )

  class StartThreadfromMessageBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** 1-100 character channel name */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): StartThreadfromMessageBody =
      objWith(StartThreadfromMessageBody, "name", newValue)

    /**
      * The thread will stop showing in the channel list after
      * auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      * 4320, 10080
      */
    @inline def autoArchiveDuration: UndefOr[Int] = selectDynamic[UndefOr[Int]]("auto_archive_duration")

    @inline def withAutoArchiveDuration(newValue: UndefOr[Int]): StartThreadfromMessageBody =
      objWithUndef(StartThreadfromMessageBody, "auto_archive_duration", newValue)

    /**
      * Amount of seconds a user has to wait before sending another message
      * (0-21600)
      */
    @inline def rateLimitPerUser: JsonOption[Int] = selectDynamic[JsonOption[Int]]("rate_limit_per_user")

    @inline def withRateLimitPerUser(newValue: JsonOption[Int]): StartThreadfromMessageBody =
      objWithUndef(StartThreadfromMessageBody, "rate_limit_per_user", newValue)

    override def values: Seq[() => Any] = Seq(() => name, () => autoArchiveDuration, () => rateLimitPerUser)
  }
  object StartThreadfromMessageBody extends DiscordObjectCompanion[StartThreadfromMessageBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): StartThreadfromMessageBody =
      new StartThreadfromMessageBody(json, cache)

    /**
      * @param name
      *   1-100 character channel name
      * @param autoArchiveDuration
      *   The thread will stop showing in the channel list after
      *   auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      *   4320, 10080
      * @param rateLimitPerUser
      *   Amount of seconds a user has to wait before sending another message
      *   (0-21600)
      */
    def make20(
        name: String,
        autoArchiveDuration: UndefOr[Int] = UndefOrUndefined(Some("auto_archive_duration")),
        rateLimitPerUser: JsonOption[Int] = JsonUndefined(Some("rate_limit_per_user"))
    ): StartThreadfromMessageBody = makeRawFromFields(
      "name"                   := name,
      "auto_archive_duration" :=? autoArchiveDuration,
      "rate_limit_per_user"   :=? rateLimitPerUser
    )
  }

  /**
    * Creates a new thread from an existing message. Returns a channel on
    * success, and a 400 BAD REQUEST on invalid parameters. Fires a Thread
    * Create and a Message Update Gateway event.
    *
    * When called on a GUILD_TEXT channel, creates a PUBLIC_THREAD. When called
    * on a GUILD_ANNOUNCEMENT channel, creates a ANNOUNCEMENT_THREAD. Does not
    * work on a GUILD_FORUM or a GUILD_MEDIA channel. The id of the created
    * thread will be the same as the id of the source message, and as such a
    * message can only have a single thread created from it.
    */
  def startThreadfromMessage(
      channelId: ChannelId,
      messageId: MessageId,
      body: StartThreadfromMessageBody,
      reason: Option[String]
  ): Request[StartThreadfromMessageBody, Channel] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "messages" / Parameters[MessageId]("messageId", messageId) / "threads").toRequest(Method.POST),
      params = body,
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  class StartThreadwithoutMessageBody(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** 1-100 character channel name */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): StartThreadwithoutMessageBody =
      objWith(StartThreadwithoutMessageBody, "name", newValue)

    /**
      * The thread will stop showing in the channel list after
      * auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      * 4320, 10080
      */
    @inline def autoArchiveDuration: UndefOr[Int] = selectDynamic[UndefOr[Int]]("auto_archive_duration")

    @inline def withAutoArchiveDuration(newValue: UndefOr[Int]): StartThreadwithoutMessageBody =
      objWithUndef(StartThreadwithoutMessageBody, "auto_archive_duration", newValue)

    /** The type of thread to create */
    @inline def tpe: UndefOr[Channel.ChannelType] = selectDynamic[UndefOr[Channel.ChannelType]]("type")

    @inline def withTpe(newValue: UndefOr[Channel.ChannelType]): StartThreadwithoutMessageBody =
      objWithUndef(StartThreadwithoutMessageBody, "type", newValue)

    /**
      * Whether non-moderators can add other non-moderators to a thread; only
      * available when creating a private thread
      */
    @inline def invitable: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("invitable")

    @inline def withInvitable(newValue: UndefOr[Boolean]): StartThreadwithoutMessageBody =
      objWithUndef(StartThreadwithoutMessageBody, "invitable", newValue)

    /**
      * Amount of seconds a user has to wait before sending another message
      * (0-21600)
      */
    @inline def rateLimitPerUser: JsonOption[Int] = selectDynamic[JsonOption[Int]]("rate_limit_per_user")

    @inline def withRateLimitPerUser(newValue: JsonOption[Int]): StartThreadwithoutMessageBody =
      objWithUndef(StartThreadwithoutMessageBody, "rate_limit_per_user", newValue)

    override def values: Seq[() => Any] =
      Seq(() => name, () => autoArchiveDuration, () => tpe, () => invitable, () => rateLimitPerUser)
  }
  object StartThreadwithoutMessageBody extends DiscordObjectCompanion[StartThreadwithoutMessageBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): StartThreadwithoutMessageBody =
      new StartThreadwithoutMessageBody(json, cache)

    /**
      * @param name
      *   1-100 character channel name
      * @param autoArchiveDuration
      *   The thread will stop showing in the channel list after
      *   auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      *   4320, 10080
      * @param tpe
      *   The type of thread to create
      * @param invitable
      *   Whether non-moderators can add other non-moderators to a thread; only
      *   available when creating a private thread
      * @param rateLimitPerUser
      *   Amount of seconds a user has to wait before sending another message
      *   (0-21600)
      */
    def make20(
        name: String,
        autoArchiveDuration: UndefOr[Int] = UndefOrUndefined(Some("auto_archive_duration")),
        tpe: UndefOr[Channel.ChannelType] = UndefOrUndefined(Some("tpe")),
        invitable: UndefOr[Boolean] = UndefOrUndefined(Some("invitable")),
        rateLimitPerUser: JsonOption[Int] = JsonUndefined(Some("rate_limit_per_user"))
    ): StartThreadwithoutMessageBody = makeRawFromFields(
      "name"                   := name,
      "auto_archive_duration" :=? autoArchiveDuration,
      "type"                  :=? tpe,
      "invitable"             :=? invitable,
      "rate_limit_per_user"   :=? rateLimitPerUser
    )
  }

  /**
    * Creates a new thread that is not connected to an existing message. Returns
    * a channel on success, and a 400 BAD REQUEST on invalid parameters. Fires a
    * Thread Create Gateway event.
    */
  def startThreadwithoutMessage(
      channelId: ChannelId,
      body: StartThreadwithoutMessageBody,
      reason: Option[String]
  ): Request[StartThreadwithoutMessageBody, Channel] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "threads")
        .toRequest(Method.POST),
      params = body,
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r))
    )

  class StartThreadInForumOrMediaChannelBody(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** 1-100 character channel name */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): StartThreadInForumOrMediaChannelBody =
      objWith(StartThreadInForumOrMediaChannelBody, "name", newValue)

    /**
      * Duration in minutes to automatically archive the thread after recent
      * activity, can be set to: 60, 1440, 4320, 10080
      */
    @inline def autoArchiveDuration: UndefOr[Int] = selectDynamic[UndefOr[Int]]("auto_archive_duration")

    @inline def withAutoArchiveDuration(newValue: UndefOr[Int]): StartThreadInForumOrMediaChannelBody =
      objWithUndef(StartThreadInForumOrMediaChannelBody, "auto_archive_duration", newValue)

    /**
      * Amount of seconds a user has to wait before sending another message
      * (0-21600)
      */
    @inline def rateLimitPerUser: JsonOption[Int] = selectDynamic[JsonOption[Int]]("rate_limit_per_user")

    @inline def withRateLimitPerUser(newValue: JsonOption[Int]): StartThreadInForumOrMediaChannelBody =
      objWithUndef(StartThreadInForumOrMediaChannelBody, "rate_limit_per_user", newValue)

    /** Contents of the first message in the forum thread */
    @inline def message: ForumAndMediaThreadMessageParams = selectDynamic[ForumAndMediaThreadMessageParams]("message")

    @inline def withMessage(newValue: ForumAndMediaThreadMessageParams): StartThreadInForumOrMediaChannelBody =
      objWith(StartThreadInForumOrMediaChannelBody, "message", newValue)

    /**
      * The IDs of the set of tags that have been applied to a thread in a
      * GUILD_FORUM channel
      */
    @inline def appliedTags: Seq[Snowflake[Channel.ForumTag]] =
      selectDynamic[Seq[Snowflake[Channel.ForumTag]]]("applied_tags")

    @inline def withAppliedTags(newValue: Seq[Snowflake[Channel.ForumTag]]): StartThreadInForumOrMediaChannelBody =
      objWith(StartThreadInForumOrMediaChannelBody, "applied_tags", newValue)

    override def values: Seq[() => Any] =
      Seq(() => name, () => autoArchiveDuration, () => rateLimitPerUser, () => message, () => appliedTags)
  }
  object StartThreadInForumOrMediaChannelBody extends DiscordObjectCompanion[StartThreadInForumOrMediaChannelBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): StartThreadInForumOrMediaChannelBody =
      new StartThreadInForumOrMediaChannelBody(json, cache)

    /**
      * @param name
      *   1-100 character channel name
      * @param autoArchiveDuration
      *   Duration in minutes to automatically archive the thread after recent
      *   activity, can be set to: 60, 1440, 4320, 10080
      * @param rateLimitPerUser
      *   Amount of seconds a user has to wait before sending another message
      *   (0-21600)
      * @param message
      *   Contents of the first message in the forum thread
      * @param appliedTags
      *   The IDs of the set of tags that have been applied to a thread in a
      *   GUILD_FORUM channel
      */
    def make20(
        name: String,
        autoArchiveDuration: UndefOr[Int] = UndefOrUndefined(Some("auto_archive_duration")),
        rateLimitPerUser: JsonOption[Int] = JsonUndefined(Some("rate_limit_per_user")),
        message: ForumAndMediaThreadMessageParams,
        appliedTags: Seq[Snowflake[Channel.ForumTag]]
    ): StartThreadInForumOrMediaChannelBody = makeRawFromFields(
      "name"                   := name,
      "auto_archive_duration" :=? autoArchiveDuration,
      "rate_limit_per_user"   :=? rateLimitPerUser,
      "message"                := message,
      "applied_tags"           := appliedTags
    )
  }

  /**
    * Creates a new thread in a forum or a media channel, and sends a message
    * within the created thread. Returns a channel, with a nested message
    * object, on success, and a 400 BAD REQUEST on invalid parameters. Fires a
    * Thread Create and Message Create Gateway event.
    *
    *   - The type of the created thread is PUBLIC_THREAD.
    *   - See message formatting for more information on how to properly format
    *     messages.
    *   - The current user must have the SEND_MESSAGES permission
    *     (CREATE_PUBLIC_THREADS is ignored).
    *   - The maximum request size when sending a message is 25 MiB.
    *   - For the embed object, you can set every field except type (it will be
    *     rich regardless of if you try to set it), provider, video, and any
    *     height, width, or proxy_url values for images.
    *   - Examples for file uploads are available in Uploading Files.
    *   - Files must be attached using a multipart/form-data body as described
    *     in Uploading Files.
    *   - Note that when sending a message, you must provide a value for at
    *     least one of content, embeds, sticker_ids, components, or files[n].
    */
  def startThreadInForumOrMediaChannel[MPR](
      channelId: ChannelId,
      body: StartThreadInForumOrMediaChannelBody,
      reason: Option[String],
      parts: Seq[EncodeBody.Multipart[_, MPR]] = Nil
  ): ComplexRequest[StartThreadInForumOrMediaChannelBody, Channel, MPR, Any] =
    Request.complexRestRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId]("channelId", channelId, major = true) / "threads")
        .toRequest(Method.POST),
      params = body,
      extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r)),
      requestBody = Some(
        EncodeBody.MultipartBody(
          EncodeBody.Multipart.EncodeJson(body, "payload_json"),
          parts.zipWithIndex.map(t => t._1.withName(s"files[${t._2}]"))
        )
      )
    )

  class ForumAndMediaThreadMessageParams(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** Message contents (up to 2000 characters) */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    @inline def withContent(newValue: UndefOr[String]): ForumAndMediaThreadMessageParams =
      objWithUndef(ForumAndMediaThreadMessageParams, "content", newValue)

    /** Embedded rich content (up to 6000 characters) */
    @inline def embeds: UndefOr[Seq[OutgoingEmbed]] = selectDynamic[UndefOr[Seq[OutgoingEmbed]]]("embeds")

    @inline def withEmbeds(newValue: UndefOr[Seq[OutgoingEmbed]]): ForumAndMediaThreadMessageParams =
      objWithUndef(ForumAndMediaThreadMessageParams, "embeds", newValue)

    /** Allowed mentions for the message */
    @inline def allowedMentions: UndefOr[AllowedMentions] = selectDynamic[UndefOr[AllowedMentions]]("allowed_mentions")

    @inline def withAllowedMentions(newValue: UndefOr[AllowedMentions]): ForumAndMediaThreadMessageParams =
      objWithUndef(ForumAndMediaThreadMessageParams, "allowed_mentions", newValue)

    /** Components to include with the message */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    @inline def withComponents(newValue: UndefOr[Seq[Component]]): ForumAndMediaThreadMessageParams =
      objWithUndef(ForumAndMediaThreadMessageParams, "components", newValue)

    /** IDs of up to 3 stickers in the server to send in the message */
    @inline def stickerIds: UndefOr[Seq[Snowflake[Sticker]]] =
      selectDynamic[UndefOr[Seq[Snowflake[Sticker]]]]("sticker_ids")

    @inline def withStickerIds(newValue: UndefOr[Seq[Snowflake[Sticker]]]): ForumAndMediaThreadMessageParams =
      objWithUndef(ForumAndMediaThreadMessageParams, "sticker_ids", newValue)

    /** Attachment objects with filename and description. See Uploading Files */
    @inline def attachments: UndefOr[Seq[MessageCreateEditAttachment]] =
      selectDynamic[UndefOr[Seq[MessageCreateEditAttachment]]]("attachments")

    @inline def withAttachments(newValue: UndefOr[Seq[MessageCreateEditAttachment]]): ForumAndMediaThreadMessageParams =
      objWithUndef(ForumAndMediaThreadMessageParams, "attachments", newValue)

    /**
      * Message flags combined as a bitfield (only SUPPRESS_EMBEDS can be set)
      */
    @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

    @inline def withFlags(newValue: UndefOr[Message.MessageFlags]): ForumAndMediaThreadMessageParams =
      objWithUndef(ForumAndMediaThreadMessageParams, "flags", newValue)

    override def values: Seq[() => Any] = Seq(
      () => content,
      () => embeds,
      () => allowedMentions,
      () => components,
      () => stickerIds,
      () => attachments,
      () => flags
    )
  }
  object ForumAndMediaThreadMessageParams extends DiscordObjectCompanion[ForumAndMediaThreadMessageParams] {
    def makeRaw(json: Json, cache: Map[String, Any]): ForumAndMediaThreadMessageParams =
      new ForumAndMediaThreadMessageParams(json, cache)

    /**
      * @param content
      *   Message contents (up to 2000 characters)
      * @param embeds
      *   Embedded rich content (up to 6000 characters)
      * @param allowedMentions
      *   Allowed mentions for the message
      * @param components
      *   Components to include with the message
      * @param stickerIds
      *   IDs of up to 3 stickers in the server to send in the message
      * @param attachments
      *   Attachment objects with filename and description. See Uploading Files
      * @param flags
      *   Message flags combined as a bitfield (only SUPPRESS_EMBEDS can be set)
      */
    def make20(
        content: UndefOr[String] = UndefOrUndefined(Some("content")),
        embeds: UndefOr[Seq[OutgoingEmbed]] = UndefOrUndefined(Some("embeds")),
        allowedMentions: UndefOr[AllowedMentions] = UndefOrUndefined(Some("allowed_mentions")),
        components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
        stickerIds: UndefOr[Seq[Snowflake[Sticker]]] = UndefOrUndefined(Some("sticker_ids")),
        attachments: UndefOr[Seq[MessageCreateEditAttachment]] = UndefOrUndefined(Some("attachments")),
        flags: UndefOr[Message.MessageFlags] = UndefOrUndefined(Some("flags"))
    ): ForumAndMediaThreadMessageParams = makeRawFromFields(
      "content"          :=? content,
      "embeds"           :=? embeds,
      "allowed_mentions" :=? allowedMentions,
      "components"       :=? components,
      "sticker_ids"      :=? stickerIds,
      "attachments"      :=? attachments,
      "flags"            :=? flags
    )
  }

  /**
    * Adds the current user to a thread. Also requires the thread is not
    * archived. Returns a 204 empty response on success. Fires a Thread Members
    * Update and a Thread Create Gateway event.
    */
  def joinThread(channelId: ChannelId): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "thread-members" / "@me").toRequest(Method.PUT)
    )

  /**
    * Adds another member to a thread. Requires the ability to send messages in
    * the thread. Also requires the thread is not archived. Returns a 204 empty
    * response if the member is successfully added or was already a member of
    * the thread. Fires a Thread Members Update Gateway event.
    */
  def addThreadMember(channelId: ChannelId, userId: UserId): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "thread-members" / Parameters[UserId]("userId", userId)).toRequest(Method.PUT)
    )

  /**
    * Removes the current user from a thread. Also requires the thread is not
    * archived. Returns a 204 empty response on success. Fires a Thread Members
    * Update Gateway event.
    */
  def leaveThread(channelId: ChannelId): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "thread-members" / "@me").toRequest(Method.DELETE)
    )

  /**
    * Removes another member from a thread. Requires the MANAGE_THREADS
    * permission, or the creator of the thread if it is a PRIVATE_THREAD. Also
    * requires the thread is not archived. Returns a 204 empty response on
    * success. Fires a Thread Members Update Gateway event.
    */
  def removeThreadMember(channelId: ChannelId, userId: UserId): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "thread-members" / Parameters[UserId]("userId", userId)).toRequest(Method.DELETE)
    )

  class GetThreadMemberQuery(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Whether to include a guild member object for the thread member */
    @inline def withMember: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("with_member")

    @inline def withWithMember(newValue: UndefOr[Boolean]): GetThreadMemberQuery =
      objWithUndef(GetThreadMemberQuery, "with_member", newValue)

    override def values: Seq[() => Any] = Seq(() => withMember)
  }
  object GetThreadMemberQuery extends DiscordObjectCompanion[GetThreadMemberQuery] {
    def makeRaw(json: Json, cache: Map[String, Any]): GetThreadMemberQuery =
      new GetThreadMemberQuery(json, cache)

    /**
      * @param withMember
      *   Whether to include a guild member object for the thread member
      */
    def make20(
        withMember: UndefOr[Boolean] = UndefOrUndefined(Some("with_member"))
    ): GetThreadMemberQuery = makeRawFromFields("with_member" :=? withMember)
  }

  /**
    * Returns a thread member object for the specified user if they are a member
    * of the thread, returns a 404 response otherwise.
    *
    * When with_member is set to true, the thread member object will include a
    * member field containing a guild member object.
    */
  def getThreadMember(
      channelId: ChannelId,
      userId: UserId,
      query: GetThreadMemberQuery = GetThreadMemberQuery.make20()
  ): Request[Unit, Channel.ThreadMember] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "thread-members" / Parameters[UserId]("userId", userId) +? Parameters.query("with_member", query.withMember))
        .toRequest(Method.GET)
    )

  class ListThreadMembersQuery(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Whether to include a guild member object for each thread member */
    @inline def withMember: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("with_member")

    @inline def withWithMember(newValue: UndefOr[Boolean]): ListThreadMembersQuery =
      objWithUndef(ListThreadMembersQuery, "with_member", newValue)

    /** Get thread members after this user ID */
    @inline def after: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("after")

    @inline def withAfter(newValue: UndefOr[UserId]): ListThreadMembersQuery =
      objWithUndef(ListThreadMembersQuery, "after", newValue)

    /** Max number of thread members to return (1-100). Defaults to 100. */
    @inline def limit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("limit")

    @inline def withLimit(newValue: UndefOr[Int]): ListThreadMembersQuery =
      objWithUndef(ListThreadMembersQuery, "limit", newValue)

    override def values: Seq[() => Any] = Seq(() => withMember, () => after, () => limit)
  }
  object ListThreadMembersQuery extends DiscordObjectCompanion[ListThreadMembersQuery] {
    def makeRaw(json: Json, cache: Map[String, Any]): ListThreadMembersQuery =
      new ListThreadMembersQuery(json, cache)

    /**
      * @param withMember
      *   Whether to include a guild member object for each thread member
      * @param after
      *   Get thread members after this user ID
      * @param limit
      *   Max number of thread members to return (1-100). Defaults to 100.
      */
    def make20(
        withMember: UndefOr[Boolean] = UndefOrUndefined(Some("with_member")),
        after: UndefOr[UserId] = UndefOrUndefined(Some("after")),
        limit: UndefOr[Int] = UndefOrUndefined(Some("limit"))
    ): ListThreadMembersQuery = makeRawFromFields("with_member" :=? withMember, "after" :=? after, "limit" :=? limit)
  }

  /**
    * When with_member is set to true, the results will be paginated and each
    * thread member object will include a member field containing a guild member
    * object.
    */
  def listThreadMembers(
      channelId: ChannelId,
      query: ListThreadMembersQuery = ListThreadMembersQuery.make20()
  ): Request[Unit, Seq[Channel.ThreadMember]] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "thread-members" +? Parameters.query("with_member", query.withMember) +? Parameters
        .query("after", query.after) +? Parameters.query("limit", query.limit)).toRequest(Method.GET)
    )

  class ListPublicArchivedThreadsQuery(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** Returns threads archived before this timestamp */
    @inline def before: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("before")

    @inline def withBefore(newValue: UndefOr[OffsetDateTime]): ListPublicArchivedThreadsQuery =
      objWithUndef(ListPublicArchivedThreadsQuery, "before", newValue)

    /** Optional maximum number of threads to return */
    @inline def limit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("limit")

    @inline def withLimit(newValue: UndefOr[Int]): ListPublicArchivedThreadsQuery =
      objWithUndef(ListPublicArchivedThreadsQuery, "limit", newValue)

    override def values: Seq[() => Any] = Seq(() => before, () => limit)
  }
  object ListPublicArchivedThreadsQuery extends DiscordObjectCompanion[ListPublicArchivedThreadsQuery] {
    def makeRaw(json: Json, cache: Map[String, Any]): ListPublicArchivedThreadsQuery =
      new ListPublicArchivedThreadsQuery(json, cache)

    /**
      * @param before
      *   Returns threads archived before this timestamp
      * @param limit
      *   Optional maximum number of threads to return
      */
    def make20(
        before: UndefOr[OffsetDateTime] = UndefOrUndefined(Some("before")),
        limit: UndefOr[Int] = UndefOrUndefined(Some("limit"))
    ): ListPublicArchivedThreadsQuery = makeRawFromFields("before" :=? before, "limit" :=? limit)
  }

  class ListPublicArchivedThreadsResult(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** The public, archived threads */
    @inline def threads: Seq[Channel] = selectDynamic[Seq[Channel]]("threads")

    @inline def withThreads(newValue: Seq[Channel]): ListPublicArchivedThreadsResult =
      objWith(ListPublicArchivedThreadsResult, "threads", newValue)

    /**
      * A thread member object for each returned thread the current user has
      * joined
      */
    @inline def members: Seq[Channel.ThreadMember] = selectDynamic[Seq[Channel.ThreadMember]]("members")

    @inline def withMembers(newValue: Seq[Channel.ThreadMember]): ListPublicArchivedThreadsResult =
      objWith(ListPublicArchivedThreadsResult, "members", newValue)

    /**
      * Whether there are potentially additional threads that could be returned
      * on a subsequent call
      */
    @inline def hasMore: Boolean = selectDynamic[Boolean]("has_more")

    @inline def withHasMore(newValue: Boolean): ListPublicArchivedThreadsResult =
      objWith(ListPublicArchivedThreadsResult, "has_more", newValue)

    override def values: Seq[() => Any] = Seq(() => threads, () => members, () => hasMore)
  }
  object ListPublicArchivedThreadsResult extends DiscordObjectCompanion[ListPublicArchivedThreadsResult] {
    def makeRaw(json: Json, cache: Map[String, Any]): ListPublicArchivedThreadsResult =
      new ListPublicArchivedThreadsResult(json, cache)

    /**
      * @param threads
      *   The public, archived threads
      * @param members
      *   A thread member object for each returned thread the current user has
      *   joined
      * @param hasMore
      *   Whether there are potentially additional threads that could be
      *   returned on a subsequent call
      */
    def make20(
        threads: Seq[Channel],
        members: Seq[Channel.ThreadMember],
        hasMore: Boolean
    ): ListPublicArchivedThreadsResult =
      makeRawFromFields("threads" := threads, "members" := members, "has_more" := hasMore)
  }

  /**
    * Returns archived threads in the channel that are public. When called on a
    * GUILD_TEXT channel, returns threads of type PUBLIC_THREAD. When called on
    * a GUILD_ANNOUNCEMENT channel returns threads of type ANNOUNCEMENT_THREAD.
    * Threads are ordered by archive_timestamp, in descending order. Requires
    * the READ_MESSAGE_HISTORY permission.
    */
  def listPublicArchivedThreads(
      channelId: ChannelId,
      query: ListPublicArchivedThreadsQuery = ListPublicArchivedThreadsQuery.make20()
  ): Request[Unit, ListPublicArchivedThreadsResult] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "threads" / "archived" / "public" +? Parameters.query("before", query.before) +? Parameters
        .query("limit", query.limit)).toRequest(Method.GET)
    )

  class ListPrivateArchivedThreadsQuery(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** Returns threads archived before this timestamp */
    @inline def before: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("before")

    @inline def withBefore(newValue: UndefOr[OffsetDateTime]): ListPrivateArchivedThreadsQuery =
      objWithUndef(ListPrivateArchivedThreadsQuery, "before", newValue)

    /** Optional maximum number of threads to return */
    @inline def limit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("limit")

    @inline def withLimit(newValue: UndefOr[Int]): ListPrivateArchivedThreadsQuery =
      objWithUndef(ListPrivateArchivedThreadsQuery, "limit", newValue)

    override def values: Seq[() => Any] = Seq(() => before, () => limit)
  }
  object ListPrivateArchivedThreadsQuery extends DiscordObjectCompanion[ListPrivateArchivedThreadsQuery] {
    def makeRaw(json: Json, cache: Map[String, Any]): ListPrivateArchivedThreadsQuery =
      new ListPrivateArchivedThreadsQuery(json, cache)

    /**
      * @param before
      *   Returns threads archived before this timestamp
      * @param limit
      *   Optional maximum number of threads to return
      */
    def make20(
        before: UndefOr[OffsetDateTime] = UndefOrUndefined(Some("before")),
        limit: UndefOr[Int] = UndefOrUndefined(Some("limit"))
    ): ListPrivateArchivedThreadsQuery = makeRawFromFields("before" :=? before, "limit" :=? limit)
  }

  class ListPrivateArchivedThreadsResult(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** The private, archived threads */
    @inline def threads: Seq[Channel] = selectDynamic[Seq[Channel]]("threads")

    @inline def withThreads(newValue: Seq[Channel]): ListPrivateArchivedThreadsResult =
      objWith(ListPrivateArchivedThreadsResult, "threads", newValue)

    /**
      * A thread member object for each returned thread the current user has
      * joined
      */
    @inline def members: Seq[Channel.ThreadMember] = selectDynamic[Seq[Channel.ThreadMember]]("members")

    @inline def withMembers(newValue: Seq[Channel.ThreadMember]): ListPrivateArchivedThreadsResult =
      objWith(ListPrivateArchivedThreadsResult, "members", newValue)

    /**
      * Whether there are potentially additional threads that could be returned
      * on a subsequent call
      */
    @inline def hasMore: Boolean = selectDynamic[Boolean]("has_more")

    @inline def withHasMore(newValue: Boolean): ListPrivateArchivedThreadsResult =
      objWith(ListPrivateArchivedThreadsResult, "has_more", newValue)

    override def values: Seq[() => Any] = Seq(() => threads, () => members, () => hasMore)
  }
  object ListPrivateArchivedThreadsResult extends DiscordObjectCompanion[ListPrivateArchivedThreadsResult] {
    def makeRaw(json: Json, cache: Map[String, Any]): ListPrivateArchivedThreadsResult =
      new ListPrivateArchivedThreadsResult(json, cache)

    /**
      * @param threads
      *   The private, archived threads
      * @param members
      *   A thread member object for each returned thread the current user has
      *   joined
      * @param hasMore
      *   Whether there are potentially additional threads that could be
      *   returned on a subsequent call
      */
    def make20(
        threads: Seq[Channel],
        members: Seq[Channel.ThreadMember],
        hasMore: Boolean
    ): ListPrivateArchivedThreadsResult =
      makeRawFromFields("threads" := threads, "members" := members, "has_more" := hasMore)
  }

  /**
    * Returns archived threads in the channel that are of type PRIVATE_THREAD.
    * Threads are ordered by archive_timestamp, in descending order. Requires
    * both the READ_MESSAGE_HISTORY and MANAGE_THREADS permissions.
    */
  def listPrivateArchivedThreads(
      channelId: ChannelId,
      query: ListPrivateArchivedThreadsQuery = ListPrivateArchivedThreadsQuery.make20()
  ): Request[Unit, ListPrivateArchivedThreadsResult] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "threads" / "archived" / "private" +? Parameters.query("before", query.before) +? Parameters
        .query("limit", query.limit)).toRequest(Method.GET)
    )

  class ListJoinedPrivateArchivedThreadsQuery(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** Returns threads before this id */
    @inline def before: UndefOr[RawSnowflake] = selectDynamic[UndefOr[RawSnowflake]]("before")

    @inline def withBefore(newValue: UndefOr[RawSnowflake]): ListJoinedPrivateArchivedThreadsQuery =
      objWithUndef(ListJoinedPrivateArchivedThreadsQuery, "before", newValue)

    /** Optional maximum number of threads to return */
    @inline def limit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("limit")

    @inline def withLimit(newValue: UndefOr[Int]): ListJoinedPrivateArchivedThreadsQuery =
      objWithUndef(ListJoinedPrivateArchivedThreadsQuery, "limit", newValue)

    override def values: Seq[() => Any] = Seq(() => before, () => limit)
  }
  object ListJoinedPrivateArchivedThreadsQuery extends DiscordObjectCompanion[ListJoinedPrivateArchivedThreadsQuery] {
    def makeRaw(json: Json, cache: Map[String, Any]): ListJoinedPrivateArchivedThreadsQuery =
      new ListJoinedPrivateArchivedThreadsQuery(json, cache)

    /**
      * @param before
      *   Returns threads before this id
      * @param limit
      *   Optional maximum number of threads to return
      */
    def make20(
        before: UndefOr[RawSnowflake] = UndefOrUndefined(Some("before")),
        limit: UndefOr[Int] = UndefOrUndefined(Some("limit"))
    ): ListJoinedPrivateArchivedThreadsQuery = makeRawFromFields("before" :=? before, "limit" :=? limit)
  }

  class ListJoinedPrivateArchivedThreadsResult(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** The private, archived threads the current user has joined */
    @inline def threads: Seq[Channel] = selectDynamic[Seq[Channel]]("threads")

    @inline def withThreads(newValue: Seq[Channel]): ListJoinedPrivateArchivedThreadsResult =
      objWith(ListJoinedPrivateArchivedThreadsResult, "threads", newValue)

    /**
      * A thread member object for each returned thread the current user has
      * joined
      */
    @inline def members: Seq[Channel.ThreadMember] = selectDynamic[Seq[Channel.ThreadMember]]("members")

    @inline def withMembers(newValue: Seq[Channel.ThreadMember]): ListJoinedPrivateArchivedThreadsResult =
      objWith(ListJoinedPrivateArchivedThreadsResult, "members", newValue)

    /**
      * Whether there are potentially additional threads that could be returned
      * on a subsequent call
      */
    @inline def hasMore: Boolean = selectDynamic[Boolean]("has_more")

    @inline def withHasMore(newValue: Boolean): ListJoinedPrivateArchivedThreadsResult =
      objWith(ListJoinedPrivateArchivedThreadsResult, "has_more", newValue)

    override def values: Seq[() => Any] = Seq(() => threads, () => members, () => hasMore)
  }
  object ListJoinedPrivateArchivedThreadsResult extends DiscordObjectCompanion[ListJoinedPrivateArchivedThreadsResult] {
    def makeRaw(json: Json, cache: Map[String, Any]): ListJoinedPrivateArchivedThreadsResult =
      new ListJoinedPrivateArchivedThreadsResult(json, cache)

    /**
      * @param threads
      *   The private, archived threads the current user has joined
      * @param members
      *   A thread member object for each returned thread the current user has
      *   joined
      * @param hasMore
      *   Whether there are potentially additional threads that could be
      *   returned on a subsequent call
      */
    def make20(
        threads: Seq[Channel],
        members: Seq[Channel.ThreadMember],
        hasMore: Boolean
    ): ListJoinedPrivateArchivedThreadsResult =
      makeRawFromFields("threads" := threads, "members" := members, "has_more" := hasMore)
  }

  /**
    * Returns archived threads in the channel that are of type PRIVATE_THREAD,
    * and the user has joined. Threads are ordered by their id, in descending
    * order. Requires the READ_MESSAGE_HISTORY permission.
    */
  def listJoinedPrivateArchivedThreads(
      channelId: ChannelId,
      query: ListJoinedPrivateArchivedThreadsQuery = ListJoinedPrivateArchivedThreadsQuery.make20()
  ): Request[Unit, ListJoinedPrivateArchivedThreadsResult] =
    Request.restRequest(
      route = (Route.Empty / "channels" / Parameters[ChannelId](
        "channelId",
        channelId,
        major = true
      ) / "users" / "@me" / "threads" / "archived" / "private" +? Parameters.query("before", query.before) +? Parameters
        .query("limit", query.limit)).toRequest(Method.GET)
    )
}
