//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.interactions.data

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/interactions/data/InteractionRequests.yaml

import ackcord.data._
import ackcord.data.base._
import ackcord.requests._
import io.circe.Json
import sttp.model.Method

object InteractionRequests {

  /**
    * Create a response to an Interaction from the gateway. Body is an
    * interaction response. Returns 204 No Content.
    *
    * This endpoint also supports file attachments similar to the webhook
    * endpoints. Refer to Uploading Files for details on uploading files and
    * multipart/form-data requests.
    */
  def createInteractionResponse(
      interactionId: InteractionId,
      interactionToken: String,
      body: InteractionResponse
  ): Request[InteractionResponse, Unit] =
    Request.restRequest(
      route =
        (Route.Empty / "interactions" / Parameters[InteractionId]("interactionId", interactionId) / Parameters[String](
          "interactionToken",
          interactionToken
        ) / "callback").toRequest(Method.POST),
      params = body
    )

  /**
    * Returns the initial Interaction response. Functions the same as Get
    * Webhook Message.
    */
  def getOriginalInteractionResponse(applicationId: ApplicationId, interactionToken: String): Request[Unit, Message] =
    Request.restRequest(
      route =
        (Route.Empty / "webhooks" / Parameters[ApplicationId]("applicationId", applicationId) / Parameters[String](
          "interactionToken",
          interactionToken
        ) / "messages" / "@original").toRequest(Method.GET)
    )

  class EditOriginalInteractionResponseBody(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** Message contents (up to 2000 characters) */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    @inline def withContent(newValue: UndefOr[String]): EditOriginalInteractionResponseBody =
      objWithUndef(EditOriginalInteractionResponseBody, "content", newValue)

    /** Up to 10 rich embeds (up to 6000 characters) */
    @inline def embeds: UndefOr[Seq[OutgoingEmbed]] = selectDynamic[UndefOr[Seq[OutgoingEmbed]]]("embeds")

    @inline def withEmbeds(newValue: UndefOr[Seq[OutgoingEmbed]]): EditOriginalInteractionResponseBody =
      objWithUndef(EditOriginalInteractionResponseBody, "embeds", newValue)

    /** Allowed mentions for the message */
    @inline def allowedMentions: UndefOr[AllowedMentions] = selectDynamic[UndefOr[AllowedMentions]]("allowed_mentions")

    @inline def withAllowedMentions(newValue: UndefOr[AllowedMentions]): EditOriginalInteractionResponseBody =
      objWithUndef(EditOriginalInteractionResponseBody, "allowed_mentions", newValue)

    /** Components to include with the message */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    @inline def withComponents(newValue: UndefOr[Seq[Component]]): EditOriginalInteractionResponseBody =
      objWithUndef(EditOriginalInteractionResponseBody, "components", newValue)

    /** Attachment objects with filename and description */
    @inline def attachments: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]] =
      selectDynamic[UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]]]("attachments")

    @inline def withAttachments(
        newValue: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]]
    ): EditOriginalInteractionResponseBody = objWithUndef(EditOriginalInteractionResponseBody, "attachments", newValue)

    override def values: Seq[() => Any] =
      Seq(() => content, () => embeds, () => allowedMentions, () => components, () => attachments)
  }
  object EditOriginalInteractionResponseBody
      extends DiscordObjectCompanion[EditOriginalInteractionResponseBody]
      with CreateMessageLikeMixin[EditOriginalInteractionResponseBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): EditOriginalInteractionResponseBody =
      new EditOriginalInteractionResponseBody(json, cache)

    /**
      * @param content
      *   Message contents (up to 2000 characters)
      * @param embeds
      *   Up to 10 rich embeds (up to 6000 characters)
      * @param allowedMentions
      *   Allowed mentions for the message
      * @param components
      *   Components to include with the message
      * @param attachments
      *   Attachment objects with filename and description
      */
    def make20(
        content: UndefOr[String] = UndefOrUndefined(Some("content")),
        embeds: UndefOr[Seq[OutgoingEmbed]] = UndefOrUndefined(Some("embeds")),
        allowedMentions: UndefOr[AllowedMentions] = UndefOrUndefined(Some("allowed_mentions")),
        components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
        attachments: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]] = UndefOrUndefined(Some("attachments"))
    ): EditOriginalInteractionResponseBody = makeRawFromFields(
      "content"          :=? content,
      "embeds"           :=? embeds,
      "allowed_mentions" :=? allowedMentions,
      "components"       :=? components,
      "attachments"      :=? attachments
    )
  }

  /**
    * Edits the initial Interaction response. Functions the same as Edit Webhook
    * Message.
    */
  def editOriginalInteractionResponse[MPR](
      applicationId: ApplicationId,
      interactionToken: String,
      body: EditOriginalInteractionResponseBody,
      parts: Seq[EncodeBody.Multipart[_, MPR]] = Nil
  ): ComplexRequest[EditOriginalInteractionResponseBody, Message, MPR, Any] =
    Request.complexRestRequest(
      route =
        (Route.Empty / "webhooks" / Parameters[ApplicationId]("applicationId", applicationId) / Parameters[String](
          "interactionToken",
          interactionToken
        ) / "messages" / "@original").toRequest(Method.PATCH),
      params = body,
      requestBody = Some(
        EncodeBody.MultipartBody(
          EncodeBody.Multipart.EncodeJson(body, "payload_json"),
          parts.zipWithIndex.map(t => t._1.withName(s"files[${t._2}]"))
        )
      )
    )

  /**
    * Deletes the initial Interaction response. Returns 204 No Content on
    * success.
    */
  def deleteOriginalInteractionResponse(applicationId: ApplicationId, interactionToken: String): Request[Unit, Unit] =
    Request.restRequest(
      route =
        (Route.Empty / "webhooks" / Parameters[ApplicationId]("applicationId", applicationId) / Parameters[String](
          "interactionToken",
          interactionToken
        ) / "messages" / "@original").toRequest(Method.DELETE)
    )

  class CreateFollowupMessageBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Message contents (up to 2000 characters) */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    @inline def withContent(newValue: UndefOr[String]): CreateFollowupMessageBody =
      objWithUndef(CreateFollowupMessageBody, "content", newValue)

    /** true if this is a TTS message */
    @inline def tts: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("tts")

    @inline def withTts(newValue: UndefOr[Boolean]): CreateFollowupMessageBody =
      objWithUndef(CreateFollowupMessageBody, "tts", newValue)

    /** Up to 10 rich embeds (up to 6000 characters) */
    @inline def embeds: UndefOr[Seq[OutgoingEmbed]] = selectDynamic[UndefOr[Seq[OutgoingEmbed]]]("embeds")

    @inline def withEmbeds(newValue: UndefOr[Seq[OutgoingEmbed]]): CreateFollowupMessageBody =
      objWithUndef(CreateFollowupMessageBody, "embeds", newValue)

    /** Allowed mentions for the message */
    @inline def allowedMentions: UndefOr[AllowedMentions] = selectDynamic[UndefOr[AllowedMentions]]("allowed_mentions")

    @inline def withAllowedMentions(newValue: UndefOr[AllowedMentions]): CreateFollowupMessageBody =
      objWithUndef(CreateFollowupMessageBody, "allowed_mentions", newValue)

    /** Components to include with the message */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    @inline def withComponents(newValue: UndefOr[Seq[Component]]): CreateFollowupMessageBody =
      objWithUndef(CreateFollowupMessageBody, "components", newValue)

    /** Attachment objects with filename and description */
    @inline def attachments: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]] =
      selectDynamic[UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]]]("attachments")

    @inline def withAttachments(
        newValue: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]]
    ): CreateFollowupMessageBody = objWithUndef(CreateFollowupMessageBody, "attachments", newValue)

    /**
      * Message flags combined as a bitfield (only SUPPRESS_EMBEDS and
      * SUPPRESS_NOTIFICATIONS can be set)
      */
    @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

    @inline def withFlags(newValue: UndefOr[Message.MessageFlags]): CreateFollowupMessageBody =
      objWithUndef(CreateFollowupMessageBody, "flags", newValue)

    /**
      * Name of thread to create (requires the webhook channel to be a forum
      * channel)
      */
    @inline def threadName: UndefOr[String] = selectDynamic[UndefOr[String]]("thread_name")

    @inline def withThreadName(newValue: UndefOr[String]): CreateFollowupMessageBody =
      objWithUndef(CreateFollowupMessageBody, "thread_name", newValue)

    override def values: Seq[() => Any] = Seq(
      () => content,
      () => tts,
      () => embeds,
      () => allowedMentions,
      () => components,
      () => attachments,
      () => flags,
      () => threadName
    )
  }
  object CreateFollowupMessageBody
      extends DiscordObjectCompanion[CreateFollowupMessageBody]
      with CreateMessageLikeMixin[CreateFollowupMessageBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): CreateFollowupMessageBody =
      new CreateFollowupMessageBody(json, cache)

    /**
      * @param content
      *   Message contents (up to 2000 characters)
      * @param tts
      *   true if this is a TTS message
      * @param embeds
      *   Up to 10 rich embeds (up to 6000 characters)
      * @param allowedMentions
      *   Allowed mentions for the message
      * @param components
      *   Components to include with the message
      * @param attachments
      *   Attachment objects with filename and description
      * @param flags
      *   Message flags combined as a bitfield (only SUPPRESS_EMBEDS and
      *   SUPPRESS_NOTIFICATIONS can be set)
      * @param threadName
      *   Name of thread to create (requires the webhook channel to be a forum
      *   channel)
      */
    def make20(
        content: UndefOr[String] = UndefOrUndefined(Some("content")),
        tts: UndefOr[Boolean] = UndefOrUndefined(Some("tts")),
        embeds: UndefOr[Seq[OutgoingEmbed]] = UndefOrUndefined(Some("embeds")),
        allowedMentions: UndefOr[AllowedMentions] = UndefOrUndefined(Some("allowed_mentions")),
        components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
        attachments: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]] = UndefOrUndefined(Some("attachments")),
        flags: UndefOr[Message.MessageFlags] = UndefOrUndefined(Some("flags")),
        threadName: UndefOr[String] = UndefOrUndefined(Some("thread_name"))
    ): CreateFollowupMessageBody = makeRawFromFields(
      "content"          :=? content,
      "tts"              :=? tts,
      "embeds"           :=? embeds,
      "allowed_mentions" :=? allowedMentions,
      "components"       :=? components,
      "attachments"      :=? attachments,
      "flags"            :=? flags,
      "thread_name"      :=? threadName
    )
  }

  /**
    * Create a followup message for an Interaction. Functions the same as
    * Execute Webhook, but wait is always true. The thread_id, avatar_url, and
    * username parameters are not supported when using this endpoint for
    * interaction followups.
    *
    * flags can be set to 64 to mark the message as ephemeral, except when it is
    * the first followup message to a deferred Interactions Response. In that
    * case, the flags field will be ignored, and the ephemerality of the message
    * will be determined by the flags value in your original ACK.
    */
  def createFollowupMessage[MPR](
      applicationId: ApplicationId,
      interactionToken: String,
      body: CreateFollowupMessageBody,
      parts: Seq[EncodeBody.Multipart[_, MPR]] = Nil
  ): ComplexRequest[CreateFollowupMessageBody, Message, MPR, Any] =
    Request.complexRestRequest(
      route =
        (Route.Empty / "webhooks" / Parameters[ApplicationId]("applicationId", applicationId) / Parameters[String](
          "interactionToken",
          interactionToken
        )).toRequest(Method.POST),
      params = body,
      requestBody = Some(
        EncodeBody.MultipartBody(
          EncodeBody.Multipart.EncodeJson(body, "payload_json"),
          parts.zipWithIndex.map(t => t._1.withName(s"files[${t._2}]"))
        )
      )
    )

  /**
    * Returns a followup message for an Interaction. Functions the same as Get
    * Webhook Message.
    */
  def getFollowupMessage(
      applicationId: ApplicationId,
      interactionToken: String,
      messageId: MessageId
  ): Request[Unit, Message] =
    Request.restRequest(
      route =
        (Route.Empty / "webhooks" / Parameters[ApplicationId]("applicationId", applicationId) / Parameters[String](
          "interactionToken",
          interactionToken
        ) / "messages" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.GET)
    )

  class EditFollowupMessageBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Message contents (up to 2000 characters) */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    @inline def withContent(newValue: UndefOr[String]): EditFollowupMessageBody =
      objWithUndef(EditFollowupMessageBody, "content", newValue)

    /** Up to 10 rich embeds (up to 6000 characters) */
    @inline def embeds: UndefOr[Seq[OutgoingEmbed]] = selectDynamic[UndefOr[Seq[OutgoingEmbed]]]("embeds")

    @inline def withEmbeds(newValue: UndefOr[Seq[OutgoingEmbed]]): EditFollowupMessageBody =
      objWithUndef(EditFollowupMessageBody, "embeds", newValue)

    /** Allowed mentions for the message */
    @inline def allowedMentions: UndefOr[AllowedMentions] = selectDynamic[UndefOr[AllowedMentions]]("allowed_mentions")

    @inline def withAllowedMentions(newValue: UndefOr[AllowedMentions]): EditFollowupMessageBody =
      objWithUndef(EditFollowupMessageBody, "allowed_mentions", newValue)

    /** Components to include with the message */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    @inline def withComponents(newValue: UndefOr[Seq[Component]]): EditFollowupMessageBody =
      objWithUndef(EditFollowupMessageBody, "components", newValue)

    /** Attachment objects with filename and description */
    @inline def attachments: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]] =
      selectDynamic[UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]]]("attachments")

    @inline def withAttachments(
        newValue: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]]
    ): EditFollowupMessageBody = objWithUndef(EditFollowupMessageBody, "attachments", newValue)

    override def values: Seq[() => Any] =
      Seq(() => content, () => embeds, () => allowedMentions, () => components, () => attachments)
  }
  object EditFollowupMessageBody
      extends DiscordObjectCompanion[EditFollowupMessageBody]
      with CreateMessageLikeMixin[EditFollowupMessageBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): EditFollowupMessageBody =
      new EditFollowupMessageBody(json, cache)

    /**
      * @param content
      *   Message contents (up to 2000 characters)
      * @param embeds
      *   Up to 10 rich embeds (up to 6000 characters)
      * @param allowedMentions
      *   Allowed mentions for the message
      * @param components
      *   Components to include with the message
      * @param attachments
      *   Attachment objects with filename and description
      */
    def make20(
        content: UndefOr[String] = UndefOrUndefined(Some("content")),
        embeds: UndefOr[Seq[OutgoingEmbed]] = UndefOrUndefined(Some("embeds")),
        allowedMentions: UndefOr[AllowedMentions] = UndefOrUndefined(Some("allowed_mentions")),
        components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
        attachments: UndefOr[Seq[ChannelRequests.MessageCreateEditAttachment]] = UndefOrUndefined(Some("attachments"))
    ): EditFollowupMessageBody = makeRawFromFields(
      "content"          :=? content,
      "embeds"           :=? embeds,
      "allowed_mentions" :=? allowedMentions,
      "components"       :=? components,
      "attachments"      :=? attachments
    )
  }

  /**
    * Edits a followup message for an Interaction. Functions the same as Edit
    * Webhook Message.
    */
  def editFollowupMessage[MPR](
      applicationId: ApplicationId,
      interactionToken: String,
      messageId: MessageId,
      body: EditFollowupMessageBody,
      parts: Seq[EncodeBody.Multipart[_, MPR]] = Nil
  ): ComplexRequest[EditFollowupMessageBody, Message, MPR, Any] =
    Request.complexRestRequest(
      route =
        (Route.Empty / "webhooks" / Parameters[ApplicationId]("applicationId", applicationId) / Parameters[String](
          "interactionToken",
          interactionToken
        ) / "messages" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.PATCH),
      params = body,
      requestBody = Some(
        EncodeBody.MultipartBody(
          EncodeBody.Multipart.EncodeJson(body, "payload_json"),
          parts.zipWithIndex.map(t => t._1.withName(s"files[${t._2}]"))
        )
      )
    )

  /**
    * Deletes a followup message for an Interaction. Returns 204 No Content on
    * success.
    */
  def deleteFollowupMessage(
      applicationId: ApplicationId,
      interactionToken: String,
      messageId: MessageId
  ): Request[Unit, Unit] =
    Request.restRequest(
      route =
        (Route.Empty / "webhooks" / Parameters[ApplicationId]("applicationId", applicationId) / Parameters[String](
          "interactionToken",
          interactionToken
        ) / "messages" / Parameters[MessageId]("messageId", messageId)).toRequest(Method.DELETE)
    )
}
