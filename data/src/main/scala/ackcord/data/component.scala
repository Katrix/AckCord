//noinspection ScalaWeakerAccess, ScalaUnusedSymbol
package ackcord.data

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/data/component.yaml

import ackcord.data.base._
import io.circe.Json

sealed trait Component extends DiscordObject {
  def tpe: Component.ComponentType
}

object Component extends DiscordObjectCompanion[Component] {

  def makeRaw(json: Json, cache: Map[String, Any]): Component =
    json.hcursor.get[ComponentType]("type").toOption.fold(UnknownComponent.makeRaw(json, cache): Component) {
      case ComponentType.ActionRow         => ActionRow.makeRaw(json, cache)
      case ComponentType.Button            => Button.makeRaw(json, cache)
      case ComponentType.StringSelect      => SelectMenu.makeRaw(json, cache)
      case ComponentType.TextInput         => TextInput.makeRaw(json, cache)
      case ComponentType.UserSelect        => SelectMenu.makeRaw(json, cache)
      case ComponentType.RoleSelect        => SelectMenu.makeRaw(json, cache)
      case ComponentType.MentionableSelect => SelectMenu.makeRaw(json, cache)
      case ComponentType.ChannelSelect     => SelectMenu.makeRaw(json, cache)
      case _                               => UnknownComponent.makeRaw(json, cache)
    }

  sealed case class ComponentType private (value: Int) extends DiscordEnum[Int]
  object ComponentType                                 extends DiscordEnumCompanion[Int, ComponentType] {

    /** Container for other components */
    val ActionRow: ComponentType = ComponentType(1)

    /** Button object */
    val Button: ComponentType = ComponentType(2)

    /** Select menu for picking from defined text options */
    val StringSelect: ComponentType = ComponentType(3)

    /** Text input object */
    val TextInput: ComponentType = ComponentType(4)

    /** Select menu for users */
    val UserSelect: ComponentType = ComponentType(5)

    /** Select menu for roles */
    val RoleSelect: ComponentType = ComponentType(6)

    /** Select menu for mentionables (users and roles) */
    val MentionableSelect: ComponentType = ComponentType(7)

    /** Select menu for channels */
    val ChannelSelect: ComponentType = ComponentType(8)

    def unknown(value: Int): ComponentType = new ComponentType(value)

    def values: Seq[ComponentType] =
      Seq(ActionRow, Button, StringSelect, TextInput, UserSelect, RoleSelect, MentionableSelect, ChannelSelect)

  }

  /**
    * * An Action Row is a non-interactive container component for other types
    * of components. It has a type: 1 and a sub-array of components of other
    * types.
    *   - You can have up to 5 Action Rows per message
    *   - An Action Row cannot contain another Action Row
    */
  class ActionRow(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {
    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    @inline def components: Seq[Component] = selectDynamic[Seq[Component]]("components")

    override def values: Seq[() => Any] = Seq(() => tpe, () => components)
  }
  object ActionRow extends DiscordObjectCompanion[ActionRow] {
    def makeRaw(json: Json, cache: Map[String, Any]): ActionRow = new ActionRow(json, cache)

    def make20(tpe: ComponentType = ComponentType.ActionRow, components: Seq[Component]): ActionRow =
      makeRawFromFields("type" := tpe, "components" := components)

  }

  /**
    * * Buttons are interactive components that render in messages. They can be
    * clicked by users, and send an interaction to your app when clicked.
    *   - Buttons must be sent inside an Action Row
    *   - An Action Row can contain up to 5 buttons
    *   - An Action Row containing buttons cannot also contain any select menu
    *     components
    */
  class Button(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {
    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    /** A button style */
    @inline def style: Button.ButtonStyle = selectDynamic[Button.ButtonStyle]("style")

    /** Text that appears on the button; max 80 characters */
    @inline def label: UndefOr[String] = selectDynamic[UndefOr[String]]("label")

    /** name, id, and animated */
    @inline def emoji: UndefOr[ComponentEmoji] = selectDynamic[UndefOr[ComponentEmoji]]("emoji")

    /** Developer-defined identifier for the button; max 100 characters */
    @inline def customId: UndefOr[String] = selectDynamic[UndefOr[String]]("custom_id")

    /** URL for link-style buttons */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    /** Whether the button is disabled (defaults to false) */
    @inline def disabled: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("disabled")

    override def values: Seq[() => Any] =
      Seq(() => tpe, () => style, () => label, () => emoji, () => customId, () => url, () => disabled)
  }
  object Button extends DiscordObjectCompanion[Button] {
    def makeRaw(json: Json, cache: Map[String, Any]): Button = new Button(json, cache)

    /**
      * @param style
      *   A button style
      * @param label
      *   Text that appears on the button; max 80 characters
      * @param emoji
      *   name, id, and animated
      * @param customId
      *   Developer-defined identifier for the button; max 100 characters
      * @param url
      *   URL for link-style buttons
      * @param disabled
      *   Whether the button is disabled (defaults to false)
      */
    def make20(
        tpe: ComponentType = ComponentType.Button,
        style: Button.ButtonStyle,
        label: UndefOr[String],
        emoji: UndefOr[ComponentEmoji],
        customId: UndefOr[String],
        url: UndefOr[String],
        disabled: UndefOr[Boolean]
    ): Button = makeRawFromFields(
      "type"       := tpe,
      "style"      := style,
      "label"     :=? label,
      "emoji"     :=? emoji,
      "custom_id" :=? customId,
      "url"       :=? url,
      "disabled"  :=? disabled
    )

    /**
      * * Buttons come in a variety of styles to convey different types of
      * actions. These styles also define what fields are valid for a button.
      * -Non-link buttons must have a custom_id, and cannot have a url
      * -Link buttons must have a url, and cannot have a custom_id
      * -Link buttons do not send an interaction to your app when clicked
      */
    sealed case class ButtonStyle private (value: Int) extends DiscordEnum[Int]
    object ButtonStyle                                 extends DiscordEnumCompanion[Int, ButtonStyle] {

      /** Blurple */
      val Primary: ButtonStyle = ButtonStyle(1)

      /** Grey */
      val Secondary: ButtonStyle = ButtonStyle(2)

      /** Green */
      val Success: ButtonStyle = ButtonStyle(3)

      /** Red */
      val Danger: ButtonStyle = ButtonStyle(4)

      /** Grey, navigates to a URL */
      val Link: ButtonStyle = ButtonStyle(5)

      def unknown(value: Int): ButtonStyle = new ButtonStyle(value)

      def values: Seq[ButtonStyle] = Seq(Primary, Secondary, Success, Danger, Link)

    }
  }

  class ComponentEmoji(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of this emoji */
    @inline def id: Option[EmojiId] = selectDynamic[Option[EmojiId]]("id")

    /** The name of this emoji */
    @inline def name: String = selectDynamic[String]("name")

    /** Whether this emoji is animated */
    @inline def animated: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("animated")

    override def values: Seq[() => Any] = Seq(() => id, () => name, () => animated)
  }
  object ComponentEmoji extends DiscordObjectCompanion[ComponentEmoji] {
    def makeRaw(json: Json, cache: Map[String, Any]): ComponentEmoji = new ComponentEmoji(json, cache)

    /**
      * @param id
      *   The id of this emoji
      * @param name
      *   The name of this emoji
      * @param animated
      *   Whether this emoji is animated
      */
    def make20(id: Option[EmojiId], name: String, animated: UndefOr[Boolean]): ComponentEmoji =
      makeRawFromFields("id" := id, "name" := name, "animated" :=? animated)

  }

  /**
    * * Select menus are interactive components that allow users to select one
    * or more options from a dropdown list in messages. On desktop, clicking on
    * a select menu opens a dropdown-style UI; on mobile, tapping a select menu
    * opens up a half-sheet with the options.
    *
    * Select menus support single-select and multi-select behavior, meaning you
    * can prompt a user to choose just one item from a list, or multiple. When a
    * user finishes making their choice(s) by clicking out of the dropdown or
    * closing the half-sheet, your app will receive an interaction.
    *   - Select menus must be sent inside an Action Row
    *   - An Action Row can contain only one select menu
    *   - An Action Row containing a select menu cannot also contain buttons
    *
    * There are 5 different select menu components that can be included in
    * Action Rows.
    *
    * The string select menu (type 3) is the only select type that allows (and
    * requires) apps to define the options that appear in the dropdown list. The
    * other 4 select menu components (users, roles, mentionables, and channels)
    * are auto-populated with options corresponding to the resource typeâ€”similar
    * to command option types.
    *
    * In addition to the values array in all select menu interaction payloads,
    * auto-populated select menu components (users, roles, mentionables, and
    * channels) also include an additional resolved object that provides
    * additional details about the user's selected resource.
    *
    * The payloads for the select menu components are detailed in the select
    * menu structure.
    */
  class SelectMenu(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {
    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    /** ID for the select menu; max 100 characters */
    @inline def customId: String = selectDynamic[String]("custom_id")

    /**
      * Specified choices in a select menu (only required and available for
      * string selects (type 3); max 25
      */
    @inline def options: UndefOr[Seq[SelectOption]] = selectDynamic[UndefOr[Seq[SelectOption]]]("options")

    /**
      * List of channel types to include in the channel select component (type
      * 8)
      */
    @inline def channelTypes: UndefOr[Seq[Channel.ChannelType]] =
      selectDynamic[UndefOr[Seq[Channel.ChannelType]]]("channel_types")

    /** Placeholder text if nothing is selected; max 150 characters */
    @inline def placeholder: UndefOr[String] = selectDynamic[UndefOr[String]]("placeholder")

    /**
      * Minimum number of items that must be chosen (defaults to 1); min 0, max
      * 25
      */
    @inline def minValues: UndefOr[Int] = selectDynamic[UndefOr[Int]]("min_values")

    /** Maximum number of items that can be chosen (defaults to 1); max 25 */
    @inline def maxValues: UndefOr[Int] = selectDynamic[UndefOr[Int]]("max_values")

    /** Whether select menu is disabled (defaults to false) */
    @inline def disabled: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("disabled")

    override def values: Seq[() => Any] = Seq(
      () => tpe,
      () => customId,
      () => options,
      () => channelTypes,
      () => placeholder,
      () => minValues,
      () => maxValues,
      () => disabled
    )
  }
  object SelectMenu extends DiscordObjectCompanion[SelectMenu] {
    def makeRaw(json: Json, cache: Map[String, Any]): SelectMenu = new SelectMenu(json, cache)

    /**
      * @param customId
      *   ID for the select menu; max 100 characters
      * @param options
      *   Specified choices in a select menu (only required and available for
      *   string selects (type 3); max 25
      * @param channelTypes
      *   List of channel types to include in the channel select component (type
      *   8)
      * @param placeholder
      *   Placeholder text if nothing is selected; max 150 characters
      * @param minValues
      *   Minimum number of items that must be chosen (defaults to 1); min 0,
      *   max 25
      * @param maxValues
      *   Maximum number of items that can be chosen (defaults to 1); max 25
      * @param disabled
      *   Whether select menu is disabled (defaults to false)
      */
    def make20(
        tpe: ComponentType,
        customId: String,
        options: UndefOr[Seq[SelectOption]],
        channelTypes: UndefOr[Seq[Channel.ChannelType]],
        placeholder: UndefOr[String],
        minValues: UndefOr[Int],
        maxValues: UndefOr[Int],
        disabled: UndefOr[Boolean]
    ): SelectMenu = makeRawFromFields(
      "type"           := tpe,
      "custom_id"      := customId,
      "options"       :=? options,
      "channel_types" :=? channelTypes,
      "placeholder"   :=? placeholder,
      "min_values"    :=? minValues,
      "max_values"    :=? maxValues,
      "disabled"      :=? disabled
    )

  }

  class SelectOption(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** User-facing name of the option; max 100 characters */
    @inline def label: String = selectDynamic[String]("label")

    /** Dev-defined value of the option; max 100 characters */
    @inline def value: String = selectDynamic[String]("value")

    /** Additional description of the option; max 100 characters */
    @inline def description: UndefOr[String] = selectDynamic[UndefOr[String]]("description")

    /** id, name, and animated */
    @inline def emoji: UndefOr[ComponentEmoji] = selectDynamic[UndefOr[ComponentEmoji]]("emoji")

    /** Will show this option as selected by default */
    @inline def default: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("default")

    override def values: Seq[() => Any] = Seq(() => label, () => value, () => description, () => emoji, () => default)
  }
  object SelectOption extends DiscordObjectCompanion[SelectOption] {
    def makeRaw(json: Json, cache: Map[String, Any]): SelectOption = new SelectOption(json, cache)

    /**
      * @param label
      *   User-facing name of the option; max 100 characters
      * @param value
      *   Dev-defined value of the option; max 100 characters
      * @param description
      *   Additional description of the option; max 100 characters
      * @param emoji
      *   id, name, and animated
      * @param default
      *   Will show this option as selected by default
      */
    def make20(
        label: String,
        value: String,
        description: UndefOr[String],
        emoji: UndefOr[ComponentEmoji],
        default: UndefOr[Boolean]
    ): SelectOption = makeRawFromFields(
      "label"        := label,
      "value"        := value,
      "description" :=? description,
      "emoji"       :=? emoji,
      "default"     :=? default
    )

  }

  /**
    * Text inputs are an interactive component that render on modals. They can
    * be used to collect short-form or long-form text.
    */
  class TextInput(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {
    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    /** Developer-defined identifier for the input; max 100 characters */
    @inline def customId: String = selectDynamic[String]("custom_id")

    /** The Text Input Style */
    @inline def style: TextInput.TextInputStyle = selectDynamic[TextInput.TextInputStyle]("style")

    /** Label for this component; max 45 characters */
    @inline def label: String = selectDynamic[String]("label")

    /** Minimum input length for a text input; min 0, max 4000 */
    @inline def minLength: UndefOr[Int] = selectDynamic[UndefOr[Int]]("min_length")

    /** Maximum input length for a text input; min 1, max 4000 */
    @inline def maxLength: UndefOr[Int] = selectDynamic[UndefOr[Int]]("max_length")

    /** Whether this component is required to be filled (defaults to true) */
    @inline def required: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("required")

    /** Pre-filled value for this component; max 4000 characters */
    @inline def value: UndefOr[String] = selectDynamic[UndefOr[String]]("value")

    /** Custom placeholder text if the input is empty; max 100 characters */
    @inline def placeholder: UndefOr[String] = selectDynamic[UndefOr[String]]("placeholder")

    override def values: Seq[() => Any] = Seq(
      () => tpe,
      () => customId,
      () => style,
      () => label,
      () => minLength,
      () => maxLength,
      () => required,
      () => value,
      () => placeholder
    )
  }
  object TextInput extends DiscordObjectCompanion[TextInput] {
    def makeRaw(json: Json, cache: Map[String, Any]): TextInput = new TextInput(json, cache)

    /**
      * @param customId
      *   Developer-defined identifier for the input; max 100 characters
      * @param style
      *   The Text Input Style
      * @param label
      *   Label for this component; max 45 characters
      * @param minLength
      *   Minimum input length for a text input; min 0, max 4000
      * @param maxLength
      *   Maximum input length for a text input; min 1, max 4000
      * @param required
      *   Whether this component is required to be filled (defaults to true)
      * @param value
      *   Pre-filled value for this component; max 4000 characters
      * @param placeholder
      *   Custom placeholder text if the input is empty; max 100 characters
      */
    def make20(
        tpe: ComponentType = ComponentType.TextInput,
        customId: String,
        style: TextInput.TextInputStyle,
        label: String,
        minLength: UndefOr[Int],
        maxLength: UndefOr[Int],
        required: UndefOr[Boolean],
        value: UndefOr[String],
        placeholder: UndefOr[String]
    ): TextInput = makeRawFromFields(
      "type"         := tpe,
      "custom_id"    := customId,
      "style"        := style,
      "label"        := label,
      "min_length"  :=? minLength,
      "max_length"  :=? maxLength,
      "required"    :=? required,
      "value"       :=? value,
      "placeholder" :=? placeholder
    )

    sealed case class TextInputStyle private (value: Int) extends DiscordEnum[Int]
    object TextInputStyle                                 extends DiscordEnumCompanion[Int, TextInputStyle] {

      /** Single-line input */
      val Short: TextInputStyle = TextInputStyle(1)

      /** Multi-line input */
      val Paragraph: TextInputStyle = TextInputStyle(2)

      def unknown(value: Int): TextInputStyle = new TextInputStyle(value)

      def values: Seq[TextInputStyle] = Seq(Short, Paragraph)

    }
  }

  class UnknownComponent(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with Component {
    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    override def values: Seq[() => Any] = Seq(() => tpe)
  }
  object UnknownComponent extends DiscordObjectCompanion[UnknownComponent] {
    def makeRaw(json: Json, cache: Map[String, Any]): UnknownComponent = new UnknownComponent(json, cache)

    def make20(tpe: ComponentType): UnknownComponent = makeRawFromFields("type" := tpe)

  }
}
