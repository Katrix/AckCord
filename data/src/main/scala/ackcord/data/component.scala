//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.data

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/data/Component.yaml

import ackcord.data.base._
import io.circe.Json

sealed trait Component extends DiscordObject {
  def tpe: Component.ComponentType
}

object Component extends DiscordObjectCompanion[Component] {

  def makeRaw(json: Json, cache: Map[String, Any]): Component =
    json.hcursor.get[ComponentType]("type").toOption.fold(UnknownComponent.makeRaw(json, cache): Component) {
      case ComponentType.ActionRow         => ActionRow.makeRaw(json, cache)
      case ComponentType.Button            => Button.makeRaw(json, cache)
      case ComponentType.StringSelect      => SelectMenu.makeRaw(json, cache)
      case ComponentType.TextInput         => TextInput.makeRaw(json, cache)
      case ComponentType.UserSelect        => SelectMenu.makeRaw(json, cache)
      case ComponentType.RoleSelect        => SelectMenu.makeRaw(json, cache)
      case ComponentType.MentionableSelect => SelectMenu.makeRaw(json, cache)
      case ComponentType.ChannelSelect     => SelectMenu.makeRaw(json, cache)
      case _                               => UnknownComponent.makeRaw(json, cache)
    }

  sealed case class ComponentType private (value: Int) extends DiscordEnum[Int]
  object ComponentType                                 extends DiscordEnumCompanion[Int, ComponentType] {

    /** Container for other components */
    val ActionRow: ComponentType = ComponentType(1)

    /** Button object */
    val Button: ComponentType = ComponentType(2)

    /** Select menu for picking from defined text options */
    val StringSelect: ComponentType = ComponentType(3)

    /** Text input object */
    val TextInput: ComponentType = ComponentType(4)

    /** Select menu for users */
    val UserSelect: ComponentType = ComponentType(5)

    /** Select menu for roles */
    val RoleSelect: ComponentType = ComponentType(6)

    /** Select menu for mentionables (users and roles) */
    val MentionableSelect: ComponentType = ComponentType(7)

    /** Select menu for channels */
    val ChannelSelect: ComponentType = ComponentType(8)

    def unknown(value: Int): ComponentType = new ComponentType(value)

    val values: Seq[ComponentType] =
      Seq(ActionRow, Button, StringSelect, TextInput, UserSelect, RoleSelect, MentionableSelect, ChannelSelect)
  }

  /**
    * An Action Row is a non-interactive container component for other types of
    * components. It has a type: 1 and a sub-array of components of other types.
    *   - You can have up to 5 Action Rows per message
    *   - An Action Row cannot contain another Action Row
    */
  class ActionRow(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {

    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    @inline def withTpe(newValue: ComponentType): ActionRow = objWith(ActionRow, "type", newValue)

    @inline def components: Seq[Component] = selectDynamic[Seq[Component]]("components")

    @inline def withComponents(newValue: Seq[Component]): ActionRow = objWith(ActionRow, "components", newValue)

    override def values: Seq[() => Any] = Seq(() => tpe, () => components)
  }
  object ActionRow extends DiscordObjectCompanion[ActionRow] {
    def makeRaw(json: Json, cache: Map[String, Any]): ActionRow = new ActionRow(json, cache)

    def make20(
        tpe: ComponentType = ComponentType.ActionRow,
        components: Seq[Component]
    ): ActionRow = makeRawFromFields("type" := tpe, "components" := components)
  }

  /**
    * Buttons are interactive components that render in messages. They can be
    * clicked by users, and send an interaction to your app when clicked.
    *   - Buttons must be sent inside an Action Row
    *   - An Action Row can contain up to 5 buttons
    *   - An Action Row containing buttons cannot also contain any select menu
    *     components
    */
  class Button(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {

    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    @inline def withTpe(newValue: ComponentType): Button = objWith(Button, "type", newValue)

    /** A button style */
    @inline def style: Button.ButtonStyle = selectDynamic[Button.ButtonStyle]("style")

    @inline def withStyle(newValue: Button.ButtonStyle): Button = objWith(Button, "style", newValue)

    /** Text that appears on the button; max 80 characters */
    @inline def label: UndefOr[String] = selectDynamic[UndefOr[String]]("label")

    @inline def withLabel(newValue: UndefOr[String]): Button = objWithUndef(Button, "label", newValue)

    /** name, id, and animated */
    @inline def emoji: UndefOr[ComponentEmoji] = selectDynamic[UndefOr[ComponentEmoji]]("emoji")

    @inline def withEmoji(newValue: UndefOr[ComponentEmoji]): Button =
      objWithUndef(Button, "emoji", newValue)

    /** Developer-defined identifier for the button; max 100 characters */
    @inline def customId: UndefOr[String] = selectDynamic[UndefOr[String]]("custom_id")

    @inline def withCustomId(newValue: UndefOr[String]): Button = objWithUndef(Button, "custom_id", newValue)

    /** URL for link-style buttons */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    @inline def withUrl(newValue: UndefOr[String]): Button = objWithUndef(Button, "url", newValue)

    /** Whether the button is disabled (defaults to false) */
    @inline def disabled: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("disabled")

    @inline def withDisabled(newValue: UndefOr[Boolean]): Button = objWithUndef(Button, "disabled", newValue)

    override def values: Seq[() => Any] =
      Seq(() => tpe, () => style, () => label, () => emoji, () => customId, () => url, () => disabled)
  }
  object Button extends DiscordObjectCompanion[Button] {
    def makeRaw(json: Json, cache: Map[String, Any]): Button = new Button(json, cache)

    /**
      * @param style
      *   A button style
      * @param label
      *   Text that appears on the button; max 80 characters
      * @param emoji
      *   name, id, and animated
      * @param customId
      *   Developer-defined identifier for the button; max 100 characters
      * @param url
      *   URL for link-style buttons
      * @param disabled
      *   Whether the button is disabled (defaults to false)
      */
    def make20(
        tpe: ComponentType = ComponentType.Button,
        style: Button.ButtonStyle,
        label: UndefOr[String] = UndefOrUndefined(Some("label")),
        emoji: UndefOr[ComponentEmoji] = UndefOrUndefined(Some("emoji")),
        customId: UndefOr[String] = UndefOrUndefined(Some("custom_id")),
        url: UndefOr[String] = UndefOrUndefined(Some("url")),
        disabled: UndefOr[Boolean] = UndefOrUndefined(Some("disabled"))
    ): Button = makeRawFromFields(
      "type"       := tpe,
      "style"      := style,
      "label"     :=? label,
      "emoji"     :=? emoji,
      "custom_id" :=? customId,
      "url"       :=? url,
      "disabled"  :=? disabled
    )

    /**
      * Buttons come in a variety of styles to convey different types of
      * actions. These styles also define what fields are valid for a button.
      * -Non-link buttons must have a custom_id, and cannot have a url
      * -Link buttons must have a url, and cannot have a custom_id
      * -Link buttons do not send an interaction to your app when clicked
      */
    sealed case class ButtonStyle private (value: Int) extends DiscordEnum[Int]
    object ButtonStyle                                 extends DiscordEnumCompanion[Int, ButtonStyle] {

      /** Blurple */
      val Primary: ButtonStyle = ButtonStyle(1)

      /** Grey */
      val Secondary: ButtonStyle = ButtonStyle(2)

      /** Green */
      val Success: ButtonStyle = ButtonStyle(3)

      /** Red */
      val Danger: ButtonStyle = ButtonStyle(4)

      /** Grey, navigates to a URL */
      val Link: ButtonStyle = ButtonStyle(5)

      def unknown(value: Int): ButtonStyle = new ButtonStyle(value)

      val values: Seq[ButtonStyle] = Seq(Primary, Secondary, Success, Danger, Link)
    }
  }

  class ComponentEmoji(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of this emoji */
    @inline def id: Option[EmojiId] = selectDynamic[Option[EmojiId]]("id")

    @inline def withId(newValue: Option[EmojiId]): ComponentEmoji = objWith(ComponentEmoji, "id", newValue)

    /** The name of this emoji */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): ComponentEmoji = objWith(ComponentEmoji, "name", newValue)

    /** Whether this emoji is animated */
    @inline def animated: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("animated")

    @inline def withAnimated(newValue: UndefOr[Boolean]): ComponentEmoji =
      objWithUndef(ComponentEmoji, "animated", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => name, () => animated)
  }
  object ComponentEmoji extends DiscordObjectCompanion[ComponentEmoji] {
    def makeRaw(json: Json, cache: Map[String, Any]): ComponentEmoji =
      new ComponentEmoji(json, cache)

    /**
      * @param id
      *   The id of this emoji
      * @param name
      *   The name of this emoji
      * @param animated
      *   Whether this emoji is animated
      */
    def make20(
        id: Option[EmojiId],
        name: String,
        animated: UndefOr[Boolean] = UndefOrUndefined(Some("animated"))
    ): ComponentEmoji = makeRawFromFields("id" := id, "name" := name, "animated" :=? animated)
  }

  /**
    * Select menus are interactive components that allow users to select one or
    * more options from a dropdown list in messages. On desktop, clicking on a
    * select menu opens a dropdown-style UI; on mobile, tapping a select menu
    * opens up a half-sheet with the options.
    *
    * Select menus support single-select and multi-select behavior, meaning you
    * can prompt a user to choose just one item from a list, or multiple. When a
    * user finishes making their choice(s) by clicking out of the dropdown or
    * closing the half-sheet, your app will receive an interaction.
    *   - Select menus must be sent inside an Action Row
    *   - An Action Row can contain only one select menu
    *   - An Action Row containing a select menu cannot also contain buttons
    *
    * There are 5 different select menu components that can be included in
    * Action Rows.
    *
    * The string select menu (type 3) is the only select type that allows (and
    * requires) apps to define the options that appear in the dropdown list. The
    * other 4 select menu components (users, roles, mentionables, and channels)
    * are auto-populated with options corresponding to the resource typeâ€”similar
    * to command option types.
    *
    * In addition to the values array in all select menu interaction payloads,
    * auto-populated select menu components (users, roles, mentionables, and
    * channels) also include an additional resolved object that provides
    * additional details about the user's selected resource.
    *
    * The payloads for the select menu components are detailed in the select
    * menu structure.
    */
  class SelectMenu(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {

    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    @inline def withTpe(newValue: ComponentType): SelectMenu = objWith(SelectMenu, "type", newValue)

    /** ID for the select menu; max 100 characters */
    @inline def customId: String = selectDynamic[String]("custom_id")

    @inline def withCustomId(newValue: String): SelectMenu = objWith(SelectMenu, "custom_id", newValue)

    /**
      * Specified choices in a select menu (only required and available for
      * string selects (type 3); max 25
      */
    @inline def options: UndefOr[Seq[SelectOption]] = selectDynamic[UndefOr[Seq[SelectOption]]]("options")

    @inline def withOptions(newValue: UndefOr[Seq[SelectOption]]): SelectMenu =
      objWithUndef(SelectMenu, "options", newValue)

    /**
      * List of channel types to include in the channel select component (type
      * 8)
      */
    @inline def channelTypes: UndefOr[Seq[Channel.ChannelType]] =
      selectDynamic[UndefOr[Seq[Channel.ChannelType]]]("channel_types")

    @inline def withChannelTypes(newValue: UndefOr[Seq[Channel.ChannelType]]): SelectMenu =
      objWithUndef(SelectMenu, "channel_types", newValue)

    /** Placeholder text if nothing is selected; max 150 characters */
    @inline def placeholder: UndefOr[String] = selectDynamic[UndefOr[String]]("placeholder")

    @inline def withPlaceholder(newValue: UndefOr[String]): SelectMenu =
      objWithUndef(SelectMenu, "placeholder", newValue)

    /**
      * Minimum number of items that must be chosen (defaults to 1); min 0, max
      * 25
      */
    @inline def minValues: UndefOr[Int] = selectDynamic[UndefOr[Int]]("min_values")

    @inline def withMinValues(newValue: UndefOr[Int]): SelectMenu = objWithUndef(SelectMenu, "min_values", newValue)

    /** Maximum number of items that can be chosen (defaults to 1); max 25 */
    @inline def maxValues: UndefOr[Int] = selectDynamic[UndefOr[Int]]("max_values")

    @inline def withMaxValues(newValue: UndefOr[Int]): SelectMenu = objWithUndef(SelectMenu, "max_values", newValue)

    /** Whether select menu is disabled (defaults to false) */
    @inline def disabled: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("disabled")

    @inline def withDisabled(newValue: UndefOr[Boolean]): SelectMenu =
      objWithUndef(SelectMenu, "disabled", newValue)

    override def values: Seq[() => Any] = Seq(
      () => tpe,
      () => customId,
      () => options,
      () => channelTypes,
      () => placeholder,
      () => minValues,
      () => maxValues,
      () => disabled
    )
  }
  object SelectMenu extends DiscordObjectCompanion[SelectMenu] {
    def makeRaw(json: Json, cache: Map[String, Any]): SelectMenu = new SelectMenu(json, cache)

    /**
      * @param customId
      *   ID for the select menu; max 100 characters
      * @param options
      *   Specified choices in a select menu (only required and available for
      *   string selects (type 3); max 25
      * @param channelTypes
      *   List of channel types to include in the channel select component (type
      *   8)
      * @param placeholder
      *   Placeholder text if nothing is selected; max 150 characters
      * @param minValues
      *   Minimum number of items that must be chosen (defaults to 1); min 0,
      *   max 25
      * @param maxValues
      *   Maximum number of items that can be chosen (defaults to 1); max 25
      * @param disabled
      *   Whether select menu is disabled (defaults to false)
      */
    def make20(
        tpe: ComponentType,
        customId: String,
        options: UndefOr[Seq[SelectOption]] = UndefOrUndefined(Some("options")),
        channelTypes: UndefOr[Seq[Channel.ChannelType]] = UndefOrUndefined(Some("channel_types")),
        placeholder: UndefOr[String] = UndefOrUndefined(Some("placeholder")),
        minValues: UndefOr[Int] = UndefOrUndefined(Some("min_values")),
        maxValues: UndefOr[Int] = UndefOrUndefined(Some("max_values")),
        disabled: UndefOr[Boolean] = UndefOrUndefined(Some("disabled"))
    ): SelectMenu = makeRawFromFields(
      "type"           := tpe,
      "custom_id"      := customId,
      "options"       :=? options,
      "channel_types" :=? channelTypes,
      "placeholder"   :=? placeholder,
      "min_values"    :=? minValues,
      "max_values"    :=? maxValues,
      "disabled"      :=? disabled
    )
  }

  class SelectOption(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** User-facing name of the option; max 100 characters */
    @inline def label: String = selectDynamic[String]("label")

    @inline def withLabel(newValue: String): SelectOption = objWith(SelectOption, "label", newValue)

    /** Dev-defined value of the option; max 100 characters */
    @inline def value: String = selectDynamic[String]("value")

    @inline def withValue(newValue: String): SelectOption = objWith(SelectOption, "value", newValue)

    /** Additional description of the option; max 100 characters */
    @inline def description: UndefOr[String] = selectDynamic[UndefOr[String]]("description")

    @inline def withDescription(newValue: UndefOr[String]): SelectOption =
      objWithUndef(SelectOption, "description", newValue)

    /** id, name, and animated */
    @inline def emoji: UndefOr[ComponentEmoji] = selectDynamic[UndefOr[ComponentEmoji]]("emoji")

    @inline def withEmoji(newValue: UndefOr[ComponentEmoji]): SelectOption =
      objWithUndef(SelectOption, "emoji", newValue)

    /** Will show this option as selected by default */
    @inline def default: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("default")

    @inline def withDefault(newValue: UndefOr[Boolean]): SelectOption =
      objWithUndef(SelectOption, "default", newValue)

    override def values: Seq[() => Any] = Seq(() => label, () => value, () => description, () => emoji, () => default)
  }
  object SelectOption extends DiscordObjectCompanion[SelectOption] {
    def makeRaw(json: Json, cache: Map[String, Any]): SelectOption = new SelectOption(json, cache)

    /**
      * @param label
      *   User-facing name of the option; max 100 characters
      * @param value
      *   Dev-defined value of the option; max 100 characters
      * @param description
      *   Additional description of the option; max 100 characters
      * @param emoji
      *   id, name, and animated
      * @param default
      *   Will show this option as selected by default
      */
    def make20(
        label: String,
        value: String,
        description: UndefOr[String] = UndefOrUndefined(Some("description")),
        emoji: UndefOr[ComponentEmoji] = UndefOrUndefined(Some("emoji")),
        default: UndefOr[Boolean] = UndefOrUndefined(Some("default"))
    ): SelectOption = makeRawFromFields(
      "label"        := label,
      "value"        := value,
      "description" :=? description,
      "emoji"       :=? emoji,
      "default"     :=? default
    )
  }

  /**
    * Text inputs are an interactive component that render on modals. They can
    * be used to collect short-form or long-form text.
    */
  class TextInput(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Component {

    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    @inline def withTpe(newValue: ComponentType): TextInput = objWith(TextInput, "type", newValue)

    /** Developer-defined identifier for the input; max 100 characters */
    @inline def customId: String = selectDynamic[String]("custom_id")

    @inline def withCustomId(newValue: String): TextInput = objWith(TextInput, "custom_id", newValue)

    /** The Text Input Style */
    @inline def style: TextInput.TextInputStyle = selectDynamic[TextInput.TextInputStyle]("style")

    @inline def withStyle(newValue: TextInput.TextInputStyle): TextInput =
      objWith(TextInput, "style", newValue)

    /** Label for this component; max 45 characters */
    @inline def label: String = selectDynamic[String]("label")

    @inline def withLabel(newValue: String): TextInput = objWith(TextInput, "label", newValue)

    /** Minimum input length for a text input; min 0, max 4000 */
    @inline def minLength: UndefOr[Int] = selectDynamic[UndefOr[Int]]("min_length")

    @inline def withMinLength(newValue: UndefOr[Int]): TextInput = objWithUndef(TextInput, "min_length", newValue)

    /** Maximum input length for a text input; min 1, max 4000 */
    @inline def maxLength: UndefOr[Int] = selectDynamic[UndefOr[Int]]("max_length")

    @inline def withMaxLength(newValue: UndefOr[Int]): TextInput = objWithUndef(TextInput, "max_length", newValue)

    /** Whether this component is required to be filled (defaults to true) */
    @inline def required: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("required")

    @inline def withRequired(newValue: UndefOr[Boolean]): TextInput = objWithUndef(TextInput, "required", newValue)

    /** Pre-filled value for this component; max 4000 characters */
    @inline def value: UndefOr[String] = selectDynamic[UndefOr[String]]("value")

    @inline def withValue(newValue: UndefOr[String]): TextInput = objWithUndef(TextInput, "value", newValue)

    /** Custom placeholder text if the input is empty; max 100 characters */
    @inline def placeholder: UndefOr[String] = selectDynamic[UndefOr[String]]("placeholder")

    @inline def withPlaceholder(newValue: UndefOr[String]): TextInput =
      objWithUndef(TextInput, "placeholder", newValue)

    override def values: Seq[() => Any] = Seq(
      () => tpe,
      () => customId,
      () => style,
      () => label,
      () => minLength,
      () => maxLength,
      () => required,
      () => value,
      () => placeholder
    )
  }
  object TextInput extends DiscordObjectCompanion[TextInput] {
    def makeRaw(json: Json, cache: Map[String, Any]): TextInput = new TextInput(json, cache)

    /**
      * @param customId
      *   Developer-defined identifier for the input; max 100 characters
      * @param style
      *   The Text Input Style
      * @param label
      *   Label for this component; max 45 characters
      * @param minLength
      *   Minimum input length for a text input; min 0, max 4000
      * @param maxLength
      *   Maximum input length for a text input; min 1, max 4000
      * @param required
      *   Whether this component is required to be filled (defaults to true)
      * @param value
      *   Pre-filled value for this component; max 4000 characters
      * @param placeholder
      *   Custom placeholder text if the input is empty; max 100 characters
      */
    def make20(
        tpe: ComponentType = ComponentType.TextInput,
        customId: String,
        style: TextInput.TextInputStyle,
        label: String,
        minLength: UndefOr[Int] = UndefOrUndefined(Some("min_length")),
        maxLength: UndefOr[Int] = UndefOrUndefined(Some("max_length")),
        required: UndefOr[Boolean] = UndefOrUndefined(Some("required")),
        value: UndefOr[String] = UndefOrUndefined(Some("value")),
        placeholder: UndefOr[String] = UndefOrUndefined(Some("placeholder"))
    ): TextInput = makeRawFromFields(
      "type"         := tpe,
      "custom_id"    := customId,
      "style"        := style,
      "label"        := label,
      "min_length"  :=? minLength,
      "max_length"  :=? maxLength,
      "required"    :=? required,
      "value"       :=? value,
      "placeholder" :=? placeholder
    )

    sealed case class TextInputStyle private (value: Int) extends DiscordEnum[Int]
    object TextInputStyle                                 extends DiscordEnumCompanion[Int, TextInputStyle] {

      /** Single-line input */
      val Short: TextInputStyle = TextInputStyle(1)

      /** Multi-line input */
      val Paragraph: TextInputStyle = TextInputStyle(2)

      def unknown(value: Int): TextInputStyle = new TextInputStyle(value)

      val values: Seq[TextInputStyle] = Seq(Short, Paragraph)
    }
  }

  class UnknownComponent(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with Component {

    @inline def tpe: ComponentType = selectDynamic[ComponentType]("type")

    @inline def withTpe(newValue: ComponentType): UnknownComponent = objWith(UnknownComponent, "type", newValue)

    override def values: Seq[() => Any] = Seq(() => tpe)
  }
  object UnknownComponent extends DiscordObjectCompanion[UnknownComponent] {
    def makeRaw(json: Json, cache: Map[String, Any]): UnknownComponent =
      new UnknownComponent(json, cache)

    def make20(tpe: ComponentType): UnknownComponent = makeRawFromFields("type" := tpe)
  }
}
