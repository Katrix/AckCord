//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.data

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/data/channel.yaml

import java.time.OffsetDateTime

import ackcord.data.base._
import io.circe.Json

/** Represents a guild or DM channel within Discord. */
class RawChannel(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Channel {

  /** The id of this channel */
  @inline def id: ChannelId = selectDynamic[ChannelId]("id")

  /** The type of channel */
  @inline def tpe: Channel.ChannelType = selectDynamic[Channel.ChannelType]("type")

  /**
    * The id of the guild (may be missing for some channel objects received over
    * gateway guild dispatches)
    */
  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  /** Sorting position of the channel */
  @inline def position: UndefOr[Int] = selectDynamic[UndefOr[Int]]("position")

  /** Explicit permission overwrites for members and roles */
  @inline def permissionOverwrites: UndefOr[Seq[Channel.PermissionOverwrite]] =
    selectDynamic[UndefOr[Seq[Channel.PermissionOverwrite]]]("permission_overwrites")

  /** The name of the channel (1-100 characters) */
  @inline def name: JsonOption[String] = selectDynamic[JsonOption[String]]("name")

  /**
    * The channel topic (0-4096 characters for GUILD_FORUM channels, 0-1024
    * characters for all others)
    */
  @inline def topic: JsonOption[String] = selectDynamic[JsonOption[String]]("topic")

  /** Whether the channel is nsfw */
  @inline def nsfw: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("nsfw")

  /**
    * The id of the last message sent in this channel (or thread for GUILD_FORUM
    * channels) (may not point to an existing or valid message or thread)
    */
  @inline def lastMessageId: JsonOption[MessageId] = selectDynamic[JsonOption[MessageId]]("last_message_id")

  /** The bitrate (in bits) of the voice channel */
  @inline def bitrate: UndefOr[Int] = selectDynamic[UndefOr[Int]]("bitrate")

  /** The user limit of the voice channel */
  @inline def userLimit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("user_limit")

  /**
    * Amount of seconds a user has to wait before sending another message
    * (0-21600); bots, as well as users with the permission manage_messages or
    * manage_channel, are unaffected
    */
  @inline def rateLimitPerUser: UndefOr[Int] = selectDynamic[UndefOr[Int]]("rate_limit_per_user")

  /** The recipients of the DM */
  @inline def recipients: UndefOr[Seq[User]] = selectDynamic[UndefOr[Seq[User]]]("recipients")

  /** Icon hash of the group DM */
  @inline def icon: JsonOption[ImageHash] = selectDynamic[JsonOption[ImageHash]]("icon")

  /** Id of the creator of the group DM or thread */
  @inline def ownerId: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("owner_id")

  /** Application id of the group DM creator if it is bot-created */
  @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

  /**
    * For group DM channels: whether the channel is managed by an application
    * via the gdm.join OAuth2 scope
    */
  @inline def managed: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("managed")

  /**
    * For guild channels: id of the parent category for a channel (each parent
    * category can contain up to 50 channels), for threads: id of the text
    * channel this thread was created
    */
  @inline def parentId: UndefOr[GuildChannelId] = selectDynamic[UndefOr[GuildChannelId]]("parent_id")

  /**
    * When the last pinned message was pinned. This may be null in events such
    * as GUILD_CREATE when a message is not pinned.
    */
  @inline def lastPinTimestamp: JsonOption[OffsetDateTime] =
    selectDynamic[JsonOption[OffsetDateTime]]("last_pin_timestamp")

  /** Voice region id for the voice channel, automatic when set to null */
  @inline def rtcRegion: JsonOption[VoiceRegion] = selectDynamic[JsonOption[VoiceRegion]]("rtc_region")

  /** The camera video quality mode of the voice channel, 1 when not present */
  @inline def videoQualityMode: UndefOr[Channel.VideoQualityMode] =
    selectDynamic[UndefOr[Channel.VideoQualityMode]]("video_quality_mode")

  /**
    * Number of messages (not including the initial message or deleted messages)
    * in a thread.
    */
  @inline def messageCount: UndefOr[Int] = selectDynamic[UndefOr[Int]]("message_count")

  /** An approximate count of users in a thread, stops counting at 50 */
  @inline def memberCount: UndefOr[Int] = selectDynamic[UndefOr[Int]]("member_count")

  /** Thread-specific fields not needed by other channels */
  @inline def threadMetadata: UndefOr[Channel.ThreadMetadata] =
    selectDynamic[UndefOr[Channel.ThreadMetadata]]("thread_metadata")

  /**
    * Thread member object for the current user, if they have joined the thread,
    * only included on certain API endpoints
    */
  @inline def member: UndefOr[Channel.ThreadMember] = selectDynamic[UndefOr[Channel.ThreadMember]]("member")

  /**
    * Default duration, copied onto newly created threads, in minutes, threads
    * will stop showing in the channel list after the specified period of
    * inactivity, can be set to: 60, 1440, 4320, 10080
    */
  @inline def defaultAutoArchiveDuration: UndefOr[Int] = selectDynamic[UndefOr[Int]]("default_auto_archive_duration")

  /**
    * Computed permissions for the invoking user in the channel, including
    * overwrites, only included when part of the resolved data received on a
    * slash command interaction
    */
  @inline def permissions: UndefOr[Permissions] = selectDynamic[UndefOr[Permissions]]("permissions")

  /** Channel flags combined as a bitfield */
  @inline def flags: UndefOr[Channel.ChannelFlags] = selectDynamic[UndefOr[Channel.ChannelFlags]]("flags")

  /**
    * Number of messages ever sent in a thread, it's similar to message_count on
    * message creation, but will not decrement the number when a message is
    * deleted
    */
  @inline def totalMessageSent: UndefOr[Int] = selectDynamic[UndefOr[Int]]("total_message_sent")

  /** The set of tags that can be used in a GUILD_FORUM channel */
  @inline def availableTags: UndefOr[Seq[Channel.ForumTag]] =
    selectDynamic[UndefOr[Seq[Channel.ForumTag]]]("available_tags")

  /**
    * The IDs of the set of tags that have been applied to a thread in a
    * GUILD_FORUM channel
    */
  @inline def appliedTags: UndefOr[Seq[Snowflake[Channel.ForumTag]]] =
    selectDynamic[UndefOr[Seq[Snowflake[Channel.ForumTag]]]]("applied_tags")

  /**
    * The emoji to show in the add reaction button on a thread in a GUILD_FORUM
    * channel
    */
  @inline def defaultReactionEmoji: JsonOption[Channel.DefaultReaction] =
    selectDynamic[JsonOption[Channel.DefaultReaction]]("default_reaction_emoji")

  /**
    * The initial rate_limit_per_user to set on newly created threads in a
    * channel. this field is copied to the thread at creation time and does not
    * live update.
    */
  @inline def defaultThreadRateLimitPerUser: UndefOr[Int] =
    selectDynamic[UndefOr[Int]]("default_thread_rate_limit_per_user")

  /**
    * The default sort order type used to order posts in GUILD_FORUM channels.
    * Defaults to null, which indicates a preferred sort order hasn't been set
    * by a channel admin
    */
  @inline def defaultSortOrder: JsonOption[Channel.ForumSortOrder] =
    selectDynamic[JsonOption[Channel.ForumSortOrder]]("default_sort_order")

  /**
    * The default forum layout view used to display posts in GUILD_FORUM
    * channels. Defaults to 0, which indicates a layout view has not been set by
    * a channel admin
    */
  @inline def defaultForumLayout: UndefOr[Channel.ForumLayout] =
    selectDynamic[UndefOr[Channel.ForumLayout]]("default_forum_layout")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => tpe,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => topic,
    () => nsfw,
    () => lastMessageId,
    () => bitrate,
    () => userLimit,
    () => rateLimitPerUser,
    () => recipients,
    () => icon,
    () => ownerId,
    () => applicationId,
    () => managed,
    () => parentId,
    () => lastPinTimestamp,
    () => rtcRegion,
    () => videoQualityMode,
    () => messageCount,
    () => memberCount,
    () => threadMetadata,
    () => member,
    () => defaultAutoArchiveDuration,
    () => permissions,
    () => flags,
    () => totalMessageSent,
    () => availableTags,
    () => appliedTags,
    () => defaultReactionEmoji,
    () => defaultThreadRateLimitPerUser,
    () => defaultSortOrder,
    () => defaultForumLayout
  )
}
object RawChannel extends DiscordObjectCompanion[RawChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): RawChannel = new RawChannel(json, cache)

  /**
    * @param id
    *   The id of this channel
    * @param tpe
    *   The type of channel
    * @param guildId
    *   The id of the guild (may be missing for some channel objects received
    *   over gateway guild dispatches)
    * @param position
    *   Sorting position of the channel
    * @param permissionOverwrites
    *   Explicit permission overwrites for members and roles
    * @param name
    *   The name of the channel (1-100 characters)
    * @param topic
    *   The channel topic (0-4096 characters for GUILD_FORUM channels, 0-1024
    *   characters for all others)
    * @param nsfw
    *   Whether the channel is nsfw
    * @param lastMessageId
    *   The id of the last message sent in this channel (or thread for
    *   GUILD_FORUM channels) (may not point to an existing or valid message or
    *   thread)
    * @param bitrate
    *   The bitrate (in bits) of the voice channel
    * @param userLimit
    *   The user limit of the voice channel
    * @param rateLimitPerUser
    *   Amount of seconds a user has to wait before sending another message
    *   (0-21600); bots, as well as users with the permission manage_messages or
    *   manage_channel, are unaffected
    * @param recipients
    *   The recipients of the DM
    * @param icon
    *   Icon hash of the group DM
    * @param ownerId
    *   Id of the creator of the group DM or thread
    * @param applicationId
    *   Application id of the group DM creator if it is bot-created
    * @param managed
    *   For group DM channels: whether the channel is managed by an application
    *   via the gdm.join OAuth2 scope
    * @param parentId
    *   For guild channels: id of the parent category for a channel (each parent
    *   category can contain up to 50 channels), for threads: id of the text
    *   channel this thread was created
    * @param lastPinTimestamp
    *   When the last pinned message was pinned. This may be null in events such
    *   as GUILD_CREATE when a message is not pinned.
    * @param rtcRegion
    *   Voice region id for the voice channel, automatic when set to null
    * @param videoQualityMode
    *   The camera video quality mode of the voice channel, 1 when not present
    * @param messageCount
    *   Number of messages (not including the initial message or deleted
    *   messages) in a thread.
    * @param memberCount
    *   An approximate count of users in a thread, stops counting at 50
    * @param threadMetadata
    *   Thread-specific fields not needed by other channels
    * @param member
    *   Thread member object for the current user, if they have joined the
    *   thread, only included on certain API endpoints
    * @param defaultAutoArchiveDuration
    *   Default duration, copied onto newly created threads, in minutes, threads
    *   will stop showing in the channel list after the specified period of
    *   inactivity, can be set to: 60, 1440, 4320, 10080
    * @param permissions
    *   Computed permissions for the invoking user in the channel, including
    *   overwrites, only included when part of the resolved data received on a
    *   slash command interaction
    * @param flags
    *   Channel flags combined as a bitfield
    * @param totalMessageSent
    *   Number of messages ever sent in a thread, it's similar to message_count
    *   on message creation, but will not decrement the number when a message is
    *   deleted
    * @param availableTags
    *   The set of tags that can be used in a GUILD_FORUM channel
    * @param appliedTags
    *   The IDs of the set of tags that have been applied to a thread in a
    *   GUILD_FORUM channel
    * @param defaultReactionEmoji
    *   The emoji to show in the add reaction button on a thread in a
    *   GUILD_FORUM channel
    * @param defaultThreadRateLimitPerUser
    *   The initial rate_limit_per_user to set on newly created threads in a
    *   channel. this field is copied to the thread at creation time and does
    *   not live update.
    * @param defaultSortOrder
    *   The default sort order type used to order posts in GUILD_FORUM channels.
    *   Defaults to null, which indicates a preferred sort order hasn't been set
    *   by a channel admin
    * @param defaultForumLayout
    *   The default forum layout view used to display posts in GUILD_FORUM
    *   channels. Defaults to 0, which indicates a layout view has not been set
    *   by a channel admin
    */
  def make20(
      id: ChannelId,
      tpe: Channel.ChannelType,
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      position: UndefOr[Int] = UndefOrUndefined,
      permissionOverwrites: UndefOr[Seq[Channel.PermissionOverwrite]] = UndefOrUndefined,
      name: JsonOption[String] = JsonUndefined,
      topic: JsonOption[String] = JsonUndefined,
      nsfw: UndefOr[Boolean] = UndefOrUndefined,
      lastMessageId: JsonOption[MessageId] = JsonUndefined,
      bitrate: UndefOr[Int] = UndefOrUndefined,
      userLimit: UndefOr[Int] = UndefOrUndefined,
      rateLimitPerUser: UndefOr[Int] = UndefOrUndefined,
      recipients: UndefOr[Seq[User]] = UndefOrUndefined,
      icon: JsonOption[ImageHash] = JsonUndefined,
      ownerId: UndefOr[UserId] = UndefOrUndefined,
      applicationId: UndefOr[ApplicationId] = UndefOrUndefined,
      managed: UndefOr[Boolean] = UndefOrUndefined,
      parentId: UndefOr[GuildChannelId] = UndefOrUndefined,
      lastPinTimestamp: JsonOption[OffsetDateTime] = JsonUndefined,
      rtcRegion: JsonOption[VoiceRegion] = JsonUndefined,
      videoQualityMode: UndefOr[Channel.VideoQualityMode] = UndefOrUndefined,
      messageCount: UndefOr[Int] = UndefOrUndefined,
      memberCount: UndefOr[Int] = UndefOrUndefined,
      threadMetadata: UndefOr[Channel.ThreadMetadata] = UndefOrUndefined,
      member: UndefOr[Channel.ThreadMember] = UndefOrUndefined,
      defaultAutoArchiveDuration: UndefOr[Int] = UndefOrUndefined,
      permissions: UndefOr[Permissions] = UndefOrUndefined,
      flags: UndefOr[Channel.ChannelFlags] = UndefOrUndefined,
      totalMessageSent: UndefOr[Int] = UndefOrUndefined,
      availableTags: UndefOr[Seq[Channel.ForumTag]] = UndefOrUndefined,
      appliedTags: UndefOr[Seq[Snowflake[Channel.ForumTag]]] = UndefOrUndefined,
      defaultReactionEmoji: JsonOption[Channel.DefaultReaction] = JsonUndefined,
      defaultThreadRateLimitPerUser: UndefOr[Int] = UndefOrUndefined,
      defaultSortOrder: JsonOption[Channel.ForumSortOrder] = JsonUndefined,
      defaultForumLayout: UndefOr[Channel.ForumLayout] = UndefOrUndefined
  ): RawChannel = makeRawFromFields(
    "id"                                  := id,
    "type"                                := tpe,
    "guild_id"                           :=? guildId,
    "position"                           :=? position,
    "permission_overwrites"              :=? permissionOverwrites,
    "name"                               :=? name,
    "topic"                              :=? topic,
    "nsfw"                               :=? nsfw,
    "last_message_id"                    :=? lastMessageId,
    "bitrate"                            :=? bitrate,
    "user_limit"                         :=? userLimit,
    "rate_limit_per_user"                :=? rateLimitPerUser,
    "recipients"                         :=? recipients,
    "icon"                               :=? icon,
    "owner_id"                           :=? ownerId,
    "application_id"                     :=? applicationId,
    "managed"                            :=? managed,
    "parent_id"                          :=? parentId,
    "last_pin_timestamp"                 :=? lastPinTimestamp,
    "rtc_region"                         :=? rtcRegion,
    "video_quality_mode"                 :=? videoQualityMode,
    "message_count"                      :=? messageCount,
    "member_count"                       :=? memberCount,
    "thread_metadata"                    :=? threadMetadata,
    "member"                             :=? member,
    "default_auto_archive_duration"      :=? defaultAutoArchiveDuration,
    "permissions"                        :=? permissions,
    "flags"                              :=? flags,
    "total_message_sent"                 :=? totalMessageSent,
    "available_tags"                     :=? availableTags,
    "applied_tags"                       :=? appliedTags,
    "default_reaction_emoji"             :=? defaultReactionEmoji,
    "default_thread_rate_limit_per_user" :=? defaultThreadRateLimitPerUser,
    "default_sort_order"                 :=? defaultSortOrder,
    "default_forum_layout"               :=? defaultForumLayout
  )

}

sealed trait Channel extends DiscordObject {
  def asRawChannel: RawChannel = retype(RawChannel)

  def id: ChannelId
}

sealed trait TextChannel extends Channel {
  override def id: TextChannelId

  def lastMessageId: Option[MessageId]
}
object TextChannel extends DiscordObjectCompanion[TextChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): TextChannel =
    Channel.makeRaw(json, cache).asInstanceOf[TextChannel]
}

sealed trait GuildChannel extends Channel {
  override def id: GuildChannelId

  def guildId: UndefOr[GuildId]

  def position: Int

  def permissionOverwrites: Seq[Channel.PermissionOverwrite]

  def name: String

  def parentId: Option[GuildChannelId]
}
object GuildChannel extends DiscordObjectCompanion[GuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): GuildChannel =
    Channel.makeRaw(json, cache).asInstanceOf[GuildChannel]
}

sealed trait TextGuildChannel extends GuildChannel with TextChannel {
  override def id: TextGuildChannelId

  def rateLimitPerUser: UndefOr[Int]
}
object TextGuildChannel extends DiscordObjectCompanion[TextGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): TextGuildChannel =
    Channel.makeRaw(json, cache).asInstanceOf[TextGuildChannel]
}

sealed trait VoiceGuildChannel extends GuildChannel {
  override def id: VoiceGuildChannelId

  def bitrate: Int
  def userLimit: Int
  def rtcRegion: Option[String]
  def videoQualityMode: Channel.VideoQualityMode
}
object VoiceGuildChannel extends DiscordObjectCompanion[VoiceGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): VoiceGuildChannel =
    Channel.makeRaw(json, cache).asInstanceOf[VoiceGuildChannel]
}

class TopLevelTextGuildChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextGuildChannel {
  @inline override def id: TopLevelTextGuildChannelId = selectDynamic[TopLevelTextGuildChannelId]("id")

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def name: String = selectDynamic[String]("name")

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def topic: Option[String] = selectDynamic[Option[String]]("topic")

  @inline def lastPinTimestamp: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("last_pin_timestamp")

  @inline def defaultAutoArchiveDuration: Int = selectDynamic[Int]("default_auto_archive_duration")

  @inline def rateLimitPerUser: UndefOr[Int] = selectDynamic[UndefOr[Int]]("rate_limit_per_user")

  @inline def defaultThreadRateLimitPerUser: Int = selectDynamic[Int]("default_thread_rate_limit_per_user")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => lastMessageId,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => topic,
    () => lastPinTimestamp,
    () => defaultAutoArchiveDuration,
    () => rateLimitPerUser,
    () => defaultThreadRateLimitPerUser
  )
}
object TopLevelTextGuildChannel extends DiscordObjectCompanion[TopLevelTextGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): TopLevelTextGuildChannel = new TopLevelTextGuildChannel(json, cache)

  def make20(
      id: TopLevelTextGuildChannelId,
      lastMessageId: Option[MessageId],
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      topic: Option[String],
      lastPinTimestamp: Option[OffsetDateTime],
      defaultAutoArchiveDuration: Int,
      rateLimitPerUser: UndefOr[Int] = UndefOrUndefined,
      defaultThreadRateLimitPerUser: Int
  ): TopLevelTextGuildChannel = makeRawFromFields(
    "id"                                 := id,
    "last_message_id"                    := lastMessageId,
    "guild_id"                          :=? guildId,
    "position"                           := position,
    "permission_overwrites"              := permissionOverwrites,
    "name"                               := name,
    "parent_id"                          := parentId,
    "topic"                              := topic,
    "last_pin_timestamp"                 := lastPinTimestamp,
    "default_auto_archive_duration"      := defaultAutoArchiveDuration,
    "rate_limit_per_user"               :=? rateLimitPerUser,
    "default_thread_rate_limit_per_user" := defaultThreadRateLimitPerUser
  )

}

class NormalVoiceGuildChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextGuildChannel {
  @inline override def id: NormalVoiceGuildChannelId = selectDynamic[NormalVoiceGuildChannelId]("id")

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def name: String = selectDynamic[String]("name")

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def rateLimitPerUser: UndefOr[Int] = selectDynamic[UndefOr[Int]]("rate_limit_per_user")

  @inline def bitrate: Int = selectDynamic[Int]("bitrate")

  @inline def userLimit: Int = selectDynamic[Int]("user_limit")

  @inline def rtcRegion: Option[String] = selectDynamic[Option[String]]("rtc_region")

  @inline def videoQualityMode: Channel.VideoQualityMode = selectDynamic[Channel.VideoQualityMode]("video_quality_mode")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => lastMessageId,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => rateLimitPerUser,
    () => bitrate,
    () => userLimit,
    () => rtcRegion,
    () => videoQualityMode
  )
}
object NormalVoiceGuildChannel extends DiscordObjectCompanion[NormalVoiceGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): NormalVoiceGuildChannel = new NormalVoiceGuildChannel(json, cache)

  def make20(
      id: NormalVoiceGuildChannelId,
      lastMessageId: Option[MessageId],
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      rateLimitPerUser: UndefOr[Int] = UndefOrUndefined,
      bitrate: Int,
      userLimit: Int,
      rtcRegion: Option[String],
      videoQualityMode: Channel.VideoQualityMode
  ): NormalVoiceGuildChannel = makeRawFromFields(
    "id"                    := id,
    "last_message_id"       := lastMessageId,
    "guild_id"             :=? guildId,
    "position"              := position,
    "permission_overwrites" := permissionOverwrites,
    "name"                  := name,
    "parent_id"             := parentId,
    "rate_limit_per_user"  :=? rateLimitPerUser,
    "bitrate"               := bitrate,
    "user_limit"            := userLimit,
    "rtc_region"            := rtcRegion,
    "video_quality_mode"    := videoQualityMode
  )

}

class GuildCategory(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with GuildChannel {
  @inline override def id: GuildCategoryId = selectDynamic[GuildCategoryId]("id")

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def name: String = selectDynamic[String]("name")

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  override def values: Seq[() => Any] =
    Seq(() => id, () => guildId, () => position, () => permissionOverwrites, () => name, () => parentId)
}
object GuildCategory extends DiscordObjectCompanion[GuildCategory] {
  def makeRaw(json: Json, cache: Map[String, Any]): GuildCategory = new GuildCategory(json, cache)

  def make20(
      id: GuildCategoryId,
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId]
  ): GuildCategory = makeRawFromFields(
    "id"                    := id,
    "guild_id"             :=? guildId,
    "position"              := position,
    "permission_overwrites" := permissionOverwrites,
    "name"                  := name,
    "parent_id"             := parentId
  )

}

class ThreadChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextChannel {
  @inline override def id: ThreadChannelId = selectDynamic[ThreadChannelId]("id")

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def name: String = selectDynamic[String]("name")

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def lastPinTimestamp: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("last_pin_timestamp")

  @inline def rateLimitPerUser: Option[Int] = selectDynamic[Option[Int]]("rate_limit_per_user")

  @inline def ownerId: UserId = selectDynamic[UserId]("owner_id")

  @inline def memberCount: Int = selectDynamic[Int]("member_count")

  @inline def messageCount: Int = selectDynamic[Int]("message_count")

  @inline def totalMessageSent: Int = selectDynamic[Int]("total_message_sent")

  @inline def threadMetadata: Channel.ThreadMetadata = selectDynamic[Channel.ThreadMetadata]("thread_metadata")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => guildId,
    () => name,
    () => lastMessageId,
    () => lastPinTimestamp,
    () => rateLimitPerUser,
    () => ownerId,
    () => memberCount,
    () => messageCount,
    () => totalMessageSent,
    () => threadMetadata
  )
}
object ThreadChannel extends DiscordObjectCompanion[ThreadChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): ThreadChannel = new ThreadChannel(json, cache)

  def make20(
      id: ThreadChannelId,
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      name: String,
      lastMessageId: Option[MessageId],
      lastPinTimestamp: Option[OffsetDateTime],
      rateLimitPerUser: Option[Int],
      ownerId: UserId,
      memberCount: Int,
      messageCount: Int,
      totalMessageSent: Int,
      threadMetadata: Channel.ThreadMetadata
  ): ThreadChannel = makeRawFromFields(
    "id"                  := id,
    "guild_id"           :=? guildId,
    "name"                := name,
    "last_message_id"     := lastMessageId,
    "last_pin_timestamp"  := lastPinTimestamp,
    "rate_limit_per_user" := rateLimitPerUser,
    "owner_id"            := ownerId,
    "member_count"        := memberCount,
    "message_count"       := messageCount,
    "total_message_sent"  := totalMessageSent,
    "thread_metadata"     := threadMetadata
  )

}

class StageChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with VoiceGuildChannel {
  @inline override def id: StageChannelId = selectDynamic[StageChannelId]("id")

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def name: String = selectDynamic[String]("name")

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def bitrate: Int = selectDynamic[Int]("bitrate")

  @inline def userLimit: Int = selectDynamic[Int]("user_limit")

  @inline def rtcRegion: Option[String] = selectDynamic[Option[String]]("rtc_region")

  @inline def videoQualityMode: Channel.VideoQualityMode = selectDynamic[Channel.VideoQualityMode]("video_quality_mode")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => bitrate,
    () => userLimit,
    () => rtcRegion,
    () => videoQualityMode
  )
}
object StageChannel extends DiscordObjectCompanion[StageChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): StageChannel = new StageChannel(json, cache)

  def make20(
      id: StageChannelId,
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      bitrate: Int,
      userLimit: Int,
      rtcRegion: Option[String],
      videoQualityMode: Channel.VideoQualityMode
  ): StageChannel = makeRawFromFields(
    "id"                    := id,
    "guild_id"             :=? guildId,
    "position"              := position,
    "permission_overwrites" := permissionOverwrites,
    "name"                  := name,
    "parent_id"             := parentId,
    "bitrate"               := bitrate,
    "user_limit"            := userLimit,
    "rtc_region"            := rtcRegion,
    "video_quality_mode"    := videoQualityMode
  )

}

class ForumChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with GuildChannel {
  @inline override def id: ForumChannelId = selectDynamic[ForumChannelId]("id")

  @inline def lastMessageId: Option[ThreadChannelId] = selectDynamic[Option[ThreadChannelId]]("last_message_id")

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def name: String = selectDynamic[String]("name")

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def topic: Option[String] = selectDynamic[Option[String]]("topic")

  @inline def rateLimitPerUser: Option[Int] = selectDynamic[Option[Int]]("rate_limit_per_user")

  @inline def defaultAutoArchiveDuration: Option[Int] = selectDynamic[Option[Int]]("default_auto_archive_duration")

  @inline def flags: Channel.ChannelFlags = selectDynamic[Channel.ChannelFlags]("flags")

  @inline def availableTags: Seq[Channel.ForumTag] = selectDynamic[Seq[Channel.ForumTag]]("available_tags")

  @inline def defaultReactionEmoji: Option[Channel.DefaultReaction] =
    selectDynamic[Option[Channel.DefaultReaction]]("default_reaction_emoji")

  @inline def defaultThreadRateLimitPerUser: Int = selectDynamic[Int]("default_thread_rate_limit_per_user")

  @inline def defaultSortOrder: Channel.ForumSortOrder = selectDynamic[Channel.ForumSortOrder]("default_sort_order")

  @inline def defaultForumLayout: Channel.ForumLayout = selectDynamic[Channel.ForumLayout]("default_forum_layout")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => lastMessageId,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => topic,
    () => rateLimitPerUser,
    () => defaultAutoArchiveDuration,
    () => flags,
    () => availableTags,
    () => defaultReactionEmoji,
    () => defaultThreadRateLimitPerUser,
    () => defaultSortOrder,
    () => defaultForumLayout
  )
}
object ForumChannel extends DiscordObjectCompanion[ForumChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): ForumChannel = new ForumChannel(json, cache)

  def make20(
      id: ForumChannelId,
      lastMessageId: Option[ThreadChannelId],
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      topic: Option[String],
      rateLimitPerUser: Option[Int],
      defaultAutoArchiveDuration: Option[Int],
      flags: Channel.ChannelFlags,
      availableTags: Seq[Channel.ForumTag],
      defaultReactionEmoji: Option[Channel.DefaultReaction],
      defaultThreadRateLimitPerUser: Int,
      defaultSortOrder: Channel.ForumSortOrder,
      defaultForumLayout: Channel.ForumLayout
  ): ForumChannel = makeRawFromFields(
    "id"                                 := id,
    "last_message_id"                    := lastMessageId,
    "guild_id"                          :=? guildId,
    "position"                           := position,
    "permission_overwrites"              := permissionOverwrites,
    "name"                               := name,
    "parent_id"                          := parentId,
    "topic"                              := topic,
    "rate_limit_per_user"                := rateLimitPerUser,
    "default_auto_archive_duration"      := defaultAutoArchiveDuration,
    "flags"                              := flags,
    "available_tags"                     := availableTags,
    "default_reaction_emoji"             := defaultReactionEmoji,
    "default_thread_rate_limit_per_user" := defaultThreadRateLimitPerUser,
    "default_sort_order"                 := defaultSortOrder,
    "default_forum_layout"               := defaultForumLayout
  )

}

class DMChannel(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with TextChannel {
  @inline override def id: DMChannelId = selectDynamic[DMChannelId]("id")

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def recipients: Seq[User] = selectDynamic[Seq[User]]("recipients")

  override def values: Seq[() => Any] = Seq(() => id, () => lastMessageId, () => recipients)
}
object DMChannel extends DiscordObjectCompanion[DMChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): DMChannel = new DMChannel(json, cache)

  def make20(id: DMChannelId, lastMessageId: Option[MessageId], recipients: Seq[User]): DMChannel =
    makeRawFromFields("id" := id, "last_message_id" := lastMessageId, "recipients" := recipients)

}

class GroupDMChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextChannel {
  @inline override def id: GroupDMChannelId = selectDynamic[GroupDMChannelId]("id")

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def recipients: Seq[User] = selectDynamic[Seq[User]]("recipients")

  @inline def icon: Option[ImageHash] = selectDynamic[Option[ImageHash]]("icon")

  @inline def ownerId: UserId = selectDynamic[UserId]("owner_id")

  @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

  @inline def managed: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("managed")

  override def values: Seq[() => Any] =
    Seq(() => id, () => lastMessageId, () => recipients, () => icon, () => ownerId, () => applicationId, () => managed)
}
object GroupDMChannel extends DiscordObjectCompanion[GroupDMChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): GroupDMChannel = new GroupDMChannel(json, cache)

  def make20(
      id: GroupDMChannelId,
      lastMessageId: Option[MessageId],
      recipients: Seq[User],
      icon: Option[ImageHash],
      ownerId: UserId,
      applicationId: UndefOr[ApplicationId] = UndefOrUndefined,
      managed: UndefOr[Boolean] = UndefOrUndefined
  ): GroupDMChannel = makeRawFromFields(
    "id"              := id,
    "last_message_id" := lastMessageId,
    "recipients"      := recipients,
    "icon"            := icon,
    "owner_id"        := ownerId,
    "application_id" :=? applicationId,
    "managed"        :=? managed
  )

}

object Channel extends DiscordObjectCompanion[Channel] {

  def makeRaw(json: Json, cache: Map[String, Any]): Channel =
    json.hcursor.get[ChannelType]("type").toOption.fold(RawChannel.makeRaw(json, cache): Channel) {
      case ChannelType.GUILD_TEXT          => TopLevelTextGuildChannel.makeRaw(json, cache)
      case ChannelType.DM                  => DMChannel.makeRaw(json, cache)
      case ChannelType.GUILD_VOICE         => NormalVoiceGuildChannel.makeRaw(json, cache)
      case ChannelType.GROUP_DM            => GroupDMChannel.makeRaw(json, cache)
      case ChannelType.GUILD_CATEGORY      => GuildCategory.makeRaw(json, cache)
      case ChannelType.GUILD_ANNOUNCEMENT  => TopLevelTextGuildChannel.makeRaw(json, cache)
      case ChannelType.ANNOUNCEMENT_THREAD => ThreadChannel.makeRaw(json, cache)
      case ChannelType.PUBLIC_THREAD       => ThreadChannel.makeRaw(json, cache)
      case ChannelType.PRIVATE_THREAD      => ThreadChannel.makeRaw(json, cache)
      case ChannelType.GUILD_STAGE_VOICE   => StageChannel.makeRaw(json, cache)
      case ChannelType.GUILD_DIRECTORY     => RawChannel.makeRaw(json, cache)
      case ChannelType.GUILD_FORUM         => ForumChannel.makeRaw(json, cache)
      case _                               => RawChannel.makeRaw(json, cache)
    }

  sealed case class ChannelType private (value: Int) extends DiscordEnum[Int]
  object ChannelType                                 extends DiscordEnumCompanion[Int, ChannelType] {

    /** A text channel within a server */
    val GUILD_TEXT: ChannelType = ChannelType(0)

    /** A direct message between users */
    val DM: ChannelType = ChannelType(1)

    /** A voice channel within a server */
    val GUILD_VOICE: ChannelType = ChannelType(2)

    /** A direct message between multiple users */
    val GROUP_DM: ChannelType = ChannelType(3)

    /** An organizational category that contains up to 50 channels */
    val GUILD_CATEGORY: ChannelType = ChannelType(4)

    /**
      * A channel that users can follow and crosspost into their own server
      * (formerly news channels)
      */
    val GUILD_ANNOUNCEMENT: ChannelType = ChannelType(5)

    /** A temporary sub-channel within a GUILD_ANNOUNCEMENT channel */
    val ANNOUNCEMENT_THREAD: ChannelType = ChannelType(10)

    /** A temporary sub-channel within a GUILD_TEXT or GUILD_FORUM channel */
    val PUBLIC_THREAD: ChannelType = ChannelType(11)

    /**
      * A temporary sub-channel within a GUILD_TEXT channel that is only
      * viewable by those invited and those with the MANAGE_THREADS permission
      */
    val PRIVATE_THREAD: ChannelType = ChannelType(12)

    /** A voice channel for hosting events with an audience */
    val GUILD_STAGE_VOICE: ChannelType = ChannelType(13)

    /** The channel in a hub containing the listed servers */
    val GUILD_DIRECTORY: ChannelType = ChannelType(14)

    /** Channel that can only contain threads */
    val GUILD_FORUM: ChannelType = ChannelType(15)

    def unknown(value: Int): ChannelType = new ChannelType(value)

    def values: Seq[ChannelType] = Seq(
      GUILD_TEXT,
      DM,
      GUILD_VOICE,
      GROUP_DM,
      GUILD_CATEGORY,
      GUILD_ANNOUNCEMENT,
      ANNOUNCEMENT_THREAD,
      PUBLIC_THREAD,
      PRIVATE_THREAD,
      GUILD_STAGE_VOICE,
      GUILD_DIRECTORY,
      GUILD_FORUM
    )

  }

  sealed case class VideoQualityMode private (value: Int) extends DiscordEnum[Int]
  object VideoQualityMode                                 extends DiscordEnumCompanion[Int, VideoQualityMode] {

    /** Discord chooses the quality for optimal performance */
    val AUTO: VideoQualityMode = VideoQualityMode(1)

    /** 720p */
    val FULL: VideoQualityMode = VideoQualityMode(2)

    def unknown(value: Int): VideoQualityMode = new VideoQualityMode(value)

    def values: Seq[VideoQualityMode] = Seq(AUTO, FULL)

  }

  sealed case class ChannelFlags private (value: Int) extends DiscordEnum[Int]
  object ChannelFlags                                 extends DiscordEnumCompanion[Int, ChannelFlags] {

    /** This thread is pinned to the top of its parent GUILD_FORUM channel */
    val PINNED: ChannelFlags = ChannelFlags(1 << 1)

    /**
      * Whether a tag is required to be specified when creating a thread in a
      * GUILD_FORUM channel. Tags are specified in the applied_tags field.
      */
    val REQUIRE_TAG: ChannelFlags = ChannelFlags(1 << 4)

    def unknown(value: Int): ChannelFlags = new ChannelFlags(value)

    def values: Seq[ChannelFlags] = Seq(PINNED, REQUIRE_TAG)

    implicit class ChannelFlagsBitFieldOps(private val here: ChannelFlags) extends AnyVal {
      def toInt: Int = here.value

      def ++(there: ChannelFlags): ChannelFlags = ChannelFlags(here.value | there.value)

      def --(there: ChannelFlags): ChannelFlags = ChannelFlags(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }

  sealed case class ForumSortOrder private (value: Int) extends DiscordEnum[Int]
  object ForumSortOrder                                 extends DiscordEnumCompanion[Int, ForumSortOrder] {

    /** Sort forum posts by activity */
    val LATEST_ACTIVITY: ForumSortOrder = ForumSortOrder(0)

    /** Sort forum posts by creation time (from most recent to oldest) */
    val CREATION_DATE: ForumSortOrder = ForumSortOrder(1)

    def unknown(value: Int): ForumSortOrder = new ForumSortOrder(value)

    def values: Seq[ForumSortOrder] = Seq(LATEST_ACTIVITY, CREATION_DATE)

  }

  sealed case class ForumLayout private (value: Int) extends DiscordEnum[Int]
  object ForumLayout                                 extends DiscordEnumCompanion[Int, ForumLayout] {

    /** No default has been set for forum channel */
    val NOT_SET: ForumLayout = ForumLayout(0)

    /** Display posts as a list */
    val LIST_VIEW: ForumLayout = ForumLayout(1)

    /** Display posts as a collection of tiles */
    val GALLERY_VIEW: ForumLayout = ForumLayout(2)

    def unknown(value: Int): ForumLayout = new ForumLayout(value)

    def values: Seq[ForumLayout] = Seq(NOT_SET, LIST_VIEW, GALLERY_VIEW)

  }

  class PermissionOverwrite(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Role or user id */
    @inline def id: UserOrRoleId = selectDynamic[UserOrRoleId]("id")

    /** Either 0 (role) or 1 (member) */
    @inline def tpe: PermissionOverwrite.PermissionOverwriteType =
      selectDynamic[PermissionOverwrite.PermissionOverwriteType]("type")

    /** Permission bit set */
    @inline def allow: Permissions = selectDynamic[Permissions]("allow")

    /** Permission bit set */
    @inline def deny: Permissions = selectDynamic[Permissions]("deny")

    override def values: Seq[() => Any] = Seq(() => id, () => tpe, () => allow, () => deny)
  }
  object PermissionOverwrite extends DiscordObjectCompanion[PermissionOverwrite] {
    def makeRaw(json: Json, cache: Map[String, Any]): PermissionOverwrite = new PermissionOverwrite(json, cache)

    /**
      * @param id
      *   Role or user id
      * @param tpe
      *   Either 0 (role) or 1 (member)
      * @param allow
      *   Permission bit set
      * @param deny
      *   Permission bit set
      */
    def make20(
        id: UserOrRoleId,
        tpe: PermissionOverwrite.PermissionOverwriteType,
        allow: Permissions,
        deny: Permissions
    ): PermissionOverwrite = makeRawFromFields("id" := id, "type" := tpe, "allow" := allow, "deny" := deny)

    sealed case class PermissionOverwriteType private (value: Int) extends DiscordEnum[Int]
    object PermissionOverwriteType extends DiscordEnumCompanion[Int, PermissionOverwriteType] {

      val Role: PermissionOverwriteType   = PermissionOverwriteType(0)
      val Member: PermissionOverwriteType = PermissionOverwriteType(1)

      def unknown(value: Int): PermissionOverwriteType = new PermissionOverwriteType(value)

      def values: Seq[PermissionOverwriteType] = Seq(Role, Member)

    }
  }

  /**
    * The thread metadata object contains a number of thread-specific channel
    * fields that are not needed by other channel types.
    */
  class ThreadMetadata(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Whether the thread is archived */
    @inline def archived: Boolean = selectDynamic[Boolean]("archived")

    /**
      * The thread will stop showing in the channel list after
      * auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      * 4320, 10080
      */
    @inline def autoArchiveDuration: Int = selectDynamic[Int]("auto_archive_duration")

    /**
      * Timestamp when the thread's archive status was last changed, used for
      * calculating recent activity
      */
    @inline def archiveTimestamp: OffsetDateTime = selectDynamic[OffsetDateTime]("archive_timestamp")

    /**
      * Whether the thread is locked; when a thread is locked, only users with
      * MANAGE_THREADS can unarchive it
      */
    @inline def locked: Boolean = selectDynamic[Boolean]("locked")

    /**
      * Whether non-moderators can add other non-moderators to a thread; only
      * available on private threads
      */
    @inline def invitable: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("invitable")

    /**
      * Timestamp when the thread was created; only populated for threads
      * created after 2022-01-09
      */
    @inline def createTimestamp: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("create_timestamp")

    override def values: Seq[() => Any] = Seq(
      () => archived,
      () => autoArchiveDuration,
      () => archiveTimestamp,
      () => locked,
      () => invitable,
      () => createTimestamp
    )
  }
  object ThreadMetadata extends DiscordObjectCompanion[ThreadMetadata] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMetadata = new ThreadMetadata(json, cache)

    /**
      * @param archived
      *   Whether the thread is archived
      * @param autoArchiveDuration
      *   The thread will stop showing in the channel list after
      *   auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      *   4320, 10080
      * @param archiveTimestamp
      *   Timestamp when the thread's archive status was last changed, used for
      *   calculating recent activity
      * @param locked
      *   Whether the thread is locked; when a thread is locked, only users with
      *   MANAGE_THREADS can unarchive it
      * @param invitable
      *   Whether non-moderators can add other non-moderators to a thread; only
      *   available on private threads
      * @param createTimestamp
      *   Timestamp when the thread was created; only populated for threads
      *   created after 2022-01-09
      */
    def make20(
        archived: Boolean,
        autoArchiveDuration: Int,
        archiveTimestamp: OffsetDateTime,
        locked: Boolean,
        invitable: UndefOr[Boolean] = UndefOrUndefined,
        createTimestamp: UndefOr[OffsetDateTime] = UndefOrUndefined
    ): ThreadMetadata = makeRawFromFields(
      "archived"              := archived,
      "auto_archive_duration" := autoArchiveDuration,
      "archive_timestamp"     := archiveTimestamp,
      "locked"                := locked,
      "invitable"            :=? invitable,
      "create_timestamp"     :=? createTimestamp
    )

  }

  /**
    * A thread member object contains information about a user that has joined a
    * thread.
    */
  class ThreadMember(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the thread */
    @inline def id: UndefOr[ThreadChannelId] = selectDynamic[UndefOr[ThreadChannelId]]("id")

    /** ID of the user */
    @inline def userId: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("user_id")

    /** Time the user last joined the thread */
    @inline def joinTimestamp: OffsetDateTime = selectDynamic[OffsetDateTime]("join_timestamp")

    /** Any user-thread settings, currently only used for notifications */
    @inline def flags: Int = selectDynamic[Int]("flags")

    /** Additional information about the user */
    @inline def member: UndefOr[GuildMember] = selectDynamic[UndefOr[GuildMember]]("member")

    override def values: Seq[() => Any] = Seq(() => id, () => userId, () => joinTimestamp, () => flags, () => member)
  }
  object ThreadMember extends DiscordObjectCompanion[ThreadMember] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMember = new ThreadMember(json, cache)

    /**
      * @param id
      *   ID of the thread
      * @param userId
      *   ID of the user
      * @param joinTimestamp
      *   Time the user last joined the thread
      * @param flags
      *   Any user-thread settings, currently only used for notifications
      * @param member
      *   Additional information about the user
      */
    def make20(
        id: UndefOr[ThreadChannelId] = UndefOrUndefined,
        userId: UndefOr[UserId] = UndefOrUndefined,
        joinTimestamp: OffsetDateTime,
        flags: Int,
        member: UndefOr[GuildMember] = UndefOrUndefined
    ): ThreadMember = makeRawFromFields(
      "id"            :=? id,
      "user_id"       :=? userId,
      "join_timestamp" := joinTimestamp,
      "flags"          := flags,
      "member"        :=? member
    )

  }

  /**
    * An object that specifies the emoji to use as the default way to react to a
    * forum post. Exactly one of emoji_id and emoji_name must be set.
    */
  class DefaultReaction(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of a guild's custom emoji */
    @inline def emojiId: Option[EmojiId] = selectDynamic[Option[EmojiId]]("emoji_id")

    /** The unicode character of the emoji */
    @inline def emojiName: Option[String] = selectDynamic[Option[String]]("emoji_name")

    override def values: Seq[() => Any] = Seq(() => emojiId, () => emojiName)
  }
  object DefaultReaction extends DiscordObjectCompanion[DefaultReaction] {
    def makeRaw(json: Json, cache: Map[String, Any]): DefaultReaction = new DefaultReaction(json, cache)

    /**
      * @param emojiId
      *   The id of a guild's custom emoji
      * @param emojiName
      *   The unicode character of the emoji
      */
    def make20(emojiId: Option[EmojiId], emojiName: Option[String]): DefaultReaction =
      makeRawFromFields("emoji_id" := emojiId, "emoji_name" := emojiName)

  }

  /**
    * An object that represents a tag that is able to be applied to a thread in
    * a GUILD_FORUM channel.
    */
  class ForumTag(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of the tag */
    @inline def id: Snowflake[ForumTag] = selectDynamic[Snowflake[ForumTag]]("id")

    /** The name of the tag (0-20 characters) */
    @inline def name: String = selectDynamic[String]("name")

    /**
      * Whether this tag can only be added to or removed from threads by a
      * member with the MANAGE_THREADS permission
      */
    @inline def moderated: Boolean = selectDynamic[Boolean]("moderated")

    /** The id of a guild's custom emoji */
    @inline def emojiId: Option[EmojiId] = selectDynamic[Option[EmojiId]]("emoji_id")

    /** The unicode character of the emoji */
    @inline def emojiName: Option[String] = selectDynamic[Option[String]]("emoji_name")

    override def values: Seq[() => Any] = Seq(() => id, () => name, () => moderated, () => emojiId, () => emojiName)
  }
  object ForumTag extends DiscordObjectCompanion[ForumTag] {
    def makeRaw(json: Json, cache: Map[String, Any]): ForumTag = new ForumTag(json, cache)

    /**
      * @param id
      *   The id of the tag
      * @param name
      *   The name of the tag (0-20 characters)
      * @param moderated
      *   Whether this tag can only be added to or removed from threads by a
      *   member with the MANAGE_THREADS permission
      * @param emojiId
      *   The id of a guild's custom emoji
      * @param emojiName
      *   The unicode character of the emoji
      */
    def make20(
        id: Snowflake[ForumTag],
        name: String,
        moderated: Boolean,
        emojiId: Option[EmojiId],
        emojiName: Option[String]
    ): ForumTag = makeRawFromFields(
      "id"         := id,
      "name"       := name,
      "moderated"  := moderated,
      "emoji_id"   := emojiId,
      "emoji_name" := emojiName
    )

  }
}

/** Represents a message sent in a channel within Discord. */
class Message(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Id of the message */
  @inline def id: MessageId = selectDynamic[MessageId]("id")

  /** Id of the channel the message was sent in */
  @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

  /**
    * The author of this message (not guaranteed to be a valid user, see below)
    */
  @inline def author: MessageAuthor = selectDynamic[MessageAuthor]("author")

  /** Contents of the message */
  @inline def content: String = selectDynamic[String]("content")

  /** When this message was sent */
  @inline def timestamp: OffsetDateTime = selectDynamic[OffsetDateTime]("timestamp")

  /** When this message was edited (or null if never) */
  @inline def editedTimestamp: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("edited_timestamp")

  /** Whether this was a TTS message */
  @inline def tts: Boolean = selectDynamic[Boolean]("tts")

  /** Whether this message mentions everyone */
  @inline def mentionEveryone: Boolean = selectDynamic[Boolean]("mention_everyone")

  /** Users specifically mentioned in the message */
  @inline def mentions: Seq[User] = selectDynamic[Seq[User]]("mentions")

  /** Roles specifically mentioned in this message */
  @inline def mentionRoles: Seq[RoleId] = selectDynamic[Seq[RoleId]]("mention_roles")

  /** Channels specifically mentioned in this message */
  @inline def mentionChannels: UndefOr[Seq[Message.ChannelMention]] =
    selectDynamic[UndefOr[Seq[Message.ChannelMention]]]("mention_channels")

  /** Any attached files */
  @inline def attachments: Seq[Attachment] = selectDynamic[Seq[Attachment]]("attachments")

  /** Any embedded content */
  @inline def embeds: Seq[Embed] = selectDynamic[Seq[Embed]]("embeds")

  /** Reactions to the message */
  @inline def reactions: UndefOr[Seq[Reaction]] = selectDynamic[UndefOr[Seq[Reaction]]]("reactions")

  /** Used for validating a message was sent */
  @inline def nonce: UndefOr[IntOrString] = selectDynamic[UndefOr[IntOrString]]("nonce")

  /** Whether this message is pinned */
  @inline def pinned: Boolean = selectDynamic[Boolean]("pinned")

  /** If the message is generated by a webhook, this is the webhook's id */
  @inline def webhookId: UndefOr[WebhookId] = selectDynamic[UndefOr[WebhookId]]("webhook_id")

  /** Type of message */
  @inline def tpe: Message.MessageType = selectDynamic[Message.MessageType]("type")

  /** Sent with Rich Presence-related chat embeds */
  @inline def activity: UndefOr[Message.MessageActivity] = selectDynamic[UndefOr[Message.MessageActivity]]("activity")

  /** Sent with Rich Presence-related chat embeds */
  @inline def application: UndefOr[Message.MessageApplicationStub] =
    selectDynamic[UndefOr[Message.MessageApplicationStub]]("application")

  /**
    * If the message is an Interaction or application-owned webhook, this is the
    * id of the application
    */
  @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

  /**
    * Data showing the source of a crosspost, channel follow add, pin, or reply
    * message
    */
  @inline def messageReference: UndefOr[MessageReference] =
    selectDynamic[UndefOr[MessageReference]]("message_reference")

  /** Message flags combined as a bitfield */
  @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

  /** The message associated with the message_reference */
  @inline def referencedMessage: JsonOption[Message] = selectDynamic[JsonOption[Message]]("referenced_message")

  /** Sent if the message is a response to an Interaction */
  @inline def interaction: UndefOr[Message.MessageInteractionStub] =
    selectDynamic[UndefOr[Message.MessageInteractionStub]]("interaction")

  /**
    * The thread that was started from this message, includes thread member
    * object
    */
  @inline def thread: UndefOr[Channel] = selectDynamic[UndefOr[Channel]]("thread")

  /**
    * Sent if the message contains components like buttons, action rows, or
    * other interactive components
    */
  @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

  /** Sent if the message contains stickers */
  @inline def stickerItems: UndefOr[Seq[Sticker.StickerItem]] =
    selectDynamic[UndefOr[Seq[Sticker.StickerItem]]]("sticker_items")

  /**
    * A generally increasing integer (there may be gaps or duplicates) that
    * represents the approximate position of the message in a thread, it can be
    * used to estimate the relative position of the message in a thread in
    * company with total_message_sent on parent thread
    */
  @inline def position: UndefOr[Int] = selectDynamic[UndefOr[Int]]("position")

  /**
    * Data of the role subscription purchase or renewal that prompted this
    * ROLE_SUBSCRIPTION_PURCHASE message
    */
  @inline def roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] =
    selectDynamic[UndefOr[Message.RoleSubscriptionData]]("role_subscription_data")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => channelId,
    () => author,
    () => content,
    () => timestamp,
    () => editedTimestamp,
    () => tts,
    () => mentionEveryone,
    () => mentions,
    () => mentionRoles,
    () => mentionChannels,
    () => attachments,
    () => embeds,
    () => reactions,
    () => nonce,
    () => pinned,
    () => webhookId,
    () => tpe,
    () => activity,
    () => application,
    () => applicationId,
    () => messageReference,
    () => flags,
    () => referencedMessage,
    () => interaction,
    () => thread,
    () => components,
    () => stickerItems,
    () => position,
    () => roleSubscriptionData
  )
}
object Message extends DiscordObjectCompanion[Message] {
  def makeRaw(json: Json, cache: Map[String, Any]): Message = new Message(json, cache)

  /**
    * @param id
    *   Id of the message
    * @param channelId
    *   Id of the channel the message was sent in
    * @param author
    *   The author of this message (not guaranteed to be a valid user, see
    *   below)
    * @param content
    *   Contents of the message
    * @param timestamp
    *   When this message was sent
    * @param editedTimestamp
    *   When this message was edited (or null if never)
    * @param tts
    *   Whether this was a TTS message
    * @param mentionEveryone
    *   Whether this message mentions everyone
    * @param mentions
    *   Users specifically mentioned in the message
    * @param mentionRoles
    *   Roles specifically mentioned in this message
    * @param mentionChannels
    *   Channels specifically mentioned in this message
    * @param attachments
    *   Any attached files
    * @param embeds
    *   Any embedded content
    * @param reactions
    *   Reactions to the message
    * @param nonce
    *   Used for validating a message was sent
    * @param pinned
    *   Whether this message is pinned
    * @param webhookId
    *   If the message is generated by a webhook, this is the webhook's id
    * @param tpe
    *   Type of message
    * @param activity
    *   Sent with Rich Presence-related chat embeds
    * @param application
    *   Sent with Rich Presence-related chat embeds
    * @param applicationId
    *   If the message is an Interaction or application-owned webhook, this is
    *   the id of the application
    * @param messageReference
    *   Data showing the source of a crosspost, channel follow add, pin, or
    *   reply message
    * @param flags
    *   Message flags combined as a bitfield
    * @param referencedMessage
    *   The message associated with the message_reference
    * @param interaction
    *   Sent if the message is a response to an Interaction
    * @param thread
    *   The thread that was started from this message, includes thread member
    *   object
    * @param components
    *   Sent if the message contains components like buttons, action rows, or
    *   other interactive components
    * @param stickerItems
    *   Sent if the message contains stickers
    * @param position
    *   A generally increasing integer (there may be gaps or duplicates) that
    *   represents the approximate position of the message in a thread, it can
    *   be used to estimate the relative position of the message in a thread in
    *   company with total_message_sent on parent thread
    * @param roleSubscriptionData
    *   Data of the role subscription purchase or renewal that prompted this
    *   ROLE_SUBSCRIPTION_PURCHASE message
    */
  def make20(
      id: MessageId,
      channelId: TextChannelId,
      author: MessageAuthor,
      content: String,
      timestamp: OffsetDateTime,
      editedTimestamp: Option[OffsetDateTime],
      tts: Boolean,
      mentionEveryone: Boolean,
      mentions: Seq[User],
      mentionRoles: Seq[RoleId],
      mentionChannels: UndefOr[Seq[Message.ChannelMention]] = UndefOrUndefined,
      attachments: Seq[Attachment],
      embeds: Seq[Embed],
      reactions: UndefOr[Seq[Reaction]] = UndefOrUndefined,
      nonce: UndefOr[IntOrString] = UndefOrUndefined,
      pinned: Boolean,
      webhookId: UndefOr[WebhookId] = UndefOrUndefined,
      tpe: Message.MessageType,
      activity: UndefOr[Message.MessageActivity] = UndefOrUndefined,
      application: UndefOr[Message.MessageApplicationStub] = UndefOrUndefined,
      applicationId: UndefOr[ApplicationId] = UndefOrUndefined,
      messageReference: UndefOr[MessageReference] = UndefOrUndefined,
      flags: UndefOr[Message.MessageFlags] = UndefOrUndefined,
      referencedMessage: JsonOption[Message] = JsonUndefined,
      interaction: UndefOr[Message.MessageInteractionStub] = UndefOrUndefined,
      thread: UndefOr[Channel] = UndefOrUndefined,
      components: UndefOr[Seq[Component]] = UndefOrUndefined,
      stickerItems: UndefOr[Seq[Sticker.StickerItem]] = UndefOrUndefined,
      position: UndefOr[Int] = UndefOrUndefined,
      roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] = UndefOrUndefined
  ): Message = makeRawFromFields(
    "id"                      := id,
    "channel_id"              := channelId,
    "author"                  := author,
    "content"                 := content,
    "timestamp"               := timestamp,
    "edited_timestamp"        := editedTimestamp,
    "tts"                     := tts,
    "mention_everyone"        := mentionEveryone,
    "mentions"                := mentions,
    "mention_roles"           := mentionRoles,
    "mention_channels"       :=? mentionChannels,
    "attachments"             := attachments,
    "embeds"                  := embeds,
    "reactions"              :=? reactions,
    "nonce"                  :=? nonce,
    "pinned"                  := pinned,
    "webhook_id"             :=? webhookId,
    "type"                    := tpe,
    "activity"               :=? activity,
    "application"            :=? application,
    "application_id"         :=? applicationId,
    "message_reference"      :=? messageReference,
    "flags"                  :=? flags,
    "referenced_message"     :=? referencedMessage,
    "interaction"            :=? interaction,
    "thread"                 :=? thread,
    "components"             :=? components,
    "sticker_items"          :=? stickerItems,
    "position"               :=? position,
    "role_subscription_data" :=? roleSubscriptionData
  )

  /** Represents a message sent in a channel within Discord. */
  class Partial(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Id of the message */
    @inline def id: MessageId = selectDynamic[MessageId]("id")

    /** Id of the channel the message was sent in */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /**
      * The author of this message (not guaranteed to be a valid user, see
      * below)
      */
    @inline def author: UndefOr[MessageAuthor] = selectDynamic[UndefOr[MessageAuthor]]("author")

    /** Contents of the message */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    /** When this message was sent */
    @inline def timestamp: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("timestamp")

    /** When this message was edited (or null if never) */
    @inline def editedTimestamp: JsonOption[OffsetDateTime] =
      selectDynamic[JsonOption[OffsetDateTime]]("edited_timestamp")

    /** Whether this was a TTS message */
    @inline def tts: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("tts")

    /** Whether this message mentions everyone */
    @inline def mentionEveryone: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("mention_everyone")

    /** Users specifically mentioned in the message */
    @inline def mentions: UndefOr[Seq[User]] = selectDynamic[UndefOr[Seq[User]]]("mentions")

    /** Roles specifically mentioned in this message */
    @inline def mentionRoles: UndefOr[Seq[RoleId]] = selectDynamic[UndefOr[Seq[RoleId]]]("mention_roles")

    /** Channels specifically mentioned in this message */
    @inline def mentionChannels: UndefOr[Seq[Message.ChannelMention]] =
      selectDynamic[UndefOr[Seq[Message.ChannelMention]]]("mention_channels")

    /** Any attached files */
    @inline def attachments: UndefOr[Seq[Attachment]] = selectDynamic[UndefOr[Seq[Attachment]]]("attachments")

    /** Any embedded content */
    @inline def embeds: UndefOr[Seq[Embed]] = selectDynamic[UndefOr[Seq[Embed]]]("embeds")

    /** Reactions to the message */
    @inline def reactions: UndefOr[Seq[Reaction]] = selectDynamic[UndefOr[Seq[Reaction]]]("reactions")

    /** Used for validating a message was sent */
    @inline def nonce: UndefOr[IntOrString] = selectDynamic[UndefOr[IntOrString]]("nonce")

    /** Whether this message is pinned */
    @inline def pinned: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("pinned")

    /** If the message is generated by a webhook, this is the webhook's id */
    @inline def webhookId: UndefOr[WebhookId] = selectDynamic[UndefOr[WebhookId]]("webhook_id")

    /** Type of message */
    @inline def tpe: UndefOr[Message.MessageType] = selectDynamic[UndefOr[Message.MessageType]]("type")

    /** Sent with Rich Presence-related chat embeds */
    @inline def activity: UndefOr[Message.MessageActivity] = selectDynamic[UndefOr[Message.MessageActivity]]("activity")

    /** Sent with Rich Presence-related chat embeds */
    @inline def application: UndefOr[Message.MessageApplicationStub] =
      selectDynamic[UndefOr[Message.MessageApplicationStub]]("application")

    /**
      * If the message is an Interaction or application-owned webhook, this is
      * the id of the application
      */
    @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

    /**
      * Data showing the source of a crosspost, channel follow add, pin, or
      * reply message
      */
    @inline def messageReference: UndefOr[MessageReference] =
      selectDynamic[UndefOr[MessageReference]]("message_reference")

    /** Message flags combined as a bitfield */
    @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

    /** The message associated with the message_reference */
    @inline def referencedMessage: JsonOption[Message] = selectDynamic[JsonOption[Message]]("referenced_message")

    /** Sent if the message is a response to an Interaction */
    @inline def interaction: UndefOr[Message.MessageInteractionStub] =
      selectDynamic[UndefOr[Message.MessageInteractionStub]]("interaction")

    /**
      * The thread that was started from this message, includes thread member
      * object
      */
    @inline def thread: UndefOr[Channel] = selectDynamic[UndefOr[Channel]]("thread")

    /**
      * Sent if the message contains components like buttons, action rows, or
      * other interactive components
      */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    /** Sent if the message contains stickers */
    @inline def stickerItems: UndefOr[Seq[Sticker.StickerItem]] =
      selectDynamic[UndefOr[Seq[Sticker.StickerItem]]]("sticker_items")

    /**
      * A generally increasing integer (there may be gaps or duplicates) that
      * represents the approximate position of the message in a thread, it can
      * be used to estimate the relative position of the message in a thread in
      * company with total_message_sent on parent thread
      */
    @inline def position: UndefOr[Int] = selectDynamic[UndefOr[Int]]("position")

    /**
      * Data of the role subscription purchase or renewal that prompted this
      * ROLE_SUBSCRIPTION_PURCHASE message
      */
    @inline def roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] =
      selectDynamic[UndefOr[Message.RoleSubscriptionData]]("role_subscription_data")

    override def values: Seq[() => Any] = Seq(
      () => id,
      () => channelId,
      () => author,
      () => content,
      () => timestamp,
      () => editedTimestamp,
      () => tts,
      () => mentionEveryone,
      () => mentions,
      () => mentionRoles,
      () => mentionChannels,
      () => attachments,
      () => embeds,
      () => reactions,
      () => nonce,
      () => pinned,
      () => webhookId,
      () => tpe,
      () => activity,
      () => application,
      () => applicationId,
      () => messageReference,
      () => flags,
      () => referencedMessage,
      () => interaction,
      () => thread,
      () => components,
      () => stickerItems,
      () => position,
      () => roleSubscriptionData
    )
  }
  object Partial extends DiscordObjectCompanion[Partial] {
    def makeRaw(json: Json, cache: Map[String, Any]): Partial = new Partial(json, cache)

    /**
      * @param id
      *   Id of the message
      * @param channelId
      *   Id of the channel the message was sent in
      * @param author
      *   The author of this message (not guaranteed to be a valid user, see
      *   below)
      * @param content
      *   Contents of the message
      * @param timestamp
      *   When this message was sent
      * @param editedTimestamp
      *   When this message was edited (or null if never)
      * @param tts
      *   Whether this was a TTS message
      * @param mentionEveryone
      *   Whether this message mentions everyone
      * @param mentions
      *   Users specifically mentioned in the message
      * @param mentionRoles
      *   Roles specifically mentioned in this message
      * @param mentionChannels
      *   Channels specifically mentioned in this message
      * @param attachments
      *   Any attached files
      * @param embeds
      *   Any embedded content
      * @param reactions
      *   Reactions to the message
      * @param nonce
      *   Used for validating a message was sent
      * @param pinned
      *   Whether this message is pinned
      * @param webhookId
      *   If the message is generated by a webhook, this is the webhook's id
      * @param tpe
      *   Type of message
      * @param activity
      *   Sent with Rich Presence-related chat embeds
      * @param application
      *   Sent with Rich Presence-related chat embeds
      * @param applicationId
      *   If the message is an Interaction or application-owned webhook, this is
      *   the id of the application
      * @param messageReference
      *   Data showing the source of a crosspost, channel follow add, pin, or
      *   reply message
      * @param flags
      *   Message flags combined as a bitfield
      * @param referencedMessage
      *   The message associated with the message_reference
      * @param interaction
      *   Sent if the message is a response to an Interaction
      * @param thread
      *   The thread that was started from this message, includes thread member
      *   object
      * @param components
      *   Sent if the message contains components like buttons, action rows, or
      *   other interactive components
      * @param stickerItems
      *   Sent if the message contains stickers
      * @param position
      *   A generally increasing integer (there may be gaps or duplicates) that
      *   represents the approximate position of the message in a thread, it can
      *   be used to estimate the relative position of the message in a thread
      *   in company with total_message_sent on parent thread
      * @param roleSubscriptionData
      *   Data of the role subscription purchase or renewal that prompted this
      *   ROLE_SUBSCRIPTION_PURCHASE message
      */
    def make20(
        id: MessageId,
        channelId: TextChannelId,
        author: UndefOr[MessageAuthor] = UndefOrUndefined,
        content: UndefOr[String] = UndefOrUndefined,
        timestamp: UndefOr[OffsetDateTime] = UndefOrUndefined,
        editedTimestamp: JsonOption[OffsetDateTime] = JsonUndefined,
        tts: UndefOr[Boolean] = UndefOrUndefined,
        mentionEveryone: UndefOr[Boolean] = UndefOrUndefined,
        mentions: UndefOr[Seq[User]] = UndefOrUndefined,
        mentionRoles: UndefOr[Seq[RoleId]] = UndefOrUndefined,
        mentionChannels: UndefOr[Seq[Message.ChannelMention]] = UndefOrUndefined,
        attachments: UndefOr[Seq[Attachment]] = UndefOrUndefined,
        embeds: UndefOr[Seq[Embed]] = UndefOrUndefined,
        reactions: UndefOr[Seq[Reaction]] = UndefOrUndefined,
        nonce: UndefOr[IntOrString] = UndefOrUndefined,
        pinned: UndefOr[Boolean] = UndefOrUndefined,
        webhookId: UndefOr[WebhookId] = UndefOrUndefined,
        tpe: UndefOr[Message.MessageType] = UndefOrUndefined,
        activity: UndefOr[Message.MessageActivity] = UndefOrUndefined,
        application: UndefOr[Message.MessageApplicationStub] = UndefOrUndefined,
        applicationId: UndefOr[ApplicationId] = UndefOrUndefined,
        messageReference: UndefOr[MessageReference] = UndefOrUndefined,
        flags: UndefOr[Message.MessageFlags] = UndefOrUndefined,
        referencedMessage: JsonOption[Message] = JsonUndefined,
        interaction: UndefOr[Message.MessageInteractionStub] = UndefOrUndefined,
        thread: UndefOr[Channel] = UndefOrUndefined,
        components: UndefOr[Seq[Component]] = UndefOrUndefined,
        stickerItems: UndefOr[Seq[Sticker.StickerItem]] = UndefOrUndefined,
        position: UndefOr[Int] = UndefOrUndefined,
        roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] = UndefOrUndefined
    ): Partial = makeRawFromFields(
      "id"                      := id,
      "channel_id"              := channelId,
      "author"                 :=? author,
      "content"                :=? content,
      "timestamp"              :=? timestamp,
      "edited_timestamp"       :=? editedTimestamp,
      "tts"                    :=? tts,
      "mention_everyone"       :=? mentionEveryone,
      "mentions"               :=? mentions,
      "mention_roles"          :=? mentionRoles,
      "mention_channels"       :=? mentionChannels,
      "attachments"            :=? attachments,
      "embeds"                 :=? embeds,
      "reactions"              :=? reactions,
      "nonce"                  :=? nonce,
      "pinned"                 :=? pinned,
      "webhook_id"             :=? webhookId,
      "type"                   :=? tpe,
      "activity"               :=? activity,
      "application"            :=? application,
      "application_id"         :=? applicationId,
      "message_reference"      :=? messageReference,
      "flags"                  :=? flags,
      "referenced_message"     :=? referencedMessage,
      "interaction"            :=? interaction,
      "thread"                 :=? thread,
      "components"             :=? components,
      "sticker_items"          :=? stickerItems,
      "position"               :=? position,
      "role_subscription_data" :=? roleSubscriptionData
    )

    sealed case class MessageType private (value: Int) extends DiscordEnum[Int]
    object MessageType extends DiscordEnumCompanion[Int, MessageType] {

      val DEFAULT: MessageType                                      = MessageType(0)
      val RECIPIENT_ADD: MessageType                                = MessageType(1)
      val RECIPIENT_REMOVE: MessageType                             = MessageType(2)
      val CALL: MessageType                                         = MessageType(3)
      val CHANNEL_NAME_CHANGE: MessageType                          = MessageType(4)
      val CHANNEL_ICON_CHANGE: MessageType                          = MessageType(5)
      val CHANNEL_PINNED_MESSAGE: MessageType                       = MessageType(6)
      val USER_JOIN: MessageType                                    = MessageType(7)
      val GUILD_BOOST: MessageType                                  = MessageType(8)
      val GUILD_BOOST_TIER_1: MessageType                           = MessageType(9)
      val GUILD_BOOST_TIER_2: MessageType                           = MessageType(10)
      val GUILD_BOOST_TIER_3: MessageType                           = MessageType(11)
      val CHANNEL_FOLLOW_ADD: MessageType                           = MessageType(12)
      val GUILD_DISCOVERY_DISQUALIFIED: MessageType                 = MessageType(14)
      val GUILD_DISCOVERY_REQUALIFIED: MessageType                  = MessageType(15)
      val GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING: MessageType = MessageType(16)
      val GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING: MessageType   = MessageType(17)
      val THREAD_CREATED: MessageType                               = MessageType(18)
      val REPLY: MessageType                                        = MessageType(19)
      val CHAT_INPUT_COMMAND: MessageType                           = MessageType(20)
      val THREAD_STARTER_MESSAGE: MessageType                       = MessageType(21)
      val GUILD_INVITE_REMINDER: MessageType                        = MessageType(22)
      val CONTEXT_MENU_COMMAND: MessageType                         = MessageType(23)
      val AUTO_MODERATION_ACTION: MessageType                       = MessageType(24)
      val ROLE_SUBSCRIPTION_PURCHASE: MessageType                   = MessageType(25)
      val INTERACTION_PREMIUM_UPSELL: MessageType                   = MessageType(26)
      val STAGE_START: MessageType                                  = MessageType(27)
      val STAGE_END: MessageType                                    = MessageType(28)
      val STAGE_SPEAKER: MessageType                                = MessageType(29)
      val STAGE_TOPIC: MessageType                                  = MessageType(31)
      val GUILD_APPLICATION_PREMIUM_SUBSCRIPTION: MessageType       = MessageType(32)

      def unknown(value: Int): MessageType = new MessageType(value)

      def values: Seq[MessageType] = Seq(
        DEFAULT,
        RECIPIENT_ADD,
        RECIPIENT_REMOVE,
        CALL,
        CHANNEL_NAME_CHANGE,
        CHANNEL_ICON_CHANGE,
        CHANNEL_PINNED_MESSAGE,
        USER_JOIN,
        GUILD_BOOST,
        GUILD_BOOST_TIER_1,
        GUILD_BOOST_TIER_2,
        GUILD_BOOST_TIER_3,
        CHANNEL_FOLLOW_ADD,
        GUILD_DISCOVERY_DISQUALIFIED,
        GUILD_DISCOVERY_REQUALIFIED,
        GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING,
        GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING,
        THREAD_CREATED,
        REPLY,
        CHAT_INPUT_COMMAND,
        THREAD_STARTER_MESSAGE,
        GUILD_INVITE_REMINDER,
        CONTEXT_MENU_COMMAND,
        AUTO_MODERATION_ACTION,
        ROLE_SUBSCRIPTION_PURCHASE,
        INTERACTION_PREMIUM_UPSELL,
        STAGE_START,
        STAGE_END,
        STAGE_SPEAKER,
        STAGE_TOPIC,
        GUILD_APPLICATION_PREMIUM_SUBSCRIPTION
      )

      implicit class MessageTypeBitFieldOps(private val here: MessageType) extends AnyVal {
        def toInt: Int = here.value

        def ++(there: MessageType): MessageType = MessageType(here.value | there.value)

        def --(there: MessageType): MessageType = MessageType(here.value & ~there.value)

        def isNone: Boolean = here.value == 0
      }
    }

    class MessageInteractionStub(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object MessageInteractionStub extends DiscordObjectCompanion[MessageInteractionStub] {
      def makeRaw(json: Json, cache: Map[String, Any]): MessageInteractionStub = new MessageInteractionStub(json, cache)

      def make20(): MessageInteractionStub = makeRawFromFields()

    }

    class MessageApplicationStub(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object MessageApplicationStub extends DiscordObjectCompanion[MessageApplicationStub] {
      def makeRaw(json: Json, cache: Map[String, Any]): MessageApplicationStub = new MessageApplicationStub(json, cache)

      def make20(): MessageApplicationStub = makeRawFromFields()

    }

    class ChannelMention(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Id of the channel */
      @inline def id: TextGuildChannelId = selectDynamic[TextGuildChannelId]("id")

      /** Id of the guild containing the channel */
      @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

      /** The type of channel */
      @inline def tpe: Channel.ChannelType = selectDynamic[Channel.ChannelType]("type")

      /** The name of the channel */
      @inline def name: String = selectDynamic[String]("name")

      override def values: Seq[() => Any] = Seq(() => id, () => guildId, () => tpe, () => name)
    }
    object ChannelMention extends DiscordObjectCompanion[ChannelMention] {
      def makeRaw(json: Json, cache: Map[String, Any]): ChannelMention = new ChannelMention(json, cache)

      /**
        * @param id
        *   Id of the channel
        * @param guildId
        *   Id of the guild containing the channel
        * @param tpe
        *   The type of channel
        * @param name
        *   The name of the channel
        */
      def make20(id: TextGuildChannelId, guildId: GuildId, tpe: Channel.ChannelType, name: String): ChannelMention =
        makeRawFromFields("id" := id, "guild_id" := guildId, "type" := tpe, "name" := name)

    }

    class MessageActivity(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Type of message activity */
      @inline def tpe: MessageActivity.MessageActivityType = selectDynamic[MessageActivity.MessageActivityType]("type")

      /** party_id from a Rich Presence event */
      @inline def partyId: UndefOr[String] = selectDynamic[UndefOr[String]]("party_id")

      override def values: Seq[() => Any] = Seq(() => tpe, () => partyId)
    }
    object MessageActivity extends DiscordObjectCompanion[MessageActivity] {
      def makeRaw(json: Json, cache: Map[String, Any]): MessageActivity = new MessageActivity(json, cache)

      /**
        * @param tpe
        *   Type of message activity
        * @param partyId
        *   party_id from a Rich Presence event
        */
      def make20(
          tpe: MessageActivity.MessageActivityType,
          partyId: UndefOr[String] = UndefOrUndefined
      ): MessageActivity = makeRawFromFields("type" := tpe, "party_id" :=? partyId)

      sealed case class MessageActivityType private (value: Int) extends DiscordEnum[Int]
      object MessageActivityType extends DiscordEnumCompanion[Int, MessageActivityType] {

        val JOIN: MessageActivityType         = MessageActivityType(1)
        val SPECTATE: MessageActivityType     = MessageActivityType(2)
        val LISTEN: MessageActivityType       = MessageActivityType(3)
        val JOIN_REQUEST: MessageActivityType = MessageActivityType(5)

        def unknown(value: Int): MessageActivityType = new MessageActivityType(value)

        def values: Seq[MessageActivityType] = Seq(JOIN, SPECTATE, LISTEN, JOIN_REQUEST)

      }
    }

    sealed case class MessageFlags private (value: Int) extends DiscordEnum[Int]
    object MessageFlags                                 extends DiscordEnumCompanion[Int, MessageFlags] {

      /**
        * This message has been published to subscribed channels (via Channel
        * Following)
        */
      val CROSSPOSTED: MessageFlags = MessageFlags(1 << 0)

      /**
        * This message originated from a message in another channel (via Channel
        * Following)
        */
      val IS_CROSSPOST: MessageFlags = MessageFlags(1 << 1)

      /** Do not include any embeds when serializing this message */
      val SUPPRESS_EMBEDS: MessageFlags = MessageFlags(1 << 2)

      /**
        * The source message for this crosspost has been deleted (via Channel
        * Following)
        */
      val SOURCE_MESSAGE_DELETED: MessageFlags = MessageFlags(1 << 3)

      /** This message came from the urgent message system */
      val URGENT: MessageFlags = MessageFlags(1 << 4)

      /**
        * This message has an associated thread, with the same id as the message
        */
      val HAS_THREAD: MessageFlags = MessageFlags(1 << 5)

      /**
        * This message is only visible to the user who invoked the Interaction
        */
      val EPHEMERAL: MessageFlags = MessageFlags(1 << 6)

      /** This message is an Interaction Response and the bot is "thinking" */
      val LOADING: MessageFlags = MessageFlags(1 << 7)

      /**
        * This message failed to mention some roles and add their members to the
        * thread
        */
      val FAILED_TO_MENTION_SOME_ROLES_IN_THREAD: MessageFlags = MessageFlags(1 << 8)

      /** This message will not trigger push and desktop notifications */
      val SUPPRESS_NOTIFICATIONS: MessageFlags = MessageFlags(1 << 12)

      /** This message is a voice message */
      val IS_VOICE_MESSAGE: MessageFlags = MessageFlags(1 << 13)

      def unknown(value: Int): MessageFlags = new MessageFlags(value)

      def values: Seq[MessageFlags] = Seq(
        CROSSPOSTED,
        IS_CROSSPOST,
        SUPPRESS_EMBEDS,
        SOURCE_MESSAGE_DELETED,
        URGENT,
        HAS_THREAD,
        EPHEMERAL,
        LOADING,
        FAILED_TO_MENTION_SOME_ROLES_IN_THREAD,
        SUPPRESS_NOTIFICATIONS,
        IS_VOICE_MESSAGE
      )

      implicit class MessageFlagsBitFieldOps(private val here: MessageFlags) extends AnyVal {
        def toInt: Int = here.value

        def ++(there: MessageFlags): MessageFlags = MessageFlags(here.value | there.value)

        def --(there: MessageFlags): MessageFlags = MessageFlags(here.value & ~there.value)

        def isNone: Boolean = here.value == 0
      }
    }

    class RoleSubscriptionData(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** The id of the sku and listing that the user is subscribed to */
      @inline def roleSubscriptionListingId: RawSnowflake = selectDynamic[RawSnowflake]("role_subscription_listing_id")

      /** The name of the tier that the user is subscribed to */
      @inline def tierName: String = selectDynamic[String]("tier_name")

      /**
        * The cumulative number of months that the user has been subscribed for
        */
      @inline def totalMonthsSubscribed: Int = selectDynamic[Int]("total_months_subscribed")

      /**
        * Whether this notification is for a renewal rather than a new purchase
        */
      @inline def isRenewal: Boolean = selectDynamic[Boolean]("is_renewal")

      override def values: Seq[() => Any] =
        Seq(() => roleSubscriptionListingId, () => tierName, () => totalMonthsSubscribed, () => isRenewal)
    }
    object RoleSubscriptionData extends DiscordObjectCompanion[RoleSubscriptionData] {
      def makeRaw(json: Json, cache: Map[String, Any]): RoleSubscriptionData = new RoleSubscriptionData(json, cache)

      /**
        * @param roleSubscriptionListingId
        *   The id of the sku and listing that the user is subscribed to
        * @param tierName
        *   The name of the tier that the user is subscribed to
        * @param totalMonthsSubscribed
        *   The cumulative number of months that the user has been subscribed
        *   for
        * @param isRenewal
        *   Whether this notification is for a renewal rather than a new
        *   purchase
        */
      def make20(
          roleSubscriptionListingId: RawSnowflake,
          tierName: String,
          totalMonthsSubscribed: Int,
          isRenewal: Boolean
      ): RoleSubscriptionData = makeRawFromFields(
        "role_subscription_listing_id" := roleSubscriptionListingId,
        "tier_name"                    := tierName,
        "total_months_subscribed"      := totalMonthsSubscribed,
        "is_renewal"                   := isRenewal
      )

    }
  }

  sealed case class MessageType private (value: Int) extends DiscordEnum[Int]
  object MessageType extends DiscordEnumCompanion[Int, MessageType] {

    val DEFAULT: MessageType                                      = MessageType(0)
    val RECIPIENT_ADD: MessageType                                = MessageType(1)
    val RECIPIENT_REMOVE: MessageType                             = MessageType(2)
    val CALL: MessageType                                         = MessageType(3)
    val CHANNEL_NAME_CHANGE: MessageType                          = MessageType(4)
    val CHANNEL_ICON_CHANGE: MessageType                          = MessageType(5)
    val CHANNEL_PINNED_MESSAGE: MessageType                       = MessageType(6)
    val USER_JOIN: MessageType                                    = MessageType(7)
    val GUILD_BOOST: MessageType                                  = MessageType(8)
    val GUILD_BOOST_TIER_1: MessageType                           = MessageType(9)
    val GUILD_BOOST_TIER_2: MessageType                           = MessageType(10)
    val GUILD_BOOST_TIER_3: MessageType                           = MessageType(11)
    val CHANNEL_FOLLOW_ADD: MessageType                           = MessageType(12)
    val GUILD_DISCOVERY_DISQUALIFIED: MessageType                 = MessageType(14)
    val GUILD_DISCOVERY_REQUALIFIED: MessageType                  = MessageType(15)
    val GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING: MessageType = MessageType(16)
    val GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING: MessageType   = MessageType(17)
    val THREAD_CREATED: MessageType                               = MessageType(18)
    val REPLY: MessageType                                        = MessageType(19)
    val CHAT_INPUT_COMMAND: MessageType                           = MessageType(20)
    val THREAD_STARTER_MESSAGE: MessageType                       = MessageType(21)
    val GUILD_INVITE_REMINDER: MessageType                        = MessageType(22)
    val CONTEXT_MENU_COMMAND: MessageType                         = MessageType(23)
    val AUTO_MODERATION_ACTION: MessageType                       = MessageType(24)
    val ROLE_SUBSCRIPTION_PURCHASE: MessageType                   = MessageType(25)
    val INTERACTION_PREMIUM_UPSELL: MessageType                   = MessageType(26)
    val STAGE_START: MessageType                                  = MessageType(27)
    val STAGE_END: MessageType                                    = MessageType(28)
    val STAGE_SPEAKER: MessageType                                = MessageType(29)
    val STAGE_TOPIC: MessageType                                  = MessageType(31)
    val GUILD_APPLICATION_PREMIUM_SUBSCRIPTION: MessageType       = MessageType(32)

    def unknown(value: Int): MessageType = new MessageType(value)

    def values: Seq[MessageType] = Seq(
      DEFAULT,
      RECIPIENT_ADD,
      RECIPIENT_REMOVE,
      CALL,
      CHANNEL_NAME_CHANGE,
      CHANNEL_ICON_CHANGE,
      CHANNEL_PINNED_MESSAGE,
      USER_JOIN,
      GUILD_BOOST,
      GUILD_BOOST_TIER_1,
      GUILD_BOOST_TIER_2,
      GUILD_BOOST_TIER_3,
      CHANNEL_FOLLOW_ADD,
      GUILD_DISCOVERY_DISQUALIFIED,
      GUILD_DISCOVERY_REQUALIFIED,
      GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING,
      GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING,
      THREAD_CREATED,
      REPLY,
      CHAT_INPUT_COMMAND,
      THREAD_STARTER_MESSAGE,
      GUILD_INVITE_REMINDER,
      CONTEXT_MENU_COMMAND,
      AUTO_MODERATION_ACTION,
      ROLE_SUBSCRIPTION_PURCHASE,
      INTERACTION_PREMIUM_UPSELL,
      STAGE_START,
      STAGE_END,
      STAGE_SPEAKER,
      STAGE_TOPIC,
      GUILD_APPLICATION_PREMIUM_SUBSCRIPTION
    )

    implicit class MessageTypeBitFieldOps(private val here: MessageType) extends AnyVal {
      def toInt: Int = here.value

      def ++(there: MessageType): MessageType = MessageType(here.value | there.value)

      def --(there: MessageType): MessageType = MessageType(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }

  class MessageInteractionStub(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    override def values: Seq[() => Any] = Seq()
  }
  object MessageInteractionStub extends DiscordObjectCompanion[MessageInteractionStub] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageInteractionStub = new MessageInteractionStub(json, cache)

    def make20(): MessageInteractionStub = makeRawFromFields()

  }

  class MessageApplicationStub(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    override def values: Seq[() => Any] = Seq()
  }
  object MessageApplicationStub extends DiscordObjectCompanion[MessageApplicationStub] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageApplicationStub = new MessageApplicationStub(json, cache)

    def make20(): MessageApplicationStub = makeRawFromFields()

  }

  class ChannelMention(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Id of the channel */
    @inline def id: TextGuildChannelId = selectDynamic[TextGuildChannelId]("id")

    /** Id of the guild containing the channel */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** The type of channel */
    @inline def tpe: Channel.ChannelType = selectDynamic[Channel.ChannelType]("type")

    /** The name of the channel */
    @inline def name: String = selectDynamic[String]("name")

    override def values: Seq[() => Any] = Seq(() => id, () => guildId, () => tpe, () => name)
  }
  object ChannelMention extends DiscordObjectCompanion[ChannelMention] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelMention = new ChannelMention(json, cache)

    /**
      * @param id
      *   Id of the channel
      * @param guildId
      *   Id of the guild containing the channel
      * @param tpe
      *   The type of channel
      * @param name
      *   The name of the channel
      */
    def make20(id: TextGuildChannelId, guildId: GuildId, tpe: Channel.ChannelType, name: String): ChannelMention =
      makeRawFromFields("id" := id, "guild_id" := guildId, "type" := tpe, "name" := name)

  }

  class MessageActivity(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Type of message activity */
    @inline def tpe: MessageActivity.MessageActivityType = selectDynamic[MessageActivity.MessageActivityType]("type")

    /** party_id from a Rich Presence event */
    @inline def partyId: UndefOr[String] = selectDynamic[UndefOr[String]]("party_id")

    override def values: Seq[() => Any] = Seq(() => tpe, () => partyId)
  }
  object MessageActivity extends DiscordObjectCompanion[MessageActivity] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageActivity = new MessageActivity(json, cache)

    /**
      * @param tpe
      *   Type of message activity
      * @param partyId
      *   party_id from a Rich Presence event
      */
    def make20(tpe: MessageActivity.MessageActivityType, partyId: UndefOr[String] = UndefOrUndefined): MessageActivity =
      makeRawFromFields("type" := tpe, "party_id" :=? partyId)

    sealed case class MessageActivityType private (value: Int) extends DiscordEnum[Int]
    object MessageActivityType extends DiscordEnumCompanion[Int, MessageActivityType] {

      val JOIN: MessageActivityType         = MessageActivityType(1)
      val SPECTATE: MessageActivityType     = MessageActivityType(2)
      val LISTEN: MessageActivityType       = MessageActivityType(3)
      val JOIN_REQUEST: MessageActivityType = MessageActivityType(5)

      def unknown(value: Int): MessageActivityType = new MessageActivityType(value)

      def values: Seq[MessageActivityType] = Seq(JOIN, SPECTATE, LISTEN, JOIN_REQUEST)

    }
  }

  sealed case class MessageFlags private (value: Int) extends DiscordEnum[Int]
  object MessageFlags                                 extends DiscordEnumCompanion[Int, MessageFlags] {

    /**
      * This message has been published to subscribed channels (via Channel
      * Following)
      */
    val CROSSPOSTED: MessageFlags = MessageFlags(1 << 0)

    /**
      * This message originated from a message in another channel (via Channel
      * Following)
      */
    val IS_CROSSPOST: MessageFlags = MessageFlags(1 << 1)

    /** Do not include any embeds when serializing this message */
    val SUPPRESS_EMBEDS: MessageFlags = MessageFlags(1 << 2)

    /**
      * The source message for this crosspost has been deleted (via Channel
      * Following)
      */
    val SOURCE_MESSAGE_DELETED: MessageFlags = MessageFlags(1 << 3)

    /** This message came from the urgent message system */
    val URGENT: MessageFlags = MessageFlags(1 << 4)

    /**
      * This message has an associated thread, with the same id as the message
      */
    val HAS_THREAD: MessageFlags = MessageFlags(1 << 5)

    /** This message is only visible to the user who invoked the Interaction */
    val EPHEMERAL: MessageFlags = MessageFlags(1 << 6)

    /** This message is an Interaction Response and the bot is "thinking" */
    val LOADING: MessageFlags = MessageFlags(1 << 7)

    /**
      * This message failed to mention some roles and add their members to the
      * thread
      */
    val FAILED_TO_MENTION_SOME_ROLES_IN_THREAD: MessageFlags = MessageFlags(1 << 8)

    /** This message will not trigger push and desktop notifications */
    val SUPPRESS_NOTIFICATIONS: MessageFlags = MessageFlags(1 << 12)

    /** This message is a voice message */
    val IS_VOICE_MESSAGE: MessageFlags = MessageFlags(1 << 13)

    def unknown(value: Int): MessageFlags = new MessageFlags(value)

    def values: Seq[MessageFlags] = Seq(
      CROSSPOSTED,
      IS_CROSSPOST,
      SUPPRESS_EMBEDS,
      SOURCE_MESSAGE_DELETED,
      URGENT,
      HAS_THREAD,
      EPHEMERAL,
      LOADING,
      FAILED_TO_MENTION_SOME_ROLES_IN_THREAD,
      SUPPRESS_NOTIFICATIONS,
      IS_VOICE_MESSAGE
    )

    implicit class MessageFlagsBitFieldOps(private val here: MessageFlags) extends AnyVal {
      def toInt: Int = here.value

      def ++(there: MessageFlags): MessageFlags = MessageFlags(here.value | there.value)

      def --(there: MessageFlags): MessageFlags = MessageFlags(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }

  class RoleSubscriptionData(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of the sku and listing that the user is subscribed to */
    @inline def roleSubscriptionListingId: RawSnowflake = selectDynamic[RawSnowflake]("role_subscription_listing_id")

    /** The name of the tier that the user is subscribed to */
    @inline def tierName: String = selectDynamic[String]("tier_name")

    /** The cumulative number of months that the user has been subscribed for */
    @inline def totalMonthsSubscribed: Int = selectDynamic[Int]("total_months_subscribed")

    /** Whether this notification is for a renewal rather than a new purchase */
    @inline def isRenewal: Boolean = selectDynamic[Boolean]("is_renewal")

    override def values: Seq[() => Any] =
      Seq(() => roleSubscriptionListingId, () => tierName, () => totalMonthsSubscribed, () => isRenewal)
  }
  object RoleSubscriptionData extends DiscordObjectCompanion[RoleSubscriptionData] {
    def makeRaw(json: Json, cache: Map[String, Any]): RoleSubscriptionData = new RoleSubscriptionData(json, cache)

    /**
      * @param roleSubscriptionListingId
      *   The id of the sku and listing that the user is subscribed to
      * @param tierName
      *   The name of the tier that the user is subscribed to
      * @param totalMonthsSubscribed
      *   The cumulative number of months that the user has been subscribed for
      * @param isRenewal
      *   Whether this notification is for a renewal rather than a new purchase
      */
    def make20(
        roleSubscriptionListingId: RawSnowflake,
        tierName: String,
        totalMonthsSubscribed: Int,
        isRenewal: Boolean
    ): RoleSubscriptionData = makeRawFromFields(
      "role_subscription_listing_id" := roleSubscriptionListingId,
      "tier_name"                    := tierName,
      "total_months_subscribed"      := totalMonthsSubscribed,
      "is_renewal"                   := isRenewal
    )

  }
}

class MessageReference(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Id of the originating message */
  @inline def messageId: UndefOr[MessageId] = selectDynamic[UndefOr[MessageId]]("message_id")

  /** Id of the originating message's channel */
  @inline def channelId: UndefOr[TextChannelId] = selectDynamic[UndefOr[TextChannelId]]("channel_id")

  /** Id of the originating message's guild */
  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  /**
    * When sending, whether to error if the referenced message doesn't exist
    * instead of sending as a normal (non-reply) message, default true
    */
  @inline def failIfNotExists: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("fail_if_not_exists")

  override def values: Seq[() => Any] = Seq(() => messageId, () => channelId, () => guildId, () => failIfNotExists)
}
object MessageReference extends DiscordObjectCompanion[MessageReference] {
  def makeRaw(json: Json, cache: Map[String, Any]): MessageReference = new MessageReference(json, cache)

  /**
    * @param messageId
    *   Id of the originating message
    * @param channelId
    *   Id of the originating message's channel
    * @param guildId
    *   Id of the originating message's guild
    * @param failIfNotExists
    *   When sending, whether to error if the referenced message doesn't exist
    *   instead of sending as a normal (non-reply) message, default true
    */
  def make20(
      messageId: UndefOr[MessageId] = UndefOrUndefined,
      channelId: UndefOr[TextChannelId] = UndefOrUndefined,
      guildId: UndefOr[GuildId] = UndefOrUndefined,
      failIfNotExists: UndefOr[Boolean] = UndefOrUndefined
  ): MessageReference = makeRawFromFields(
    "message_id"         :=? messageId,
    "channel_id"         :=? channelId,
    "guild_id"           :=? guildId,
    "fail_if_not_exists" :=? failIfNotExists
  )

}

class FollowedChannel(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Source channel id */
  @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

  /** Created target webhook id */
  @inline def webhookId: WebhookId = selectDynamic[WebhookId]("webhook_id")

  override def values: Seq[() => Any] = Seq(() => channelId, () => webhookId)
}
object FollowedChannel extends DiscordObjectCompanion[FollowedChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): FollowedChannel = new FollowedChannel(json, cache)

  /**
    * @param channelId
    *   Source channel id
    * @param webhookId
    *   Created target webhook id
    */
  def make20(channelId: TextChannelId, webhookId: WebhookId): FollowedChannel =
    makeRawFromFields("channel_id" := channelId, "webhook_id" := webhookId)

}

class Reaction(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Times this emoji has been used to react */
  @inline def count: Int = selectDynamic[Int]("count")

  /** Whether the current user reacted using this emoji */
  @inline def me: Boolean = selectDynamic[Boolean]("me")

  /** Emoji information */
  @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

  override def values: Seq[() => Any] = Seq(() => count, () => me, () => emoji)
}
object Reaction extends DiscordObjectCompanion[Reaction] {
  def makeRaw(json: Json, cache: Map[String, Any]): Reaction = new Reaction(json, cache)

  /**
    * @param count
    *   Times this emoji has been used to react
    * @param me
    *   Whether the current user reacted using this emoji
    * @param emoji
    *   Emoji information
    */
  def make20(count: Int, me: Boolean, emoji: Emoji): Reaction =
    makeRawFromFields("count" := count, "me" := me, "emoji" := emoji)

}

class Embed(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Title of embed */
  @inline def title: UndefOr[String] = selectDynamic[UndefOr[String]]("title")

  /** Type of embed (always "rich" for webhook embeds) */
  @inline def tpe: UndefOr[Embed.EmbedType] = selectDynamic[UndefOr[Embed.EmbedType]]("type")

  /** Description of embed */
  @inline def description: UndefOr[String] = selectDynamic[UndefOr[String]]("description")

  /** Url of embed */
  @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

  /** Timestamp of embed content */
  @inline def timestamp: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("timestamp")

  /** Color code of the embed */
  @inline def color: UndefOr[Int] = selectDynamic[UndefOr[Int]]("color")

  /** Footer information */
  @inline def footer: UndefOr[Embed.EmbedFooter] = selectDynamic[UndefOr[Embed.EmbedFooter]]("footer")

  /** Image information */
  @inline def image: UndefOr[Embed.EmbedImage] = selectDynamic[UndefOr[Embed.EmbedImage]]("image")

  /** Thumbnail information */
  @inline def thumbnail: UndefOr[Embed.EmbedThumbnail] = selectDynamic[UndefOr[Embed.EmbedThumbnail]]("thumbnail")

  /** Video information */
  @inline def video: UndefOr[Embed.EmbedVideo] = selectDynamic[UndefOr[Embed.EmbedVideo]]("video")

  /** Provider information */
  @inline def provider: UndefOr[Embed.EmbedProvider] = selectDynamic[UndefOr[Embed.EmbedProvider]]("provider")

  /** Author information */
  @inline def author: UndefOr[Embed.EmbedAuthor] = selectDynamic[UndefOr[Embed.EmbedAuthor]]("author")

  /** Fields information */
  @inline def fields: UndefOr[Seq[Embed.EmbedField]] = selectDynamic[UndefOr[Seq[Embed.EmbedField]]]("fields")

  override def values: Seq[() => Any] = Seq(
    () => title,
    () => tpe,
    () => description,
    () => url,
    () => timestamp,
    () => color,
    () => footer,
    () => image,
    () => thumbnail,
    () => video,
    () => provider,
    () => author,
    () => fields
  )
}
object Embed extends DiscordObjectCompanion[Embed] {
  def makeRaw(json: Json, cache: Map[String, Any]): Embed = new Embed(json, cache)

  /**
    * @param title
    *   Title of embed
    * @param tpe
    *   Type of embed (always "rich" for webhook embeds)
    * @param description
    *   Description of embed
    * @param url
    *   Url of embed
    * @param timestamp
    *   Timestamp of embed content
    * @param color
    *   Color code of the embed
    * @param footer
    *   Footer information
    * @param image
    *   Image information
    * @param thumbnail
    *   Thumbnail information
    * @param video
    *   Video information
    * @param provider
    *   Provider information
    * @param author
    *   Author information
    * @param fields
    *   Fields information
    */
  def make20(
      title: UndefOr[String] = UndefOrUndefined,
      tpe: UndefOr[Embed.EmbedType] = UndefOrUndefined,
      description: UndefOr[String] = UndefOrUndefined,
      url: UndefOr[String] = UndefOrUndefined,
      timestamp: UndefOr[OffsetDateTime] = UndefOrUndefined,
      color: UndefOr[Int] = UndefOrUndefined,
      footer: UndefOr[Embed.EmbedFooter] = UndefOrUndefined,
      image: UndefOr[Embed.EmbedImage] = UndefOrUndefined,
      thumbnail: UndefOr[Embed.EmbedThumbnail] = UndefOrUndefined,
      video: UndefOr[Embed.EmbedVideo] = UndefOrUndefined,
      provider: UndefOr[Embed.EmbedProvider] = UndefOrUndefined,
      author: UndefOr[Embed.EmbedAuthor] = UndefOrUndefined,
      fields: UndefOr[Seq[Embed.EmbedField]] = UndefOrUndefined
  ): Embed = makeRawFromFields(
    "title"       :=? title,
    "type"        :=? tpe,
    "description" :=? description,
    "url"         :=? url,
    "timestamp"   :=? timestamp,
    "color"       :=? color,
    "footer"      :=? footer,
    "image"       :=? image,
    "thumbnail"   :=? thumbnail,
    "video"       :=? video,
    "provider"    :=? provider,
    "author"      :=? author,
    "fields"      :=? fields
  )

  sealed case class EmbedType private (value: String) extends DiscordEnum[String]
  object EmbedType                                    extends DiscordEnumCompanion[String, EmbedType] {

    /** Generic embed rendered from embed attributes */
    val Rich: EmbedType = EmbedType("rich")

    /** Image embed */
    val Image: EmbedType = EmbedType("image")

    /** Video embed */
    val Video: EmbedType = EmbedType("video")

    /** Animated gif image embed rendered as a video embed */
    val Gifv: EmbedType = EmbedType("gifv")

    /** Article embed */
    val Article: EmbedType = EmbedType("article")

    /** Link embed */
    val Link: EmbedType = EmbedType("link")

    def unknown(value: String): EmbedType = new EmbedType(value)

    def values: Seq[EmbedType] = Seq(Rich, Image, Video, Gifv, Article, Link)

  }

  class EmbedThumbnail(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Source url of thumbnail (only supports http(s) and attachments) */
    @inline def url: String = selectDynamic[String]("url")

    /** A proxied url of the thumbnail */
    @inline def proxyUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_url")

    /** Height of thumbnail */
    @inline def height: UndefOr[Int] = selectDynamic[UndefOr[Int]]("height")

    /** Width of thumbnail */
    @inline def width: UndefOr[Int] = selectDynamic[UndefOr[Int]]("width")

    override def values: Seq[() => Any] = Seq(() => url, () => proxyUrl, () => height, () => width)
  }
  object EmbedThumbnail extends DiscordObjectCompanion[EmbedThumbnail] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedThumbnail = new EmbedThumbnail(json, cache)

    /**
      * @param url
      *   Source url of thumbnail (only supports http(s) and attachments)
      * @param proxyUrl
      *   A proxied url of the thumbnail
      * @param height
      *   Height of thumbnail
      * @param width
      *   Width of thumbnail
      */
    def make20(
        url: String,
        proxyUrl: UndefOr[String] = UndefOrUndefined,
        height: UndefOr[Int] = UndefOrUndefined,
        width: UndefOr[Int] = UndefOrUndefined
    ): EmbedThumbnail =
      makeRawFromFields("url" := url, "proxy_url" :=? proxyUrl, "height" :=? height, "width" :=? width)

  }

  class EmbedVideo(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Source url of video */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    /** A proxied url of the video */
    @inline def proxyUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_url")

    /** Height of video */
    @inline def height: UndefOr[Int] = selectDynamic[UndefOr[Int]]("height")

    /** Width of video */
    @inline def width: UndefOr[Int] = selectDynamic[UndefOr[Int]]("width")

    override def values: Seq[() => Any] = Seq(() => url, () => proxyUrl, () => height, () => width)
  }
  object EmbedVideo extends DiscordObjectCompanion[EmbedVideo] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedVideo = new EmbedVideo(json, cache)

    /**
      * @param url
      *   Source url of video
      * @param proxyUrl
      *   A proxied url of the video
      * @param height
      *   Height of video
      * @param width
      *   Width of video
      */
    def make20(
        url: UndefOr[String] = UndefOrUndefined,
        proxyUrl: UndefOr[String] = UndefOrUndefined,
        height: UndefOr[Int] = UndefOrUndefined,
        width: UndefOr[Int] = UndefOrUndefined
    ): EmbedVideo = makeRawFromFields("url" :=? url, "proxy_url" :=? proxyUrl, "height" :=? height, "width" :=? width)

  }

  class EmbedImage(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Source url of image (only supports http(s) and attachments) */
    @inline def url: String = selectDynamic[String]("url")

    /** A proxied url of the image */
    @inline def proxyUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_url")

    /** Height of image */
    @inline def height: UndefOr[Int] = selectDynamic[UndefOr[Int]]("height")

    /** Width of image */
    @inline def width: UndefOr[Int] = selectDynamic[UndefOr[Int]]("width")

    override def values: Seq[() => Any] = Seq(() => url, () => proxyUrl, () => height, () => width)
  }
  object EmbedImage extends DiscordObjectCompanion[EmbedImage] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedImage = new EmbedImage(json, cache)

    /**
      * @param url
      *   Source url of image (only supports http(s) and attachments)
      * @param proxyUrl
      *   A proxied url of the image
      * @param height
      *   Height of image
      * @param width
      *   Width of image
      */
    def make20(
        url: String,
        proxyUrl: UndefOr[String] = UndefOrUndefined,
        height: UndefOr[Int] = UndefOrUndefined,
        width: UndefOr[Int] = UndefOrUndefined
    ): EmbedImage = makeRawFromFields("url" := url, "proxy_url" :=? proxyUrl, "height" :=? height, "width" :=? width)

  }

  class EmbedProvider(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Name of provider */
    @inline def name: UndefOr[String] = selectDynamic[UndefOr[String]]("name")

    /** Url of provider */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    override def values: Seq[() => Any] = Seq(() => name, () => url)
  }
  object EmbedProvider extends DiscordObjectCompanion[EmbedProvider] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedProvider = new EmbedProvider(json, cache)

    /**
      * @param name
      *   Name of provider
      * @param url
      *   Url of provider
      */
    def make20(name: UndefOr[String] = UndefOrUndefined, url: UndefOr[String] = UndefOrUndefined): EmbedProvider =
      makeRawFromFields("name" :=? name, "url" :=? url)

  }

  class EmbedAuthor(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Name of author */
    @inline def name: String = selectDynamic[String]("name")

    /** Url of author (only supports http(s)) */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    /** Url of author icon (only supports http(s) and attachments) */
    @inline def iconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("icon_url")

    /** A proxied url of author icon */
    @inline def proxyIconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_icon_url")

    override def values: Seq[() => Any] = Seq(() => name, () => url, () => iconUrl, () => proxyIconUrl)
  }
  object EmbedAuthor extends DiscordObjectCompanion[EmbedAuthor] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedAuthor = new EmbedAuthor(json, cache)

    /**
      * @param name
      *   Name of author
      * @param url
      *   Url of author (only supports http(s))
      * @param iconUrl
      *   Url of author icon (only supports http(s) and attachments)
      * @param proxyIconUrl
      *   A proxied url of author icon
      */
    def make20(
        name: String,
        url: UndefOr[String] = UndefOrUndefined,
        iconUrl: UndefOr[String] = UndefOrUndefined,
        proxyIconUrl: UndefOr[String] = UndefOrUndefined
    ): EmbedAuthor =
      makeRawFromFields("name" := name, "url" :=? url, "icon_url" :=? iconUrl, "proxy_icon_url" :=? proxyIconUrl)

  }

  class EmbedFooter(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Footer text */
    @inline def text: String = selectDynamic[String]("text")

    /** Url of footer icon (only supports http(s) and attachments) */
    @inline def iconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("icon_url")

    /** A proxied url of footer icon */
    @inline def proxyIconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_icon_url")

    override def values: Seq[() => Any] = Seq(() => text, () => iconUrl, () => proxyIconUrl)
  }
  object EmbedFooter extends DiscordObjectCompanion[EmbedFooter] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedFooter = new EmbedFooter(json, cache)

    /**
      * @param text
      *   Footer text
      * @param iconUrl
      *   Url of footer icon (only supports http(s) and attachments)
      * @param proxyIconUrl
      *   A proxied url of footer icon
      */
    def make20(
        text: String,
        iconUrl: UndefOr[String] = UndefOrUndefined,
        proxyIconUrl: UndefOr[String] = UndefOrUndefined
    ): EmbedFooter = makeRawFromFields("text" := text, "icon_url" :=? iconUrl, "proxy_icon_url" :=? proxyIconUrl)

  }

  class EmbedField(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Name of the field */
    @inline def name: String = selectDynamic[String]("name")

    /** Value of the field */
    @inline def value: String = selectDynamic[String]("value")

    /** Whether or not this field should display inline */
    @inline def inline: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("inline")

    override def values: Seq[() => Any] = Seq(() => name, () => value, () => inline)
  }
  object EmbedField extends DiscordObjectCompanion[EmbedField] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedField = new EmbedField(json, cache)

    /**
      * @param name
      *   Name of the field
      * @param value
      *   Value of the field
      * @param inline
      *   Whether or not this field should display inline
      */
    def make20(name: String, value: String, inline: UndefOr[Boolean] = UndefOrUndefined): EmbedField =
      makeRawFromFields("name" := name, "value" := value, "inline" :=? inline)

  }
}

class Attachment(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Attachment id */
  @inline def id: Snowflake[Attachment] = selectDynamic[Snowflake[Attachment]]("id")

  /** Name of file attached */
  @inline def filename: String = selectDynamic[String]("filename")

  /** Description for the file (max 1024 characters) */
  @inline def description: UndefOr[String] = selectDynamic[UndefOr[String]]("description")

  /** The attachment's media type */
  @inline def contentType: UndefOr[String] = selectDynamic[UndefOr[String]]("content_type")

  /** Size of file in bytes */
  @inline def size: Int = selectDynamic[Int]("size")

  /** Source url of file */
  @inline def url: String = selectDynamic[String]("url")

  /** A proxied url of file */
  @inline def proxyUrl: String = selectDynamic[String]("proxy_url")

  /** Height of file (if image) */
  @inline def height: JsonOption[Int] = selectDynamic[JsonOption[Int]]("height")

  /** Width of file (if image) */
  @inline def width: JsonOption[Int] = selectDynamic[JsonOption[Int]]("width")

  /** Whether this attachment is ephemeral */
  @inline def ephemeral: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("ephemeral")

  /** The duration of the audio file (currently for voice messages) */
  @inline def durationSecs: UndefOr[Float] = selectDynamic[UndefOr[Float]]("duration_secs")

  /**
    * Base64 encoded bytearray representing a sampled waveform (currently for
    * voice messages)
    */
  @inline def waveform: UndefOr[String] = selectDynamic[UndefOr[String]]("waveform")

  /** Attachment flags combined as a bitfield */
  @inline def flags: UndefOr[Attachment.AttachmentFlags] = selectDynamic[UndefOr[Attachment.AttachmentFlags]]("flags")

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => filename,
    () => description,
    () => contentType,
    () => size,
    () => url,
    () => proxyUrl,
    () => height,
    () => width,
    () => ephemeral,
    () => durationSecs,
    () => waveform,
    () => flags
  )
}
object Attachment extends DiscordObjectCompanion[Attachment] {
  def makeRaw(json: Json, cache: Map[String, Any]): Attachment = new Attachment(json, cache)

  /**
    * @param id
    *   Attachment id
    * @param filename
    *   Name of file attached
    * @param description
    *   Description for the file (max 1024 characters)
    * @param contentType
    *   The attachment's media type
    * @param size
    *   Size of file in bytes
    * @param url
    *   Source url of file
    * @param proxyUrl
    *   A proxied url of file
    * @param height
    *   Height of file (if image)
    * @param width
    *   Width of file (if image)
    * @param ephemeral
    *   Whether this attachment is ephemeral
    * @param durationSecs
    *   The duration of the audio file (currently for voice messages)
    * @param waveform
    *   Base64 encoded bytearray representing a sampled waveform (currently for
    *   voice messages)
    * @param flags
    *   Attachment flags combined as a bitfield
    */
  def make20(
      id: Snowflake[Attachment],
      filename: String,
      description: UndefOr[String] = UndefOrUndefined,
      contentType: UndefOr[String] = UndefOrUndefined,
      size: Int,
      url: String,
      proxyUrl: String,
      height: JsonOption[Int] = JsonUndefined,
      width: JsonOption[Int] = JsonUndefined,
      ephemeral: UndefOr[Boolean] = UndefOrUndefined,
      durationSecs: UndefOr[Float] = UndefOrUndefined,
      waveform: UndefOr[String] = UndefOrUndefined,
      flags: UndefOr[Attachment.AttachmentFlags] = UndefOrUndefined
  ): Attachment = makeRawFromFields(
    "id"             := id,
    "filename"       := filename,
    "description"   :=? description,
    "content_type"  :=? contentType,
    "size"           := size,
    "url"            := url,
    "proxy_url"      := proxyUrl,
    "height"        :=? height,
    "width"         :=? width,
    "ephemeral"     :=? ephemeral,
    "duration_secs" :=? durationSecs,
    "waveform"      :=? waveform,
    "flags"         :=? flags
  )

  sealed case class AttachmentFlags private (value: Int) extends DiscordEnum[Int]
  object AttachmentFlags                                 extends DiscordEnumCompanion[Int, AttachmentFlags] {

    /** This attachment has been edited using the remix feature on mobile */
    val IS_REMIX: AttachmentFlags = AttachmentFlags(1 << 2)

    def unknown(value: Int): AttachmentFlags = new AttachmentFlags(value)

    def values: Seq[AttachmentFlags] = Seq(IS_REMIX)

    implicit class AttachmentFlagsBitFieldOps(private val here: AttachmentFlags) extends AnyVal {
      def toInt: Int = here.value

      def ++(there: AttachmentFlags): AttachmentFlags = AttachmentFlags(here.value | there.value)

      def --(there: AttachmentFlags): AttachmentFlags = AttachmentFlags(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }
}

class AllowedMentions(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** An array of allowed mention types to parse from the content. */
  @inline def parse: UndefOr[Seq[AllowedMentions.AllowedMentionsType]] =
    selectDynamic[UndefOr[Seq[AllowedMentions.AllowedMentionsType]]]("parse")

  /** Array of role_ids to mention (Max size of 100) */
  @inline def roles: UndefOr[Seq[RoleId]] = selectDynamic[UndefOr[Seq[RoleId]]]("roles")

  /** Array of user_ids to mention (Max size of 100) */
  @inline def users: UndefOr[Seq[UserId]] = selectDynamic[UndefOr[Seq[UserId]]]("users")

  /**
    * For replies, whether to mention the author of the message being replied to
    * (default false)
    */
  @inline def repliedUser: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("replied_user")

  override def values: Seq[() => Any] = Seq(() => parse, () => roles, () => users, () => repliedUser)
}
object AllowedMentions extends DiscordObjectCompanion[AllowedMentions] {
  def makeRaw(json: Json, cache: Map[String, Any]): AllowedMentions = new AllowedMentions(json, cache)

  /**
    * @param parse
    *   An array of allowed mention types to parse from the content.
    * @param roles
    *   Array of role_ids to mention (Max size of 100)
    * @param users
    *   Array of user_ids to mention (Max size of 100)
    * @param repliedUser
    *   For replies, whether to mention the author of the message being replied
    *   to (default false)
    */
  def make20(
      parse: UndefOr[Seq[AllowedMentions.AllowedMentionsType]] = UndefOrUndefined,
      roles: UndefOr[Seq[RoleId]] = UndefOrUndefined,
      users: UndefOr[Seq[UserId]] = UndefOrUndefined,
      repliedUser: UndefOr[Boolean] = UndefOrUndefined
  ): AllowedMentions =
    makeRawFromFields("parse" :=? parse, "roles" :=? roles, "users" :=? users, "replied_user" :=? repliedUser)

  sealed case class AllowedMentionsType private (value: String) extends DiscordEnum[String]
  object AllowedMentionsType extends DiscordEnumCompanion[String, AllowedMentionsType] {

    /** Controls role mentions */
    val RoleMentions: AllowedMentionsType = AllowedMentionsType("roles")

    /** Controls user mentions */
    val UserMentions: AllowedMentionsType = AllowedMentionsType("users")

    /** Controls @everyone and @here mentions */
    val EveryoneMentions: AllowedMentionsType = AllowedMentionsType("everyone")

    def unknown(value: String): AllowedMentionsType = new AllowedMentionsType(value)

    def values: Seq[AllowedMentionsType] = Seq(RoleMentions, UserMentions, EveryoneMentions)

  }
}
