//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.data

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/data/channel.yaml

import java.time.OffsetDateTime

import ackcord.data.base._
import io.circe.Json

/** Represents a guild or DM channel within Discord. */
class RawChannel(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with Channel {

  /** The id of this channel */
  @inline def id: ChannelId = selectDynamic[ChannelId]("id")

  @inline def withId(newValue: ChannelId): RawChannel = objWith(RawChannel, "id", newValue)

  /** The type of channel */
  @inline def tpe: Channel.ChannelType = selectDynamic[Channel.ChannelType]("type")

  @inline def withTpe(newValue: Channel.ChannelType): RawChannel = objWith(RawChannel, "type", newValue)

  /**
    * The id of the guild (may be missing for some channel objects received over
    * gateway guild dispatches)
    */
  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): RawChannel = objWithUndef(RawChannel, "guild_id", newValue)

  /** Sorting position of the channel */
  @inline def position: UndefOr[Int] = selectDynamic[UndefOr[Int]]("position")

  @inline def withPosition(newValue: UndefOr[Int]): RawChannel = objWithUndef(RawChannel, "position", newValue)

  /** Explicit permission overwrites for members and roles */
  @inline def permissionOverwrites: UndefOr[Seq[Channel.PermissionOverwrite]] =
    selectDynamic[UndefOr[Seq[Channel.PermissionOverwrite]]]("permission_overwrites")

  @inline def withPermissionOverwrites(newValue: UndefOr[Seq[Channel.PermissionOverwrite]]): RawChannel =
    objWithUndef(RawChannel, "permission_overwrites", newValue)

  /** The name of the channel (1-100 characters) */
  @inline def name: JsonOption[String] = selectDynamic[JsonOption[String]]("name")

  @inline def withName(newValue: JsonOption[String]): RawChannel = objWithUndef(RawChannel, "name", newValue)

  /**
    * The channel topic (0-4096 characters for GUILD_FORUM channels, 0-1024
    * characters for all others)
    */
  @inline def topic: JsonOption[String] = selectDynamic[JsonOption[String]]("topic")

  @inline def withTopic(newValue: JsonOption[String]): RawChannel = objWithUndef(RawChannel, "topic", newValue)

  /** Whether the channel is nsfw */
  @inline def nsfw: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("nsfw")

  @inline def withNsfw(newValue: UndefOr[Boolean]): RawChannel = objWithUndef(RawChannel, "nsfw", newValue)

  /**
    * The id of the last message sent in this channel (or thread for GUILD_FORUM
    * channels) (may not point to an existing or valid message or thread)
    */
  @inline def lastMessageId: JsonOption[MessageId] = selectDynamic[JsonOption[MessageId]]("last_message_id")

  @inline def withLastMessageId(newValue: JsonOption[MessageId]): RawChannel =
    objWithUndef(RawChannel, "last_message_id", newValue)

  /** The bitrate (in bits) of the voice channel */
  @inline def bitrate: UndefOr[Int] = selectDynamic[UndefOr[Int]]("bitrate")

  @inline def withBitrate(newValue: UndefOr[Int]): RawChannel = objWithUndef(RawChannel, "bitrate", newValue)

  /** The user limit of the voice channel */
  @inline def userLimit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("user_limit")

  @inline def withUserLimit(newValue: UndefOr[Int]): RawChannel = objWithUndef(RawChannel, "user_limit", newValue)

  /**
    * Amount of seconds a user has to wait before sending another message
    * (0-21600); bots, as well as users with the permission manage_messages or
    * manage_channel, are unaffected
    */
  @inline def rateLimitPerUser: UndefOr[Int] = selectDynamic[UndefOr[Int]]("rate_limit_per_user")

  @inline def withRateLimitPerUser(newValue: UndefOr[Int]): RawChannel =
    objWithUndef(RawChannel, "rate_limit_per_user", newValue)

  /** The recipients of the DM */
  @inline def recipients: UndefOr[Seq[User]] = selectDynamic[UndefOr[Seq[User]]]("recipients")

  @inline def withRecipients(newValue: UndefOr[Seq[User]]): RawChannel =
    objWithUndef(RawChannel, "recipients", newValue)

  /** Icon hash of the group DM */
  @inline def icon: JsonOption[ImageHash] = selectDynamic[JsonOption[ImageHash]]("icon")

  @inline def withIcon(newValue: JsonOption[ImageHash]): RawChannel = objWithUndef(RawChannel, "icon", newValue)

  /** Id of the creator of the group DM or thread */
  @inline def ownerId: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("owner_id")

  @inline def withOwnerId(newValue: UndefOr[UserId]): RawChannel = objWithUndef(RawChannel, "owner_id", newValue)

  /** Application id of the group DM creator if it is bot-created */
  @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

  @inline def withApplicationId(newValue: UndefOr[ApplicationId]): RawChannel =
    objWithUndef(RawChannel, "application_id", newValue)

  /**
    * For group DM channels: whether the channel is managed by an application
    * via the gdm.join OAuth2 scope
    */
  @inline def managed: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("managed")

  @inline def withManaged(newValue: UndefOr[Boolean]): RawChannel = objWithUndef(RawChannel, "managed", newValue)

  /**
    * For guild channels: id of the parent category for a channel (each parent
    * category can contain up to 50 channels), for threads: id of the text
    * channel this thread was created
    */
  @inline def parentId: UndefOr[GuildChannelId] = selectDynamic[UndefOr[GuildChannelId]]("parent_id")

  @inline def withParentId(newValue: UndefOr[GuildChannelId]): RawChannel =
    objWithUndef(RawChannel, "parent_id", newValue)

  /**
    * When the last pinned message was pinned. This may be null in events such
    * as GUILD_CREATE when a message is not pinned.
    */
  @inline def lastPinTimestamp: JsonOption[OffsetDateTime] =
    selectDynamic[JsonOption[OffsetDateTime]]("last_pin_timestamp")

  @inline def withLastPinTimestamp(newValue: JsonOption[OffsetDateTime]): RawChannel =
    objWithUndef(RawChannel, "last_pin_timestamp", newValue)

  /** Voice region id for the voice channel, automatic when set to null */
  @inline def rtcRegion: JsonOption[VoiceRegion] = selectDynamic[JsonOption[VoiceRegion]]("rtc_region")

  @inline def withRtcRegion(newValue: JsonOption[VoiceRegion]): RawChannel =
    objWithUndef(RawChannel, "rtc_region", newValue)

  /** The camera video quality mode of the voice channel, 1 when not present */
  @inline def videoQualityMode: UndefOr[Channel.VideoQualityMode] =
    selectDynamic[UndefOr[Channel.VideoQualityMode]]("video_quality_mode")

  @inline def withVideoQualityMode(newValue: UndefOr[Channel.VideoQualityMode]): RawChannel =
    objWithUndef(RawChannel, "video_quality_mode", newValue)

  /**
    * Number of messages (not including the initial message or deleted messages)
    * in a thread.
    */
  @inline def messageCount: UndefOr[Int] = selectDynamic[UndefOr[Int]]("message_count")

  @inline def withMessageCount(newValue: UndefOr[Int]): RawChannel = objWithUndef(RawChannel, "message_count", newValue)

  /** An approximate count of users in a thread, stops counting at 50 */
  @inline def memberCount: UndefOr[Int] = selectDynamic[UndefOr[Int]]("member_count")

  @inline def withMemberCount(newValue: UndefOr[Int]): RawChannel = objWithUndef(RawChannel, "member_count", newValue)

  /** Thread-specific fields not needed by other channels */
  @inline def threadMetadata: UndefOr[Channel.ThreadMetadata] =
    selectDynamic[UndefOr[Channel.ThreadMetadata]]("thread_metadata")

  @inline def withThreadMetadata(newValue: UndefOr[Channel.ThreadMetadata]): RawChannel =
    objWithUndef(RawChannel, "thread_metadata", newValue)

  /**
    * Thread member object for the current user, if they have joined the thread,
    * only included on certain API endpoints
    */
  @inline def member: UndefOr[Channel.ThreadMember] = selectDynamic[UndefOr[Channel.ThreadMember]]("member")

  @inline def withMember(newValue: UndefOr[Channel.ThreadMember]): RawChannel =
    objWithUndef(RawChannel, "member", newValue)

  /**
    * Default duration, copied onto newly created threads, in minutes, threads
    * will stop showing in the channel list after the specified period of
    * inactivity, can be set to: 60, 1440, 4320, 10080
    */
  @inline def defaultAutoArchiveDuration: UndefOr[Int] = selectDynamic[UndefOr[Int]]("default_auto_archive_duration")

  @inline def withDefaultAutoArchiveDuration(newValue: UndefOr[Int]): RawChannel =
    objWithUndef(RawChannel, "default_auto_archive_duration", newValue)

  /**
    * Computed permissions for the invoking user in the channel, including
    * overwrites, only included when part of the resolved data received on a
    * slash command interaction
    */
  @inline def permissions: UndefOr[Permissions] = selectDynamic[UndefOr[Permissions]]("permissions")

  @inline def withPermissions(newValue: UndefOr[Permissions]): RawChannel =
    objWithUndef(RawChannel, "permissions", newValue)

  /** Channel flags combined as a bitfield */
  @inline def flags: UndefOr[Channel.ChannelFlags] = selectDynamic[UndefOr[Channel.ChannelFlags]]("flags")

  @inline def withFlags(newValue: UndefOr[Channel.ChannelFlags]): RawChannel =
    objWithUndef(RawChannel, "flags", newValue)

  /**
    * Number of messages ever sent in a thread, it's similar to message_count on
    * message creation, but will not decrement the number when a message is
    * deleted
    */
  @inline def totalMessageSent: UndefOr[Int] = selectDynamic[UndefOr[Int]]("total_message_sent")

  @inline def withTotalMessageSent(newValue: UndefOr[Int]): RawChannel =
    objWithUndef(RawChannel, "total_message_sent", newValue)

  /** The set of tags that can be used in a GUILD_FORUM channel */
  @inline def availableTags: UndefOr[Seq[Channel.ForumTag]] =
    selectDynamic[UndefOr[Seq[Channel.ForumTag]]]("available_tags")

  @inline def withAvailableTags(newValue: UndefOr[Seq[Channel.ForumTag]]): RawChannel =
    objWithUndef(RawChannel, "available_tags", newValue)

  /**
    * The IDs of the set of tags that have been applied to a thread in a
    * GUILD_FORUM channel
    */
  @inline def appliedTags: UndefOr[Seq[Snowflake[Channel.ForumTag]]] =
    selectDynamic[UndefOr[Seq[Snowflake[Channel.ForumTag]]]]("applied_tags")

  @inline def withAppliedTags(newValue: UndefOr[Seq[Snowflake[Channel.ForumTag]]]): RawChannel =
    objWithUndef(RawChannel, "applied_tags", newValue)

  /**
    * The emoji to show in the add reaction button on a thread in a GUILD_FORUM
    * channel
    */
  @inline def defaultReactionEmoji: JsonOption[Channel.DefaultReaction] =
    selectDynamic[JsonOption[Channel.DefaultReaction]]("default_reaction_emoji")

  @inline def withDefaultReactionEmoji(newValue: JsonOption[Channel.DefaultReaction]): RawChannel =
    objWithUndef(RawChannel, "default_reaction_emoji", newValue)

  /**
    * The initial rate_limit_per_user to set on newly created threads in a
    * channel. this field is copied to the thread at creation time and does not
    * live update.
    */
  @inline def defaultThreadRateLimitPerUser: UndefOr[Int] =
    selectDynamic[UndefOr[Int]]("default_thread_rate_limit_per_user")

  @inline def withDefaultThreadRateLimitPerUser(newValue: UndefOr[Int]): RawChannel =
    objWithUndef(RawChannel, "default_thread_rate_limit_per_user", newValue)

  /**
    * The default sort order type used to order posts in GUILD_FORUM channels.
    * Defaults to null, which indicates a preferred sort order hasn't been set
    * by a channel admin
    */
  @inline def defaultSortOrder: JsonOption[Channel.ForumSortOrder] =
    selectDynamic[JsonOption[Channel.ForumSortOrder]]("default_sort_order")

  @inline def withDefaultSortOrder(newValue: JsonOption[Channel.ForumSortOrder]): RawChannel =
    objWithUndef(RawChannel, "default_sort_order", newValue)

  /**
    * The default forum layout view used to display posts in GUILD_FORUM
    * channels. Defaults to 0, which indicates a layout view has not been set by
    * a channel admin
    */
  @inline def defaultForumLayout: UndefOr[Channel.ForumLayout] =
    selectDynamic[UndefOr[Channel.ForumLayout]]("default_forum_layout")

  @inline def withDefaultForumLayout(newValue: UndefOr[Channel.ForumLayout]): RawChannel =
    objWithUndef(RawChannel, "default_forum_layout", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => tpe,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => topic,
    () => nsfw,
    () => lastMessageId,
    () => bitrate,
    () => userLimit,
    () => rateLimitPerUser,
    () => recipients,
    () => icon,
    () => ownerId,
    () => applicationId,
    () => managed,
    () => parentId,
    () => lastPinTimestamp,
    () => rtcRegion,
    () => videoQualityMode,
    () => messageCount,
    () => memberCount,
    () => threadMetadata,
    () => member,
    () => defaultAutoArchiveDuration,
    () => permissions,
    () => flags,
    () => totalMessageSent,
    () => availableTags,
    () => appliedTags,
    () => defaultReactionEmoji,
    () => defaultThreadRateLimitPerUser,
    () => defaultSortOrder,
    () => defaultForumLayout
  )
}
object RawChannel extends DiscordObjectCompanion[RawChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): RawChannel = new RawChannel(json, cache)

  /**
    * @param id
    *   The id of this channel
    * @param tpe
    *   The type of channel
    * @param guildId
    *   The id of the guild (may be missing for some channel objects received
    *   over gateway guild dispatches)
    * @param position
    *   Sorting position of the channel
    * @param permissionOverwrites
    *   Explicit permission overwrites for members and roles
    * @param name
    *   The name of the channel (1-100 characters)
    * @param topic
    *   The channel topic (0-4096 characters for GUILD_FORUM channels, 0-1024
    *   characters for all others)
    * @param nsfw
    *   Whether the channel is nsfw
    * @param lastMessageId
    *   The id of the last message sent in this channel (or thread for
    *   GUILD_FORUM channels) (may not point to an existing or valid message or
    *   thread)
    * @param bitrate
    *   The bitrate (in bits) of the voice channel
    * @param userLimit
    *   The user limit of the voice channel
    * @param rateLimitPerUser
    *   Amount of seconds a user has to wait before sending another message
    *   (0-21600); bots, as well as users with the permission manage_messages or
    *   manage_channel, are unaffected
    * @param recipients
    *   The recipients of the DM
    * @param icon
    *   Icon hash of the group DM
    * @param ownerId
    *   Id of the creator of the group DM or thread
    * @param applicationId
    *   Application id of the group DM creator if it is bot-created
    * @param managed
    *   For group DM channels: whether the channel is managed by an application
    *   via the gdm.join OAuth2 scope
    * @param parentId
    *   For guild channels: id of the parent category for a channel (each parent
    *   category can contain up to 50 channels), for threads: id of the text
    *   channel this thread was created
    * @param lastPinTimestamp
    *   When the last pinned message was pinned. This may be null in events such
    *   as GUILD_CREATE when a message is not pinned.
    * @param rtcRegion
    *   Voice region id for the voice channel, automatic when set to null
    * @param videoQualityMode
    *   The camera video quality mode of the voice channel, 1 when not present
    * @param messageCount
    *   Number of messages (not including the initial message or deleted
    *   messages) in a thread.
    * @param memberCount
    *   An approximate count of users in a thread, stops counting at 50
    * @param threadMetadata
    *   Thread-specific fields not needed by other channels
    * @param member
    *   Thread member object for the current user, if they have joined the
    *   thread, only included on certain API endpoints
    * @param defaultAutoArchiveDuration
    *   Default duration, copied onto newly created threads, in minutes, threads
    *   will stop showing in the channel list after the specified period of
    *   inactivity, can be set to: 60, 1440, 4320, 10080
    * @param permissions
    *   Computed permissions for the invoking user in the channel, including
    *   overwrites, only included when part of the resolved data received on a
    *   slash command interaction
    * @param flags
    *   Channel flags combined as a bitfield
    * @param totalMessageSent
    *   Number of messages ever sent in a thread, it's similar to message_count
    *   on message creation, but will not decrement the number when a message is
    *   deleted
    * @param availableTags
    *   The set of tags that can be used in a GUILD_FORUM channel
    * @param appliedTags
    *   The IDs of the set of tags that have been applied to a thread in a
    *   GUILD_FORUM channel
    * @param defaultReactionEmoji
    *   The emoji to show in the add reaction button on a thread in a
    *   GUILD_FORUM channel
    * @param defaultThreadRateLimitPerUser
    *   The initial rate_limit_per_user to set on newly created threads in a
    *   channel. this field is copied to the thread at creation time and does
    *   not live update.
    * @param defaultSortOrder
    *   The default sort order type used to order posts in GUILD_FORUM channels.
    *   Defaults to null, which indicates a preferred sort order hasn't been set
    *   by a channel admin
    * @param defaultForumLayout
    *   The default forum layout view used to display posts in GUILD_FORUM
    *   channels. Defaults to 0, which indicates a layout view has not been set
    *   by a channel admin
    */
  def make20(
      id: ChannelId,
      tpe: Channel.ChannelType,
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      position: UndefOr[Int] = UndefOrUndefined(Some("position")),
      permissionOverwrites: UndefOr[Seq[Channel.PermissionOverwrite]] = UndefOrUndefined(Some("permission_overwrites")),
      name: JsonOption[String] = JsonUndefined(Some("name")),
      topic: JsonOption[String] = JsonUndefined(Some("topic")),
      nsfw: UndefOr[Boolean] = UndefOrUndefined(Some("nsfw")),
      lastMessageId: JsonOption[MessageId] = JsonUndefined(Some("last_message_id")),
      bitrate: UndefOr[Int] = UndefOrUndefined(Some("bitrate")),
      userLimit: UndefOr[Int] = UndefOrUndefined(Some("user_limit")),
      rateLimitPerUser: UndefOr[Int] = UndefOrUndefined(Some("rate_limit_per_user")),
      recipients: UndefOr[Seq[User]] = UndefOrUndefined(Some("recipients")),
      icon: JsonOption[ImageHash] = JsonUndefined(Some("icon")),
      ownerId: UndefOr[UserId] = UndefOrUndefined(Some("owner_id")),
      applicationId: UndefOr[ApplicationId] = UndefOrUndefined(Some("application_id")),
      managed: UndefOr[Boolean] = UndefOrUndefined(Some("managed")),
      parentId: UndefOr[GuildChannelId] = UndefOrUndefined(Some("parent_id")),
      lastPinTimestamp: JsonOption[OffsetDateTime] = JsonUndefined(Some("last_pin_timestamp")),
      rtcRegion: JsonOption[VoiceRegion] = JsonUndefined(Some("rtc_region")),
      videoQualityMode: UndefOr[Channel.VideoQualityMode] = UndefOrUndefined(Some("video_quality_mode")),
      messageCount: UndefOr[Int] = UndefOrUndefined(Some("message_count")),
      memberCount: UndefOr[Int] = UndefOrUndefined(Some("member_count")),
      threadMetadata: UndefOr[Channel.ThreadMetadata] = UndefOrUndefined(Some("thread_metadata")),
      member: UndefOr[Channel.ThreadMember] = UndefOrUndefined(Some("member")),
      defaultAutoArchiveDuration: UndefOr[Int] = UndefOrUndefined(Some("default_auto_archive_duration")),
      permissions: UndefOr[Permissions] = UndefOrUndefined(Some("permissions")),
      flags: UndefOr[Channel.ChannelFlags] = UndefOrUndefined(Some("flags")),
      totalMessageSent: UndefOr[Int] = UndefOrUndefined(Some("total_message_sent")),
      availableTags: UndefOr[Seq[Channel.ForumTag]] = UndefOrUndefined(Some("available_tags")),
      appliedTags: UndefOr[Seq[Snowflake[Channel.ForumTag]]] = UndefOrUndefined(Some("applied_tags")),
      defaultReactionEmoji: JsonOption[Channel.DefaultReaction] = JsonUndefined(Some("default_reaction_emoji")),
      defaultThreadRateLimitPerUser: UndefOr[Int] = UndefOrUndefined(Some("default_thread_rate_limit_per_user")),
      defaultSortOrder: JsonOption[Channel.ForumSortOrder] = JsonUndefined(Some("default_sort_order")),
      defaultForumLayout: UndefOr[Channel.ForumLayout] = UndefOrUndefined(Some("default_forum_layout"))
  ): RawChannel = makeRawFromFields(
    "id"                                  := id,
    "type"                                := tpe,
    "guild_id"                           :=? guildId,
    "position"                           :=? position,
    "permission_overwrites"              :=? permissionOverwrites,
    "name"                               :=? name,
    "topic"                              :=? topic,
    "nsfw"                               :=? nsfw,
    "last_message_id"                    :=? lastMessageId,
    "bitrate"                            :=? bitrate,
    "user_limit"                         :=? userLimit,
    "rate_limit_per_user"                :=? rateLimitPerUser,
    "recipients"                         :=? recipients,
    "icon"                               :=? icon,
    "owner_id"                           :=? ownerId,
    "application_id"                     :=? applicationId,
    "managed"                            :=? managed,
    "parent_id"                          :=? parentId,
    "last_pin_timestamp"                 :=? lastPinTimestamp,
    "rtc_region"                         :=? rtcRegion,
    "video_quality_mode"                 :=? videoQualityMode,
    "message_count"                      :=? messageCount,
    "member_count"                       :=? memberCount,
    "thread_metadata"                    :=? threadMetadata,
    "member"                             :=? member,
    "default_auto_archive_duration"      :=? defaultAutoArchiveDuration,
    "permissions"                        :=? permissions,
    "flags"                              :=? flags,
    "total_message_sent"                 :=? totalMessageSent,
    "available_tags"                     :=? availableTags,
    "applied_tags"                       :=? appliedTags,
    "default_reaction_emoji"             :=? defaultReactionEmoji,
    "default_thread_rate_limit_per_user" :=? defaultThreadRateLimitPerUser,
    "default_sort_order"                 :=? defaultSortOrder,
    "default_forum_layout"               :=? defaultForumLayout
  )
}

sealed trait Channel extends DiscordObject {
  def asRawChannel: RawChannel = retype(RawChannel)

  def id: ChannelId
}

sealed trait TextChannel extends Channel {
  override def id: TextChannelId

  def lastMessageId: Option[MessageId]
}
object TextChannel extends DiscordObjectCompanion[TextChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): TextChannel =
    Channel.makeRaw(json, cache).asInstanceOf[TextChannel]
}

sealed trait GuildChannel extends Channel {
  override def id: GuildChannelId

  def guildId: UndefOr[GuildId]

  def position: Int

  def permissionOverwrites: Seq[Channel.PermissionOverwrite]

  def name: String

  def parentId: Option[GuildChannelId]
}
object GuildChannel extends DiscordObjectCompanion[GuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): GuildChannel =
    Channel.makeRaw(json, cache).asInstanceOf[GuildChannel]
}

sealed trait TextGuildChannel extends GuildChannel with TextChannel {
  override def id: TextGuildChannelId

  def rateLimitPerUser: UndefOr[Int]
}
object TextGuildChannel extends DiscordObjectCompanion[TextGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): TextGuildChannel =
    Channel.makeRaw(json, cache).asInstanceOf[TextGuildChannel]
}

sealed trait VoiceGuildChannel extends GuildChannel {
  override def id: VoiceGuildChannelId

  def bitrate: Int
  def userLimit: Int
  def rtcRegion: Option[String]
  def videoQualityMode: Channel.VideoQualityMode
}
object VoiceGuildChannel extends DiscordObjectCompanion[VoiceGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): VoiceGuildChannel =
    Channel.makeRaw(json, cache).asInstanceOf[VoiceGuildChannel]
}

class TopLevelTextGuildChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextGuildChannel {

  @inline override def id: TopLevelTextGuildChannelId = selectDynamic[TopLevelTextGuildChannelId]("id")

  @inline def withId(newValue: TopLevelTextGuildChannelId): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "id", newValue)

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def withLastMessageId(newValue: Option[MessageId]): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "last_message_id", newValue)

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): TopLevelTextGuildChannel =
    objWithUndef(TopLevelTextGuildChannel, "guild_id", newValue)

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def withPosition(newValue: Int): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "position", newValue)

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def withPermissionOverwrites(newValue: Seq[Channel.PermissionOverwrite]): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "permission_overwrites", newValue)

  @inline def name: String = selectDynamic[String]("name")

  @inline def withName(newValue: String): TopLevelTextGuildChannel = objWith(TopLevelTextGuildChannel, "name", newValue)

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def withParentId(newValue: Option[GuildChannelId]): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "parent_id", newValue)

  @inline def topic: Option[String] = selectDynamic[Option[String]]("topic")

  @inline def withTopic(newValue: Option[String]): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "topic", newValue)

  @inline def lastPinTimestamp: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("last_pin_timestamp")

  @inline def withLastPinTimestamp(newValue: Option[OffsetDateTime]): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "last_pin_timestamp", newValue)

  @inline def defaultAutoArchiveDuration: Int = selectDynamic[Int]("default_auto_archive_duration")

  @inline def withDefaultAutoArchiveDuration(newValue: Int): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "default_auto_archive_duration", newValue)

  @inline def rateLimitPerUser: UndefOr[Int] = selectDynamic[UndefOr[Int]]("rate_limit_per_user")

  @inline def withRateLimitPerUser(newValue: UndefOr[Int]): TopLevelTextGuildChannel =
    objWithUndef(TopLevelTextGuildChannel, "rate_limit_per_user", newValue)

  @inline def defaultThreadRateLimitPerUser: Int = selectDynamic[Int]("default_thread_rate_limit_per_user")

  @inline def withDefaultThreadRateLimitPerUser(newValue: Int): TopLevelTextGuildChannel =
    objWith(TopLevelTextGuildChannel, "default_thread_rate_limit_per_user", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => lastMessageId,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => topic,
    () => lastPinTimestamp,
    () => defaultAutoArchiveDuration,
    () => rateLimitPerUser,
    () => defaultThreadRateLimitPerUser
  )
}
object TopLevelTextGuildChannel extends DiscordObjectCompanion[TopLevelTextGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): TopLevelTextGuildChannel =
    new TopLevelTextGuildChannel(json, cache)

  def make20(
      id: TopLevelTextGuildChannelId,
      lastMessageId: Option[MessageId],
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      topic: Option[String],
      lastPinTimestamp: Option[OffsetDateTime],
      defaultAutoArchiveDuration: Int,
      rateLimitPerUser: UndefOr[Int] = UndefOrUndefined(Some("rate_limit_per_user")),
      defaultThreadRateLimitPerUser: Int
  ): TopLevelTextGuildChannel = makeRawFromFields(
    "id"                                 := id,
    "last_message_id"                    := lastMessageId,
    "guild_id"                          :=? guildId,
    "position"                           := position,
    "permission_overwrites"              := permissionOverwrites,
    "name"                               := name,
    "parent_id"                          := parentId,
    "topic"                              := topic,
    "last_pin_timestamp"                 := lastPinTimestamp,
    "default_auto_archive_duration"      := defaultAutoArchiveDuration,
    "rate_limit_per_user"               :=? rateLimitPerUser,
    "default_thread_rate_limit_per_user" := defaultThreadRateLimitPerUser
  )
}

class NormalVoiceGuildChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextGuildChannel {

  @inline override def id: NormalVoiceGuildChannelId = selectDynamic[NormalVoiceGuildChannelId]("id")

  @inline def withId(newValue: NormalVoiceGuildChannelId): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "id", newValue)

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def withLastMessageId(newValue: Option[MessageId]): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "last_message_id", newValue)

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): NormalVoiceGuildChannel =
    objWithUndef(NormalVoiceGuildChannel, "guild_id", newValue)

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def withPosition(newValue: Int): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "position", newValue)

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def withPermissionOverwrites(newValue: Seq[Channel.PermissionOverwrite]): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "permission_overwrites", newValue)

  @inline def name: String = selectDynamic[String]("name")

  @inline def withName(newValue: String): NormalVoiceGuildChannel = objWith(NormalVoiceGuildChannel, "name", newValue)

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def withParentId(newValue: Option[GuildChannelId]): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "parent_id", newValue)

  @inline def rateLimitPerUser: UndefOr[Int] = selectDynamic[UndefOr[Int]]("rate_limit_per_user")

  @inline def withRateLimitPerUser(newValue: UndefOr[Int]): NormalVoiceGuildChannel =
    objWithUndef(NormalVoiceGuildChannel, "rate_limit_per_user", newValue)

  @inline def bitrate: Int = selectDynamic[Int]("bitrate")

  @inline def withBitrate(newValue: Int): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "bitrate", newValue)

  @inline def userLimit: Int = selectDynamic[Int]("user_limit")

  @inline def withUserLimit(newValue: Int): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "user_limit", newValue)

  @inline def rtcRegion: Option[String] = selectDynamic[Option[String]]("rtc_region")

  @inline def withRtcRegion(newValue: Option[String]): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "rtc_region", newValue)

  @inline def videoQualityMode: Channel.VideoQualityMode = selectDynamic[Channel.VideoQualityMode]("video_quality_mode")

  @inline def withVideoQualityMode(newValue: Channel.VideoQualityMode): NormalVoiceGuildChannel =
    objWith(NormalVoiceGuildChannel, "video_quality_mode", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => lastMessageId,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => rateLimitPerUser,
    () => bitrate,
    () => userLimit,
    () => rtcRegion,
    () => videoQualityMode
  )
}
object NormalVoiceGuildChannel extends DiscordObjectCompanion[NormalVoiceGuildChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): NormalVoiceGuildChannel =
    new NormalVoiceGuildChannel(json, cache)

  def make20(
      id: NormalVoiceGuildChannelId,
      lastMessageId: Option[MessageId],
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      rateLimitPerUser: UndefOr[Int] = UndefOrUndefined(Some("rate_limit_per_user")),
      bitrate: Int,
      userLimit: Int,
      rtcRegion: Option[String],
      videoQualityMode: Channel.VideoQualityMode
  ): NormalVoiceGuildChannel = makeRawFromFields(
    "id"                    := id,
    "last_message_id"       := lastMessageId,
    "guild_id"             :=? guildId,
    "position"              := position,
    "permission_overwrites" := permissionOverwrites,
    "name"                  := name,
    "parent_id"             := parentId,
    "rate_limit_per_user"  :=? rateLimitPerUser,
    "bitrate"               := bitrate,
    "user_limit"            := userLimit,
    "rtc_region"            := rtcRegion,
    "video_quality_mode"    := videoQualityMode
  )
}

class GuildCategory(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with GuildChannel {

  @inline override def id: GuildCategoryId = selectDynamic[GuildCategoryId]("id")

  @inline def withId(newValue: GuildCategoryId): GuildCategory = objWith(GuildCategory, "id", newValue)

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): GuildCategory =
    objWithUndef(GuildCategory, "guild_id", newValue)

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def withPosition(newValue: Int): GuildCategory = objWith(GuildCategory, "position", newValue)

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def withPermissionOverwrites(newValue: Seq[Channel.PermissionOverwrite]): GuildCategory =
    objWith(GuildCategory, "permission_overwrites", newValue)

  @inline def name: String = selectDynamic[String]("name")

  @inline def withName(newValue: String): GuildCategory = objWith(GuildCategory, "name", newValue)

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def withParentId(newValue: Option[GuildChannelId]): GuildCategory =
    objWith(GuildCategory, "parent_id", newValue)

  override def values: Seq[() => Any] =
    Seq(() => id, () => guildId, () => position, () => permissionOverwrites, () => name, () => parentId)
}
object GuildCategory extends DiscordObjectCompanion[GuildCategory] {
  def makeRaw(json: Json, cache: Map[String, Any]): GuildCategory = new GuildCategory(json, cache)

  def make20(
      id: GuildCategoryId,
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId]
  ): GuildCategory = makeRawFromFields(
    "id"                    := id,
    "guild_id"             :=? guildId,
    "position"              := position,
    "permission_overwrites" := permissionOverwrites,
    "name"                  := name,
    "parent_id"             := parentId
  )
}

class ThreadChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextChannel {

  @inline override def id: ThreadChannelId = selectDynamic[ThreadChannelId]("id")

  @inline def withId(newValue: ThreadChannelId): ThreadChannel = objWith(ThreadChannel, "id", newValue)

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): ThreadChannel =
    objWithUndef(ThreadChannel, "guild_id", newValue)

  @inline def name: String = selectDynamic[String]("name")

  @inline def withName(newValue: String): ThreadChannel = objWith(ThreadChannel, "name", newValue)

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def withLastMessageId(newValue: Option[MessageId]): ThreadChannel =
    objWith(ThreadChannel, "last_message_id", newValue)

  @inline def lastPinTimestamp: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("last_pin_timestamp")

  @inline def withLastPinTimestamp(newValue: Option[OffsetDateTime]): ThreadChannel =
    objWith(ThreadChannel, "last_pin_timestamp", newValue)

  @inline def rateLimitPerUser: Option[Int] = selectDynamic[Option[Int]]("rate_limit_per_user")

  @inline def withRateLimitPerUser(newValue: Option[Int]): ThreadChannel =
    objWith(ThreadChannel, "rate_limit_per_user", newValue)

  @inline def ownerId: UserId = selectDynamic[UserId]("owner_id")

  @inline def withOwnerId(newValue: UserId): ThreadChannel = objWith(ThreadChannel, "owner_id", newValue)

  @inline def memberCount: Int = selectDynamic[Int]("member_count")

  @inline def withMemberCount(newValue: Int): ThreadChannel = objWith(ThreadChannel, "member_count", newValue)

  @inline def messageCount: Int = selectDynamic[Int]("message_count")

  @inline def withMessageCount(newValue: Int): ThreadChannel = objWith(ThreadChannel, "message_count", newValue)

  @inline def totalMessageSent: Int = selectDynamic[Int]("total_message_sent")

  @inline def withTotalMessageSent(newValue: Int): ThreadChannel =
    objWith(ThreadChannel, "total_message_sent", newValue)

  @inline def threadMetadata: Channel.ThreadMetadata = selectDynamic[Channel.ThreadMetadata]("thread_metadata")

  @inline def withThreadMetadata(newValue: Channel.ThreadMetadata): ThreadChannel =
    objWith(ThreadChannel, "thread_metadata", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => guildId,
    () => name,
    () => lastMessageId,
    () => lastPinTimestamp,
    () => rateLimitPerUser,
    () => ownerId,
    () => memberCount,
    () => messageCount,
    () => totalMessageSent,
    () => threadMetadata
  )
}
object ThreadChannel extends DiscordObjectCompanion[ThreadChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): ThreadChannel = new ThreadChannel(json, cache)

  def make20(
      id: ThreadChannelId,
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      name: String,
      lastMessageId: Option[MessageId],
      lastPinTimestamp: Option[OffsetDateTime],
      rateLimitPerUser: Option[Int],
      ownerId: UserId,
      memberCount: Int,
      messageCount: Int,
      totalMessageSent: Int,
      threadMetadata: Channel.ThreadMetadata
  ): ThreadChannel = makeRawFromFields(
    "id"                  := id,
    "guild_id"           :=? guildId,
    "name"                := name,
    "last_message_id"     := lastMessageId,
    "last_pin_timestamp"  := lastPinTimestamp,
    "rate_limit_per_user" := rateLimitPerUser,
    "owner_id"            := ownerId,
    "member_count"        := memberCount,
    "message_count"       := messageCount,
    "total_message_sent"  := totalMessageSent,
    "thread_metadata"     := threadMetadata
  )
}

class StageChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with VoiceGuildChannel {

  @inline override def id: StageChannelId = selectDynamic[StageChannelId]("id")

  @inline def withId(newValue: StageChannelId): StageChannel = objWith(StageChannel, "id", newValue)

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): StageChannel = objWithUndef(StageChannel, "guild_id", newValue)

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def withPosition(newValue: Int): StageChannel = objWith(StageChannel, "position", newValue)

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def withPermissionOverwrites(newValue: Seq[Channel.PermissionOverwrite]): StageChannel =
    objWith(StageChannel, "permission_overwrites", newValue)

  @inline def name: String = selectDynamic[String]("name")

  @inline def withName(newValue: String): StageChannel = objWith(StageChannel, "name", newValue)

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def withParentId(newValue: Option[GuildChannelId]): StageChannel =
    objWith(StageChannel, "parent_id", newValue)

  @inline def bitrate: Int = selectDynamic[Int]("bitrate")

  @inline def withBitrate(newValue: Int): StageChannel = objWith(StageChannel, "bitrate", newValue)

  @inline def userLimit: Int = selectDynamic[Int]("user_limit")

  @inline def withUserLimit(newValue: Int): StageChannel = objWith(StageChannel, "user_limit", newValue)

  @inline def rtcRegion: Option[String] = selectDynamic[Option[String]]("rtc_region")

  @inline def withRtcRegion(newValue: Option[String]): StageChannel = objWith(StageChannel, "rtc_region", newValue)

  @inline def videoQualityMode: Channel.VideoQualityMode = selectDynamic[Channel.VideoQualityMode]("video_quality_mode")

  @inline def withVideoQualityMode(newValue: Channel.VideoQualityMode): StageChannel =
    objWith(StageChannel, "video_quality_mode", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => bitrate,
    () => userLimit,
    () => rtcRegion,
    () => videoQualityMode
  )
}
object StageChannel extends DiscordObjectCompanion[StageChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): StageChannel = new StageChannel(json, cache)

  def make20(
      id: StageChannelId,
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      bitrate: Int,
      userLimit: Int,
      rtcRegion: Option[String],
      videoQualityMode: Channel.VideoQualityMode
  ): StageChannel = makeRawFromFields(
    "id"                    := id,
    "guild_id"             :=? guildId,
    "position"              := position,
    "permission_overwrites" := permissionOverwrites,
    "name"                  := name,
    "parent_id"             := parentId,
    "bitrate"               := bitrate,
    "user_limit"            := userLimit,
    "rtc_region"            := rtcRegion,
    "video_quality_mode"    := videoQualityMode
  )
}

class ForumChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with GuildChannel {

  @inline override def id: ForumChannelId = selectDynamic[ForumChannelId]("id")

  @inline def withId(newValue: ForumChannelId): ForumChannel = objWith(ForumChannel, "id", newValue)

  @inline def lastMessageId: Option[ThreadChannelId] = selectDynamic[Option[ThreadChannelId]]("last_message_id")

  @inline def withLastMessageId(newValue: Option[ThreadChannelId]): ForumChannel =
    objWith(ForumChannel, "last_message_id", newValue)

  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): ForumChannel = objWithUndef(ForumChannel, "guild_id", newValue)

  @inline def position: Int = selectDynamic[Int]("position")

  @inline def withPosition(newValue: Int): ForumChannel = objWith(ForumChannel, "position", newValue)

  @inline def permissionOverwrites: Seq[Channel.PermissionOverwrite] =
    selectDynamic[Seq[Channel.PermissionOverwrite]]("permission_overwrites")

  @inline def withPermissionOverwrites(newValue: Seq[Channel.PermissionOverwrite]): ForumChannel =
    objWith(ForumChannel, "permission_overwrites", newValue)

  @inline def name: String = selectDynamic[String]("name")

  @inline def withName(newValue: String): ForumChannel = objWith(ForumChannel, "name", newValue)

  @inline def parentId: Option[GuildChannelId] = selectDynamic[Option[GuildChannelId]]("parent_id")

  @inline def withParentId(newValue: Option[GuildChannelId]): ForumChannel =
    objWith(ForumChannel, "parent_id", newValue)

  @inline def topic: Option[String] = selectDynamic[Option[String]]("topic")

  @inline def withTopic(newValue: Option[String]): ForumChannel = objWith(ForumChannel, "topic", newValue)

  @inline def rateLimitPerUser: Option[Int] = selectDynamic[Option[Int]]("rate_limit_per_user")

  @inline def withRateLimitPerUser(newValue: Option[Int]): ForumChannel =
    objWith(ForumChannel, "rate_limit_per_user", newValue)

  @inline def defaultAutoArchiveDuration: Option[Int] = selectDynamic[Option[Int]]("default_auto_archive_duration")

  @inline def withDefaultAutoArchiveDuration(newValue: Option[Int]): ForumChannel =
    objWith(ForumChannel, "default_auto_archive_duration", newValue)

  @inline def flags: Channel.ChannelFlags = selectDynamic[Channel.ChannelFlags]("flags")

  @inline def withFlags(newValue: Channel.ChannelFlags): ForumChannel =
    objWith(ForumChannel, "flags", newValue)

  @inline def availableTags: Seq[Channel.ForumTag] = selectDynamic[Seq[Channel.ForumTag]]("available_tags")

  @inline def withAvailableTags(newValue: Seq[Channel.ForumTag]): ForumChannel =
    objWith(ForumChannel, "available_tags", newValue)

  @inline def defaultReactionEmoji: Option[Channel.DefaultReaction] =
    selectDynamic[Option[Channel.DefaultReaction]]("default_reaction_emoji")

  @inline def withDefaultReactionEmoji(newValue: Option[Channel.DefaultReaction]): ForumChannel =
    objWith(ForumChannel, "default_reaction_emoji", newValue)

  @inline def defaultThreadRateLimitPerUser: Int = selectDynamic[Int]("default_thread_rate_limit_per_user")

  @inline def withDefaultThreadRateLimitPerUser(newValue: Int): ForumChannel =
    objWith(ForumChannel, "default_thread_rate_limit_per_user", newValue)

  @inline def defaultSortOrder: Channel.ForumSortOrder = selectDynamic[Channel.ForumSortOrder]("default_sort_order")

  @inline def withDefaultSortOrder(newValue: Channel.ForumSortOrder): ForumChannel =
    objWith(ForumChannel, "default_sort_order", newValue)

  @inline def defaultForumLayout: Channel.ForumLayout = selectDynamic[Channel.ForumLayout]("default_forum_layout")

  @inline def withDefaultForumLayout(newValue: Channel.ForumLayout): ForumChannel =
    objWith(ForumChannel, "default_forum_layout", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => lastMessageId,
    () => guildId,
    () => position,
    () => permissionOverwrites,
    () => name,
    () => parentId,
    () => topic,
    () => rateLimitPerUser,
    () => defaultAutoArchiveDuration,
    () => flags,
    () => availableTags,
    () => defaultReactionEmoji,
    () => defaultThreadRateLimitPerUser,
    () => defaultSortOrder,
    () => defaultForumLayout
  )
}
object ForumChannel extends DiscordObjectCompanion[ForumChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): ForumChannel = new ForumChannel(json, cache)

  def make20(
      id: ForumChannelId,
      lastMessageId: Option[ThreadChannelId],
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      position: Int,
      permissionOverwrites: Seq[Channel.PermissionOverwrite],
      name: String,
      parentId: Option[GuildChannelId],
      topic: Option[String],
      rateLimitPerUser: Option[Int],
      defaultAutoArchiveDuration: Option[Int],
      flags: Channel.ChannelFlags,
      availableTags: Seq[Channel.ForumTag],
      defaultReactionEmoji: Option[Channel.DefaultReaction],
      defaultThreadRateLimitPerUser: Int,
      defaultSortOrder: Channel.ForumSortOrder,
      defaultForumLayout: Channel.ForumLayout
  ): ForumChannel = makeRawFromFields(
    "id"                                 := id,
    "last_message_id"                    := lastMessageId,
    "guild_id"                          :=? guildId,
    "position"                           := position,
    "permission_overwrites"              := permissionOverwrites,
    "name"                               := name,
    "parent_id"                          := parentId,
    "topic"                              := topic,
    "rate_limit_per_user"                := rateLimitPerUser,
    "default_auto_archive_duration"      := defaultAutoArchiveDuration,
    "flags"                              := flags,
    "available_tags"                     := availableTags,
    "default_reaction_emoji"             := defaultReactionEmoji,
    "default_thread_rate_limit_per_user" := defaultThreadRateLimitPerUser,
    "default_sort_order"                 := defaultSortOrder,
    "default_forum_layout"               := defaultForumLayout
  )
}

class DMChannel(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) with TextChannel {

  @inline override def id: DMChannelId = selectDynamic[DMChannelId]("id")

  @inline def withId(newValue: DMChannelId): DMChannel = objWith(DMChannel, "id", newValue)

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def withLastMessageId(newValue: Option[MessageId]): DMChannel =
    objWith(DMChannel, "last_message_id", newValue)

  @inline def recipients: Seq[User] = selectDynamic[Seq[User]]("recipients")

  @inline def withRecipients(newValue: Seq[User]): DMChannel = objWith(DMChannel, "recipients", newValue)

  override def values: Seq[() => Any] = Seq(() => id, () => lastMessageId, () => recipients)
}
object DMChannel extends DiscordObjectCompanion[DMChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): DMChannel = new DMChannel(json, cache)

  def make20(
      id: DMChannelId,
      lastMessageId: Option[MessageId],
      recipients: Seq[User]
  ): DMChannel = makeRawFromFields("id" := id, "last_message_id" := lastMessageId, "recipients" := recipients)
}

class GroupDMChannel(json: Json, cache: Map[String, Any] = Map.empty)
    extends DiscordObject(json, cache)
    with TextChannel {

  @inline override def id: GroupDMChannelId = selectDynamic[GroupDMChannelId]("id")

  @inline def withId(newValue: GroupDMChannelId): GroupDMChannel = objWith(GroupDMChannel, "id", newValue)

  @inline def lastMessageId: Option[MessageId] = selectDynamic[Option[MessageId]]("last_message_id")

  @inline def withLastMessageId(newValue: Option[MessageId]): GroupDMChannel =
    objWith(GroupDMChannel, "last_message_id", newValue)

  @inline def recipients: Seq[User] = selectDynamic[Seq[User]]("recipients")

  @inline def withRecipients(newValue: Seq[User]): GroupDMChannel = objWith(GroupDMChannel, "recipients", newValue)

  @inline def icon: Option[ImageHash] = selectDynamic[Option[ImageHash]]("icon")

  @inline def withIcon(newValue: Option[ImageHash]): GroupDMChannel = objWith(GroupDMChannel, "icon", newValue)

  @inline def ownerId: UserId = selectDynamic[UserId]("owner_id")

  @inline def withOwnerId(newValue: UserId): GroupDMChannel = objWith(GroupDMChannel, "owner_id", newValue)

  @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

  @inline def withApplicationId(newValue: UndefOr[ApplicationId]): GroupDMChannel =
    objWithUndef(GroupDMChannel, "application_id", newValue)

  @inline def managed: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("managed")

  @inline def withManaged(newValue: UndefOr[Boolean]): GroupDMChannel =
    objWithUndef(GroupDMChannel, "managed", newValue)

  override def values: Seq[() => Any] =
    Seq(() => id, () => lastMessageId, () => recipients, () => icon, () => ownerId, () => applicationId, () => managed)
}
object GroupDMChannel extends DiscordObjectCompanion[GroupDMChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): GroupDMChannel = new GroupDMChannel(json, cache)

  def make20(
      id: GroupDMChannelId,
      lastMessageId: Option[MessageId],
      recipients: Seq[User],
      icon: Option[ImageHash],
      ownerId: UserId,
      applicationId: UndefOr[ApplicationId] = UndefOrUndefined(Some("application_id")),
      managed: UndefOr[Boolean] = UndefOrUndefined(Some("managed"))
  ): GroupDMChannel = makeRawFromFields(
    "id"              := id,
    "last_message_id" := lastMessageId,
    "recipients"      := recipients,
    "icon"            := icon,
    "owner_id"        := ownerId,
    "application_id" :=? applicationId,
    "managed"        :=? managed
  )
}

object Channel extends DiscordObjectCompanion[Channel] {

  def makeRaw(json: Json, cache: Map[String, Any]): Channel =
    json.hcursor.get[ChannelType]("type").toOption.fold(RawChannel.makeRaw(json, cache): Channel) {
      case ChannelType.GUILD_TEXT          => TopLevelTextGuildChannel.makeRaw(json, cache)
      case ChannelType.DM                  => DMChannel.makeRaw(json, cache)
      case ChannelType.GUILD_VOICE         => NormalVoiceGuildChannel.makeRaw(json, cache)
      case ChannelType.GROUP_DM            => GroupDMChannel.makeRaw(json, cache)
      case ChannelType.GUILD_CATEGORY      => GuildCategory.makeRaw(json, cache)
      case ChannelType.GUILD_ANNOUNCEMENT  => TopLevelTextGuildChannel.makeRaw(json, cache)
      case ChannelType.ANNOUNCEMENT_THREAD => ThreadChannel.makeRaw(json, cache)
      case ChannelType.PUBLIC_THREAD       => ThreadChannel.makeRaw(json, cache)
      case ChannelType.PRIVATE_THREAD      => ThreadChannel.makeRaw(json, cache)
      case ChannelType.GUILD_STAGE_VOICE   => StageChannel.makeRaw(json, cache)
      case ChannelType.GUILD_DIRECTORY     => RawChannel.makeRaw(json, cache)
      case ChannelType.GUILD_FORUM         => ForumChannel.makeRaw(json, cache)
      case _                               => RawChannel.makeRaw(json, cache)
    }

  sealed case class ChannelType private (value: Int) extends DiscordEnum[Int]
  object ChannelType                                 extends DiscordEnumCompanion[Int, ChannelType] {

    /** A text channel within a server */
    val GUILD_TEXT: ChannelType = ChannelType(0)

    /** A direct message between users */
    val DM: ChannelType = ChannelType(1)

    /** A voice channel within a server */
    val GUILD_VOICE: ChannelType = ChannelType(2)

    /** A direct message between multiple users */
    val GROUP_DM: ChannelType = ChannelType(3)

    /** An organizational category that contains up to 50 channels */
    val GUILD_CATEGORY: ChannelType = ChannelType(4)

    /**
      * A channel that users can follow and crosspost into their own server
      * (formerly news channels)
      */
    val GUILD_ANNOUNCEMENT: ChannelType = ChannelType(5)

    /** A temporary sub-channel within a GUILD_ANNOUNCEMENT channel */
    val ANNOUNCEMENT_THREAD: ChannelType = ChannelType(10)

    /** A temporary sub-channel within a GUILD_TEXT or GUILD_FORUM channel */
    val PUBLIC_THREAD: ChannelType = ChannelType(11)

    /**
      * A temporary sub-channel within a GUILD_TEXT channel that is only
      * viewable by those invited and those with the MANAGE_THREADS permission
      */
    val PRIVATE_THREAD: ChannelType = ChannelType(12)

    /** A voice channel for hosting events with an audience */
    val GUILD_STAGE_VOICE: ChannelType = ChannelType(13)

    /** The channel in a hub containing the listed servers */
    val GUILD_DIRECTORY: ChannelType = ChannelType(14)

    /** Channel that can only contain threads */
    val GUILD_FORUM: ChannelType = ChannelType(15)

    def unknown(value: Int): ChannelType = new ChannelType(value)

    val values: Seq[ChannelType] = Seq(
      GUILD_TEXT,
      DM,
      GUILD_VOICE,
      GROUP_DM,
      GUILD_CATEGORY,
      GUILD_ANNOUNCEMENT,
      ANNOUNCEMENT_THREAD,
      PUBLIC_THREAD,
      PRIVATE_THREAD,
      GUILD_STAGE_VOICE,
      GUILD_DIRECTORY,
      GUILD_FORUM
    )
  }

  sealed case class VideoQualityMode private (value: Int) extends DiscordEnum[Int]
  object VideoQualityMode                                 extends DiscordEnumCompanion[Int, VideoQualityMode] {

    /** Discord chooses the quality for optimal performance */
    val AUTO: VideoQualityMode = VideoQualityMode(1)

    /** 720p */
    val FULL: VideoQualityMode = VideoQualityMode(2)

    def unknown(value: Int): VideoQualityMode = new VideoQualityMode(value)

    val values: Seq[VideoQualityMode] = Seq(AUTO, FULL)
  }

  sealed case class ChannelFlags private (value: Int) extends DiscordEnum[Int]
  object ChannelFlags                                 extends DiscordEnumCompanion[Int, ChannelFlags] {

    /** This thread is pinned to the top of its parent GUILD_FORUM channel */
    val PINNED: ChannelFlags = ChannelFlags(1 << 1)

    /**
      * Whether a tag is required to be specified when creating a thread in a
      * GUILD_FORUM channel. Tags are specified in the applied_tags field.
      */
    val REQUIRE_TAG: ChannelFlags = ChannelFlags(1 << 4)

    def unknown(value: Int): ChannelFlags = new ChannelFlags(value)

    val values: Seq[ChannelFlags] = Seq(PINNED, REQUIRE_TAG)

    implicit class ChannelFlagsBitFieldOps(private val here: ChannelFlags) extends AnyVal {

      def toInt: Int = here.value

      def ++(there: ChannelFlags): ChannelFlags = ChannelFlags(here.value | there.value)

      def --(there: ChannelFlags): ChannelFlags = ChannelFlags(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }

  sealed case class ForumSortOrder private (value: Int) extends DiscordEnum[Int]
  object ForumSortOrder                                 extends DiscordEnumCompanion[Int, ForumSortOrder] {

    /** Sort forum posts by activity */
    val LATEST_ACTIVITY: ForumSortOrder = ForumSortOrder(0)

    /** Sort forum posts by creation time (from most recent to oldest) */
    val CREATION_DATE: ForumSortOrder = ForumSortOrder(1)

    def unknown(value: Int): ForumSortOrder = new ForumSortOrder(value)

    val values: Seq[ForumSortOrder] = Seq(LATEST_ACTIVITY, CREATION_DATE)
  }

  sealed case class ForumLayout private (value: Int) extends DiscordEnum[Int]
  object ForumLayout                                 extends DiscordEnumCompanion[Int, ForumLayout] {

    /** No default has been set for forum channel */
    val NOT_SET: ForumLayout = ForumLayout(0)

    /** Display posts as a list */
    val LIST_VIEW: ForumLayout = ForumLayout(1)

    /** Display posts as a collection of tiles */
    val GALLERY_VIEW: ForumLayout = ForumLayout(2)

    def unknown(value: Int): ForumLayout = new ForumLayout(value)

    val values: Seq[ForumLayout] = Seq(NOT_SET, LIST_VIEW, GALLERY_VIEW)
  }

  class PermissionOverwrite(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Role or user id */
    @inline def id: UserOrRoleId = selectDynamic[UserOrRoleId]("id")

    @inline def withId(newValue: UserOrRoleId): PermissionOverwrite = objWith(PermissionOverwrite, "id", newValue)

    /** Either 0 (role) or 1 (member) */
    @inline def tpe: PermissionOverwrite.PermissionOverwriteType =
      selectDynamic[PermissionOverwrite.PermissionOverwriteType]("type")

    @inline def withTpe(newValue: PermissionOverwrite.PermissionOverwriteType): PermissionOverwrite =
      objWith(PermissionOverwrite, "type", newValue)

    /** Permission bit set */
    @inline def allow: Permissions = selectDynamic[Permissions]("allow")

    @inline def withAllow(newValue: Permissions): PermissionOverwrite =
      objWith(PermissionOverwrite, "allow", newValue)

    /** Permission bit set */
    @inline def deny: Permissions = selectDynamic[Permissions]("deny")

    @inline def withDeny(newValue: Permissions): PermissionOverwrite =
      objWith(PermissionOverwrite, "deny", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => tpe, () => allow, () => deny)
  }
  object PermissionOverwrite extends DiscordObjectCompanion[PermissionOverwrite] {
    def makeRaw(json: Json, cache: Map[String, Any]): PermissionOverwrite =
      new PermissionOverwrite(json, cache)

    /**
      * @param id
      *   Role or user id
      * @param tpe
      *   Either 0 (role) or 1 (member)
      * @param allow
      *   Permission bit set
      * @param deny
      *   Permission bit set
      */
    def make20(
        id: UserOrRoleId,
        tpe: PermissionOverwrite.PermissionOverwriteType,
        allow: Permissions,
        deny: Permissions
    ): PermissionOverwrite = makeRawFromFields("id" := id, "type" := tpe, "allow" := allow, "deny" := deny)

    sealed case class PermissionOverwriteType private (value: Int) extends DiscordEnum[Int]
    object PermissionOverwriteType extends DiscordEnumCompanion[Int, PermissionOverwriteType] {
      val Role: PermissionOverwriteType = PermissionOverwriteType(0)

      val Member: PermissionOverwriteType = PermissionOverwriteType(1)

      def unknown(value: Int): PermissionOverwriteType = new PermissionOverwriteType(value)

      val values: Seq[PermissionOverwriteType] = Seq(Role, Member)
    }
  }

  /**
    * The thread metadata object contains a number of thread-specific channel
    * fields that are not needed by other channel types.
    */
  class ThreadMetadata(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Whether the thread is archived */
    @inline def archived: Boolean = selectDynamic[Boolean]("archived")

    @inline def withArchived(newValue: Boolean): ThreadMetadata = objWith(ThreadMetadata, "archived", newValue)

    /**
      * The thread will stop showing in the channel list after
      * auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      * 4320, 10080
      */
    @inline def autoArchiveDuration: Int = selectDynamic[Int]("auto_archive_duration")

    @inline def withAutoArchiveDuration(newValue: Int): ThreadMetadata =
      objWith(ThreadMetadata, "auto_archive_duration", newValue)

    /**
      * Timestamp when the thread's archive status was last changed, used for
      * calculating recent activity
      */
    @inline def archiveTimestamp: OffsetDateTime = selectDynamic[OffsetDateTime]("archive_timestamp")

    @inline def withArchiveTimestamp(newValue: OffsetDateTime): ThreadMetadata =
      objWith(ThreadMetadata, "archive_timestamp", newValue)

    /**
      * Whether the thread is locked; when a thread is locked, only users with
      * MANAGE_THREADS can unarchive it
      */
    @inline def locked: Boolean = selectDynamic[Boolean]("locked")

    @inline def withLocked(newValue: Boolean): ThreadMetadata = objWith(ThreadMetadata, "locked", newValue)

    /**
      * Whether non-moderators can add other non-moderators to a thread; only
      * available on private threads
      */
    @inline def invitable: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("invitable")

    @inline def withInvitable(newValue: UndefOr[Boolean]): ThreadMetadata =
      objWithUndef(ThreadMetadata, "invitable", newValue)

    /**
      * Timestamp when the thread was created; only populated for threads
      * created after 2022-01-09
      */
    @inline def createTimestamp: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("create_timestamp")

    @inline def withCreateTimestamp(newValue: UndefOr[OffsetDateTime]): ThreadMetadata =
      objWithUndef(ThreadMetadata, "create_timestamp", newValue)

    override def values: Seq[() => Any] = Seq(
      () => archived,
      () => autoArchiveDuration,
      () => archiveTimestamp,
      () => locked,
      () => invitable,
      () => createTimestamp
    )
  }
  object ThreadMetadata extends DiscordObjectCompanion[ThreadMetadata] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMetadata =
      new ThreadMetadata(json, cache)

    /**
      * @param archived
      *   Whether the thread is archived
      * @param autoArchiveDuration
      *   The thread will stop showing in the channel list after
      *   auto_archive_duration minutes of inactivity, can be set to: 60, 1440,
      *   4320, 10080
      * @param archiveTimestamp
      *   Timestamp when the thread's archive status was last changed, used for
      *   calculating recent activity
      * @param locked
      *   Whether the thread is locked; when a thread is locked, only users with
      *   MANAGE_THREADS can unarchive it
      * @param invitable
      *   Whether non-moderators can add other non-moderators to a thread; only
      *   available on private threads
      * @param createTimestamp
      *   Timestamp when the thread was created; only populated for threads
      *   created after 2022-01-09
      */
    def make20(
        archived: Boolean,
        autoArchiveDuration: Int,
        archiveTimestamp: OffsetDateTime,
        locked: Boolean,
        invitable: UndefOr[Boolean] = UndefOrUndefined(Some("invitable")),
        createTimestamp: UndefOr[OffsetDateTime] = UndefOrUndefined(Some("create_timestamp"))
    ): ThreadMetadata = makeRawFromFields(
      "archived"              := archived,
      "auto_archive_duration" := autoArchiveDuration,
      "archive_timestamp"     := archiveTimestamp,
      "locked"                := locked,
      "invitable"            :=? invitable,
      "create_timestamp"     :=? createTimestamp
    )
  }

  /**
    * A thread member object contains information about a user that has joined a
    * thread.
    */
  class ThreadMember(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the thread */
    @inline def id: UndefOr[ThreadChannelId] = selectDynamic[UndefOr[ThreadChannelId]]("id")

    @inline def withId(newValue: UndefOr[ThreadChannelId]): ThreadMember =
      objWithUndef(ThreadMember, "id", newValue)

    /** ID of the user */
    @inline def userId: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("user_id")

    @inline def withUserId(newValue: UndefOr[UserId]): ThreadMember = objWithUndef(ThreadMember, "user_id", newValue)

    /** Time the user last joined the thread */
    @inline def joinTimestamp: OffsetDateTime = selectDynamic[OffsetDateTime]("join_timestamp")

    @inline def withJoinTimestamp(newValue: OffsetDateTime): ThreadMember =
      objWith(ThreadMember, "join_timestamp", newValue)

    /** Any user-thread settings, currently only used for notifications */
    @inline def flags: Int = selectDynamic[Int]("flags")

    @inline def withFlags(newValue: Int): ThreadMember = objWith(ThreadMember, "flags", newValue)

    /** Additional information about the user */
    @inline def member: UndefOr[GuildMember] = selectDynamic[UndefOr[GuildMember]]("member")

    @inline def withMember(newValue: UndefOr[GuildMember]): ThreadMember =
      objWithUndef(ThreadMember, "member", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => userId, () => joinTimestamp, () => flags, () => member)
  }
  object ThreadMember extends DiscordObjectCompanion[ThreadMember] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMember = new ThreadMember(json, cache)

    /**
      * @param id
      *   ID of the thread
      * @param userId
      *   ID of the user
      * @param joinTimestamp
      *   Time the user last joined the thread
      * @param flags
      *   Any user-thread settings, currently only used for notifications
      * @param member
      *   Additional information about the user
      */
    def make20(
        id: UndefOr[ThreadChannelId] = UndefOrUndefined(Some("id")),
        userId: UndefOr[UserId] = UndefOrUndefined(Some("user_id")),
        joinTimestamp: OffsetDateTime,
        flags: Int,
        member: UndefOr[GuildMember] = UndefOrUndefined(Some("member"))
    ): ThreadMember = makeRawFromFields(
      "id"            :=? id,
      "user_id"       :=? userId,
      "join_timestamp" := joinTimestamp,
      "flags"          := flags,
      "member"        :=? member
    )
  }

  /**
    * An object that specifies the emoji to use as the default way to react to a
    * forum post. Exactly one of emoji_id and emoji_name must be set.
    */
  class DefaultReaction(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of a guild's custom emoji */
    @inline def emojiId: Option[EmojiId] = selectDynamic[Option[EmojiId]]("emoji_id")

    @inline def withEmojiId(newValue: Option[EmojiId]): DefaultReaction =
      objWith(DefaultReaction, "emoji_id", newValue)

    /** The unicode character of the emoji */
    @inline def emojiName: Option[String] = selectDynamic[Option[String]]("emoji_name")

    @inline def withEmojiName(newValue: Option[String]): DefaultReaction =
      objWith(DefaultReaction, "emoji_name", newValue)

    override def values: Seq[() => Any] = Seq(() => emojiId, () => emojiName)
  }
  object DefaultReaction extends DiscordObjectCompanion[DefaultReaction] {
    def makeRaw(json: Json, cache: Map[String, Any]): DefaultReaction =
      new DefaultReaction(json, cache)

    /**
      * @param emojiId
      *   The id of a guild's custom emoji
      * @param emojiName
      *   The unicode character of the emoji
      */
    def make20(emojiId: Option[EmojiId], emojiName: Option[String]): DefaultReaction =
      makeRawFromFields("emoji_id" := emojiId, "emoji_name" := emojiName)
  }

  /**
    * An object that represents a tag that is able to be applied to a thread in
    * a GUILD_FORUM channel.
    */
  class ForumTag(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of the tag */
    @inline def id: Snowflake[ForumTag] = selectDynamic[Snowflake[ForumTag]]("id")

    @inline def withId(newValue: Snowflake[ForumTag]): ForumTag = objWith(ForumTag, "id", newValue)

    /** The name of the tag (0-20 characters) */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): ForumTag = objWith(ForumTag, "name", newValue)

    /**
      * Whether this tag can only be added to or removed from threads by a
      * member with the MANAGE_THREADS permission
      */
    @inline def moderated: Boolean = selectDynamic[Boolean]("moderated")

    @inline def withModerated(newValue: Boolean): ForumTag = objWith(ForumTag, "moderated", newValue)

    /** The id of a guild's custom emoji */
    @inline def emojiId: Option[EmojiId] = selectDynamic[Option[EmojiId]]("emoji_id")

    @inline def withEmojiId(newValue: Option[EmojiId]): ForumTag = objWith(ForumTag, "emoji_id", newValue)

    /** The unicode character of the emoji */
    @inline def emojiName: Option[String] = selectDynamic[Option[String]]("emoji_name")

    @inline def withEmojiName(newValue: Option[String]): ForumTag = objWith(ForumTag, "emoji_name", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => name, () => moderated, () => emojiId, () => emojiName)
  }
  object ForumTag extends DiscordObjectCompanion[ForumTag] {
    def makeRaw(json: Json, cache: Map[String, Any]): ForumTag = new ForumTag(json, cache)

    /**
      * @param id
      *   The id of the tag
      * @param name
      *   The name of the tag (0-20 characters)
      * @param moderated
      *   Whether this tag can only be added to or removed from threads by a
      *   member with the MANAGE_THREADS permission
      * @param emojiId
      *   The id of a guild's custom emoji
      * @param emojiName
      *   The unicode character of the emoji
      */
    def make20(
        id: Snowflake[ForumTag],
        name: String,
        moderated: Boolean,
        emojiId: Option[EmojiId],
        emojiName: Option[String]
    ): ForumTag = makeRawFromFields(
      "id"         := id,
      "name"       := name,
      "moderated"  := moderated,
      "emoji_id"   := emojiId,
      "emoji_name" := emojiName
    )
  }
}

/** Represents a message sent in a channel within Discord. */
class Message(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Id of the message */
  @inline def id: MessageId = selectDynamic[MessageId]("id")

  @inline def withId(newValue: MessageId): Message = objWith(Message, "id", newValue)

  /** Id of the channel the message was sent in */
  @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

  @inline def withChannelId(newValue: TextChannelId): Message = objWith(Message, "channel_id", newValue)

  /**
    * The author of this message (not guaranteed to be a valid user, see below)
    */
  @inline def author: MessageAuthor = selectDynamic[MessageAuthor]("author")

  @inline def withAuthor(newValue: MessageAuthor): Message = objWith(Message, "author", newValue)

  /** Contents of the message */
  @inline def content: String = selectDynamic[String]("content")

  @inline def withContent(newValue: String): Message = objWith(Message, "content", newValue)

  /** When this message was sent */
  @inline def timestamp: OffsetDateTime = selectDynamic[OffsetDateTime]("timestamp")

  @inline def withTimestamp(newValue: OffsetDateTime): Message = objWith(Message, "timestamp", newValue)

  /** When this message was edited (or null if never) */
  @inline def editedTimestamp: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("edited_timestamp")

  @inline def withEditedTimestamp(newValue: Option[OffsetDateTime]): Message =
    objWith(Message, "edited_timestamp", newValue)

  /** Whether this was a TTS message */
  @inline def tts: Boolean = selectDynamic[Boolean]("tts")

  @inline def withTts(newValue: Boolean): Message = objWith(Message, "tts", newValue)

  /** Whether this message mentions everyone */
  @inline def mentionEveryone: Boolean = selectDynamic[Boolean]("mention_everyone")

  @inline def withMentionEveryone(newValue: Boolean): Message = objWith(Message, "mention_everyone", newValue)

  /** Users specifically mentioned in the message */
  @inline def mentions: Seq[User] = selectDynamic[Seq[User]]("mentions")

  @inline def withMentions(newValue: Seq[User]): Message = objWith(Message, "mentions", newValue)

  /** Roles specifically mentioned in this message */
  @inline def mentionRoles: Seq[RoleId] = selectDynamic[Seq[RoleId]]("mention_roles")

  @inline def withMentionRoles(newValue: Seq[RoleId]): Message = objWith(Message, "mention_roles", newValue)

  /** Channels specifically mentioned in this message */
  @inline def mentionChannels: UndefOr[Seq[Message.ChannelMention]] =
    selectDynamic[UndefOr[Seq[Message.ChannelMention]]]("mention_channels")

  @inline def withMentionChannels(newValue: UndefOr[Seq[Message.ChannelMention]]): Message =
    objWithUndef(Message, "mention_channels", newValue)

  /** Any attached files */
  @inline def attachments: Seq[Attachment] = selectDynamic[Seq[Attachment]]("attachments")

  @inline def withAttachments(newValue: Seq[Attachment]): Message = objWith(Message, "attachments", newValue)

  /** Any embedded content */
  @inline def embeds: Seq[Embed] = selectDynamic[Seq[Embed]]("embeds")

  @inline def withEmbeds(newValue: Seq[Embed]): Message = objWith(Message, "embeds", newValue)

  /** Reactions to the message */
  @inline def reactions: UndefOr[Seq[Reaction]] = selectDynamic[UndefOr[Seq[Reaction]]]("reactions")

  @inline def withReactions(newValue: UndefOr[Seq[Reaction]]): Message =
    objWithUndef(Message, "reactions", newValue)

  /** Used for validating a message was sent */
  @inline def nonce: UndefOr[IntOrString] = selectDynamic[UndefOr[IntOrString]]("nonce")

  @inline def withNonce(newValue: UndefOr[IntOrString]): Message = objWithUndef(Message, "nonce", newValue)

  /** Whether this message is pinned */
  @inline def pinned: Boolean = selectDynamic[Boolean]("pinned")

  @inline def withPinned(newValue: Boolean): Message = objWith(Message, "pinned", newValue)

  /** If the message is generated by a webhook, this is the webhook's id */
  @inline def webhookId: UndefOr[WebhookId] = selectDynamic[UndefOr[WebhookId]]("webhook_id")

  @inline def withWebhookId(newValue: UndefOr[WebhookId]): Message = objWithUndef(Message, "webhook_id", newValue)

  /** Type of message */
  @inline def tpe: Message.MessageType = selectDynamic[Message.MessageType]("type")

  @inline def withTpe(newValue: Message.MessageType): Message = objWith(Message, "type", newValue)

  /** Sent with Rich Presence-related chat embeds */
  @inline def activity: UndefOr[Message.MessageActivity] = selectDynamic[UndefOr[Message.MessageActivity]]("activity")

  @inline def withActivity(newValue: UndefOr[Message.MessageActivity]): Message =
    objWithUndef(Message, "activity", newValue)

  /** Sent with Rich Presence-related chat embeds */
  @inline def application: UndefOr[Message.MessageApplicationStub] =
    selectDynamic[UndefOr[Message.MessageApplicationStub]]("application")

  @inline def withApplication(newValue: UndefOr[Message.MessageApplicationStub]): Message =
    objWithUndef(Message, "application", newValue)

  /**
    * If the message is an Interaction or application-owned webhook, this is the
    * id of the application
    */
  @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

  @inline def withApplicationId(newValue: UndefOr[ApplicationId]): Message =
    objWithUndef(Message, "application_id", newValue)

  /**
    * Data showing the source of a crosspost, channel follow add, pin, or reply
    * message
    */
  @inline def messageReference: UndefOr[MessageReference] =
    selectDynamic[UndefOr[MessageReference]]("message_reference")

  @inline def withMessageReference(newValue: UndefOr[MessageReference]): Message =
    objWithUndef(Message, "message_reference", newValue)

  /** Message flags combined as a bitfield */
  @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

  @inline def withFlags(newValue: UndefOr[Message.MessageFlags]): Message =
    objWithUndef(Message, "flags", newValue)

  /** The message associated with the message_reference */
  @inline def referencedMessage: JsonOption[Message] = selectDynamic[JsonOption[Message]]("referenced_message")

  @inline def withReferencedMessage(newValue: JsonOption[Message]): Message =
    objWithUndef(Message, "referenced_message", newValue)

  /** Sent if the message is a response to an Interaction */
  @inline def interaction: UndefOr[Message.MessageInteractionStub] =
    selectDynamic[UndefOr[Message.MessageInteractionStub]]("interaction")

  @inline def withInteraction(newValue: UndefOr[Message.MessageInteractionStub]): Message =
    objWithUndef(Message, "interaction", newValue)

  /**
    * The thread that was started from this message, includes thread member
    * object
    */
  @inline def thread: UndefOr[Channel] = selectDynamic[UndefOr[Channel]]("thread")

  @inline def withThread(newValue: UndefOr[Channel]): Message = objWithUndef(Message, "thread", newValue)

  /**
    * Sent if the message contains components like buttons, action rows, or
    * other interactive components
    */
  @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

  @inline def withComponents(newValue: UndefOr[Seq[Component]]): Message =
    objWithUndef(Message, "components", newValue)

  /** Sent if the message contains stickers */
  @inline def stickerItems: UndefOr[Seq[Sticker.StickerItem]] =
    selectDynamic[UndefOr[Seq[Sticker.StickerItem]]]("sticker_items")

  @inline def withStickerItems(newValue: UndefOr[Seq[Sticker.StickerItem]]): Message =
    objWithUndef(Message, "sticker_items", newValue)

  /**
    * A generally increasing integer (there may be gaps or duplicates) that
    * represents the approximate position of the message in a thread, it can be
    * used to estimate the relative position of the message in a thread in
    * company with total_message_sent on parent thread
    */
  @inline def position: UndefOr[Int] = selectDynamic[UndefOr[Int]]("position")

  @inline def withPosition(newValue: UndefOr[Int]): Message = objWithUndef(Message, "position", newValue)

  /**
    * Data of the role subscription purchase or renewal that prompted this
    * ROLE_SUBSCRIPTION_PURCHASE message
    */
  @inline def roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] =
    selectDynamic[UndefOr[Message.RoleSubscriptionData]]("role_subscription_data")

  @inline def withRoleSubscriptionData(newValue: UndefOr[Message.RoleSubscriptionData]): Message =
    objWithUndef(Message, "role_subscription_data", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => channelId,
    () => author,
    () => content,
    () => timestamp,
    () => editedTimestamp,
    () => tts,
    () => mentionEveryone,
    () => mentions,
    () => mentionRoles,
    () => mentionChannels,
    () => attachments,
    () => embeds,
    () => reactions,
    () => nonce,
    () => pinned,
    () => webhookId,
    () => tpe,
    () => activity,
    () => application,
    () => applicationId,
    () => messageReference,
    () => flags,
    () => referencedMessage,
    () => interaction,
    () => thread,
    () => components,
    () => stickerItems,
    () => position,
    () => roleSubscriptionData
  )
}
object Message extends DiscordObjectCompanion[Message] {
  def makeRaw(json: Json, cache: Map[String, Any]): Message = new Message(json, cache)

  /**
    * @param id
    *   Id of the message
    * @param channelId
    *   Id of the channel the message was sent in
    * @param author
    *   The author of this message (not guaranteed to be a valid user, see
    *   below)
    * @param content
    *   Contents of the message
    * @param timestamp
    *   When this message was sent
    * @param editedTimestamp
    *   When this message was edited (or null if never)
    * @param tts
    *   Whether this was a TTS message
    * @param mentionEveryone
    *   Whether this message mentions everyone
    * @param mentions
    *   Users specifically mentioned in the message
    * @param mentionRoles
    *   Roles specifically mentioned in this message
    * @param mentionChannels
    *   Channels specifically mentioned in this message
    * @param attachments
    *   Any attached files
    * @param embeds
    *   Any embedded content
    * @param reactions
    *   Reactions to the message
    * @param nonce
    *   Used for validating a message was sent
    * @param pinned
    *   Whether this message is pinned
    * @param webhookId
    *   If the message is generated by a webhook, this is the webhook's id
    * @param tpe
    *   Type of message
    * @param activity
    *   Sent with Rich Presence-related chat embeds
    * @param application
    *   Sent with Rich Presence-related chat embeds
    * @param applicationId
    *   If the message is an Interaction or application-owned webhook, this is
    *   the id of the application
    * @param messageReference
    *   Data showing the source of a crosspost, channel follow add, pin, or
    *   reply message
    * @param flags
    *   Message flags combined as a bitfield
    * @param referencedMessage
    *   The message associated with the message_reference
    * @param interaction
    *   Sent if the message is a response to an Interaction
    * @param thread
    *   The thread that was started from this message, includes thread member
    *   object
    * @param components
    *   Sent if the message contains components like buttons, action rows, or
    *   other interactive components
    * @param stickerItems
    *   Sent if the message contains stickers
    * @param position
    *   A generally increasing integer (there may be gaps or duplicates) that
    *   represents the approximate position of the message in a thread, it can
    *   be used to estimate the relative position of the message in a thread in
    *   company with total_message_sent on parent thread
    * @param roleSubscriptionData
    *   Data of the role subscription purchase or renewal that prompted this
    *   ROLE_SUBSCRIPTION_PURCHASE message
    */
  def make20(
      id: MessageId,
      channelId: TextChannelId,
      author: MessageAuthor,
      content: String,
      timestamp: OffsetDateTime,
      editedTimestamp: Option[OffsetDateTime],
      tts: Boolean,
      mentionEveryone: Boolean,
      mentions: Seq[User],
      mentionRoles: Seq[RoleId],
      mentionChannels: UndefOr[Seq[Message.ChannelMention]] = UndefOrUndefined(Some("mention_channels")),
      attachments: Seq[Attachment],
      embeds: Seq[Embed],
      reactions: UndefOr[Seq[Reaction]] = UndefOrUndefined(Some("reactions")),
      nonce: UndefOr[IntOrString] = UndefOrUndefined(Some("nonce")),
      pinned: Boolean,
      webhookId: UndefOr[WebhookId] = UndefOrUndefined(Some("webhook_id")),
      tpe: Message.MessageType,
      activity: UndefOr[Message.MessageActivity] = UndefOrUndefined(Some("activity")),
      application: UndefOr[Message.MessageApplicationStub] = UndefOrUndefined(Some("application")),
      applicationId: UndefOr[ApplicationId] = UndefOrUndefined(Some("application_id")),
      messageReference: UndefOr[MessageReference] = UndefOrUndefined(Some("message_reference")),
      flags: UndefOr[Message.MessageFlags] = UndefOrUndefined(Some("flags")),
      referencedMessage: JsonOption[Message] = JsonUndefined(Some("referenced_message")),
      interaction: UndefOr[Message.MessageInteractionStub] = UndefOrUndefined(Some("interaction")),
      thread: UndefOr[Channel] = UndefOrUndefined(Some("thread")),
      components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
      stickerItems: UndefOr[Seq[Sticker.StickerItem]] = UndefOrUndefined(Some("sticker_items")),
      position: UndefOr[Int] = UndefOrUndefined(Some("position")),
      roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] = UndefOrUndefined(Some("role_subscription_data"))
  ): Message = makeRawFromFields(
    "id"                      := id,
    "channel_id"              := channelId,
    "author"                  := author,
    "content"                 := content,
    "timestamp"               := timestamp,
    "edited_timestamp"        := editedTimestamp,
    "tts"                     := tts,
    "mention_everyone"        := mentionEveryone,
    "mentions"                := mentions,
    "mention_roles"           := mentionRoles,
    "mention_channels"       :=? mentionChannels,
    "attachments"             := attachments,
    "embeds"                  := embeds,
    "reactions"              :=? reactions,
    "nonce"                  :=? nonce,
    "pinned"                  := pinned,
    "webhook_id"             :=? webhookId,
    "type"                    := tpe,
    "activity"               :=? activity,
    "application"            :=? application,
    "application_id"         :=? applicationId,
    "message_reference"      :=? messageReference,
    "flags"                  :=? flags,
    "referenced_message"     :=? referencedMessage,
    "interaction"            :=? interaction,
    "thread"                 :=? thread,
    "components"             :=? components,
    "sticker_items"          :=? stickerItems,
    "position"               :=? position,
    "role_subscription_data" :=? roleSubscriptionData
  )

  /** Represents a message sent in a channel within Discord. */
  class Partial(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Id of the message */
    @inline def id: MessageId = selectDynamic[MessageId]("id")

    @inline def withId(newValue: MessageId): Partial = objWith(Partial, "id", newValue)

    /** Id of the channel the message was sent in */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): Partial = objWith(Partial, "channel_id", newValue)

    /**
      * The author of this message (not guaranteed to be a valid user, see
      * below)
      */
    @inline def author: UndefOr[MessageAuthor] = selectDynamic[UndefOr[MessageAuthor]]("author")

    @inline def withAuthor(newValue: UndefOr[MessageAuthor]): Partial =
      objWithUndef(Partial, "author", newValue)

    /** Contents of the message */
    @inline def content: UndefOr[String] = selectDynamic[UndefOr[String]]("content")

    @inline def withContent(newValue: UndefOr[String]): Partial = objWithUndef(Partial, "content", newValue)

    /** When this message was sent */
    @inline def timestamp: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("timestamp")

    @inline def withTimestamp(newValue: UndefOr[OffsetDateTime]): Partial =
      objWithUndef(Partial, "timestamp", newValue)

    /** When this message was edited (or null if never) */
    @inline def editedTimestamp: JsonOption[OffsetDateTime] =
      selectDynamic[JsonOption[OffsetDateTime]]("edited_timestamp")

    @inline def withEditedTimestamp(newValue: JsonOption[OffsetDateTime]): Partial =
      objWithUndef(Partial, "edited_timestamp", newValue)

    /** Whether this was a TTS message */
    @inline def tts: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("tts")

    @inline def withTts(newValue: UndefOr[Boolean]): Partial = objWithUndef(Partial, "tts", newValue)

    /** Whether this message mentions everyone */
    @inline def mentionEveryone: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("mention_everyone")

    @inline def withMentionEveryone(newValue: UndefOr[Boolean]): Partial =
      objWithUndef(Partial, "mention_everyone", newValue)

    /** Users specifically mentioned in the message */
    @inline def mentions: UndefOr[Seq[User]] = selectDynamic[UndefOr[Seq[User]]]("mentions")

    @inline def withMentions(newValue: UndefOr[Seq[User]]): Partial = objWithUndef(Partial, "mentions", newValue)

    /** Roles specifically mentioned in this message */
    @inline def mentionRoles: UndefOr[Seq[RoleId]] = selectDynamic[UndefOr[Seq[RoleId]]]("mention_roles")

    @inline def withMentionRoles(newValue: UndefOr[Seq[RoleId]]): Partial =
      objWithUndef(Partial, "mention_roles", newValue)

    /** Channels specifically mentioned in this message */
    @inline def mentionChannels: UndefOr[Seq[Message.ChannelMention]] =
      selectDynamic[UndefOr[Seq[Message.ChannelMention]]]("mention_channels")

    @inline def withMentionChannels(newValue: UndefOr[Seq[Message.ChannelMention]]): Partial =
      objWithUndef(Partial, "mention_channels", newValue)

    /** Any attached files */
    @inline def attachments: UndefOr[Seq[Attachment]] = selectDynamic[UndefOr[Seq[Attachment]]]("attachments")

    @inline def withAttachments(newValue: UndefOr[Seq[Attachment]]): Partial =
      objWithUndef(Partial, "attachments", newValue)

    /** Any embedded content */
    @inline def embeds: UndefOr[Seq[Embed]] = selectDynamic[UndefOr[Seq[Embed]]]("embeds")

    @inline def withEmbeds(newValue: UndefOr[Seq[Embed]]): Partial = objWithUndef(Partial, "embeds", newValue)

    /** Reactions to the message */
    @inline def reactions: UndefOr[Seq[Reaction]] = selectDynamic[UndefOr[Seq[Reaction]]]("reactions")

    @inline def withReactions(newValue: UndefOr[Seq[Reaction]]): Partial =
      objWithUndef(Partial, "reactions", newValue)

    /** Used for validating a message was sent */
    @inline def nonce: UndefOr[IntOrString] = selectDynamic[UndefOr[IntOrString]]("nonce")

    @inline def withNonce(newValue: UndefOr[IntOrString]): Partial = objWithUndef(Partial, "nonce", newValue)

    /** Whether this message is pinned */
    @inline def pinned: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("pinned")

    @inline def withPinned(newValue: UndefOr[Boolean]): Partial = objWithUndef(Partial, "pinned", newValue)

    /** If the message is generated by a webhook, this is the webhook's id */
    @inline def webhookId: UndefOr[WebhookId] = selectDynamic[UndefOr[WebhookId]]("webhook_id")

    @inline def withWebhookId(newValue: UndefOr[WebhookId]): Partial =
      objWithUndef(Partial, "webhook_id", newValue)

    /** Type of message */
    @inline def tpe: UndefOr[Message.MessageType] = selectDynamic[UndefOr[Message.MessageType]]("type")

    @inline def withTpe(newValue: UndefOr[Message.MessageType]): Partial =
      objWithUndef(Partial, "type", newValue)

    /** Sent with Rich Presence-related chat embeds */
    @inline def activity: UndefOr[Message.MessageActivity] = selectDynamic[UndefOr[Message.MessageActivity]]("activity")

    @inline def withActivity(newValue: UndefOr[Message.MessageActivity]): Partial =
      objWithUndef(Partial, "activity", newValue)

    /** Sent with Rich Presence-related chat embeds */
    @inline def application: UndefOr[Message.MessageApplicationStub] =
      selectDynamic[UndefOr[Message.MessageApplicationStub]]("application")

    @inline def withApplication(newValue: UndefOr[Message.MessageApplicationStub]): Partial =
      objWithUndef(Partial, "application", newValue)

    /**
      * If the message is an Interaction or application-owned webhook, this is
      * the id of the application
      */
    @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

    @inline def withApplicationId(newValue: UndefOr[ApplicationId]): Partial =
      objWithUndef(Partial, "application_id", newValue)

    /**
      * Data showing the source of a crosspost, channel follow add, pin, or
      * reply message
      */
    @inline def messageReference: UndefOr[MessageReference] =
      selectDynamic[UndefOr[MessageReference]]("message_reference")

    @inline def withMessageReference(newValue: UndefOr[MessageReference]): Partial =
      objWithUndef(Partial, "message_reference", newValue)

    /** Message flags combined as a bitfield */
    @inline def flags: UndefOr[Message.MessageFlags] = selectDynamic[UndefOr[Message.MessageFlags]]("flags")

    @inline def withFlags(newValue: UndefOr[Message.MessageFlags]): Partial =
      objWithUndef(Partial, "flags", newValue)

    /** The message associated with the message_reference */
    @inline def referencedMessage: JsonOption[Message] = selectDynamic[JsonOption[Message]]("referenced_message")

    @inline def withReferencedMessage(newValue: JsonOption[Message]): Partial =
      objWithUndef(Partial, "referenced_message", newValue)

    /** Sent if the message is a response to an Interaction */
    @inline def interaction: UndefOr[Message.MessageInteractionStub] =
      selectDynamic[UndefOr[Message.MessageInteractionStub]]("interaction")

    @inline def withInteraction(newValue: UndefOr[Message.MessageInteractionStub]): Partial =
      objWithUndef(Partial, "interaction", newValue)

    /**
      * The thread that was started from this message, includes thread member
      * object
      */
    @inline def thread: UndefOr[Channel] = selectDynamic[UndefOr[Channel]]("thread")

    @inline def withThread(newValue: UndefOr[Channel]): Partial = objWithUndef(Partial, "thread", newValue)

    /**
      * Sent if the message contains components like buttons, action rows, or
      * other interactive components
      */
    @inline def components: UndefOr[Seq[Component]] = selectDynamic[UndefOr[Seq[Component]]]("components")

    @inline def withComponents(newValue: UndefOr[Seq[Component]]): Partial =
      objWithUndef(Partial, "components", newValue)

    /** Sent if the message contains stickers */
    @inline def stickerItems: UndefOr[Seq[Sticker.StickerItem]] =
      selectDynamic[UndefOr[Seq[Sticker.StickerItem]]]("sticker_items")

    @inline def withStickerItems(newValue: UndefOr[Seq[Sticker.StickerItem]]): Partial =
      objWithUndef(Partial, "sticker_items", newValue)

    /**
      * A generally increasing integer (there may be gaps or duplicates) that
      * represents the approximate position of the message in a thread, it can
      * be used to estimate the relative position of the message in a thread in
      * company with total_message_sent on parent thread
      */
    @inline def position: UndefOr[Int] = selectDynamic[UndefOr[Int]]("position")

    @inline def withPosition(newValue: UndefOr[Int]): Partial = objWithUndef(Partial, "position", newValue)

    /**
      * Data of the role subscription purchase or renewal that prompted this
      * ROLE_SUBSCRIPTION_PURCHASE message
      */
    @inline def roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] =
      selectDynamic[UndefOr[Message.RoleSubscriptionData]]("role_subscription_data")

    @inline def withRoleSubscriptionData(newValue: UndefOr[Message.RoleSubscriptionData]): Partial =
      objWithUndef(Partial, "role_subscription_data", newValue)

    override def values: Seq[() => Any] = Seq(
      () => id,
      () => channelId,
      () => author,
      () => content,
      () => timestamp,
      () => editedTimestamp,
      () => tts,
      () => mentionEveryone,
      () => mentions,
      () => mentionRoles,
      () => mentionChannels,
      () => attachments,
      () => embeds,
      () => reactions,
      () => nonce,
      () => pinned,
      () => webhookId,
      () => tpe,
      () => activity,
      () => application,
      () => applicationId,
      () => messageReference,
      () => flags,
      () => referencedMessage,
      () => interaction,
      () => thread,
      () => components,
      () => stickerItems,
      () => position,
      () => roleSubscriptionData
    )
  }
  object Partial extends DiscordObjectCompanion[Partial] {
    def makeRaw(json: Json, cache: Map[String, Any]): Partial = new Partial(json, cache)

    /**
      * @param id
      *   Id of the message
      * @param channelId
      *   Id of the channel the message was sent in
      * @param author
      *   The author of this message (not guaranteed to be a valid user, see
      *   below)
      * @param content
      *   Contents of the message
      * @param timestamp
      *   When this message was sent
      * @param editedTimestamp
      *   When this message was edited (or null if never)
      * @param tts
      *   Whether this was a TTS message
      * @param mentionEveryone
      *   Whether this message mentions everyone
      * @param mentions
      *   Users specifically mentioned in the message
      * @param mentionRoles
      *   Roles specifically mentioned in this message
      * @param mentionChannels
      *   Channels specifically mentioned in this message
      * @param attachments
      *   Any attached files
      * @param embeds
      *   Any embedded content
      * @param reactions
      *   Reactions to the message
      * @param nonce
      *   Used for validating a message was sent
      * @param pinned
      *   Whether this message is pinned
      * @param webhookId
      *   If the message is generated by a webhook, this is the webhook's id
      * @param tpe
      *   Type of message
      * @param activity
      *   Sent with Rich Presence-related chat embeds
      * @param application
      *   Sent with Rich Presence-related chat embeds
      * @param applicationId
      *   If the message is an Interaction or application-owned webhook, this is
      *   the id of the application
      * @param messageReference
      *   Data showing the source of a crosspost, channel follow add, pin, or
      *   reply message
      * @param flags
      *   Message flags combined as a bitfield
      * @param referencedMessage
      *   The message associated with the message_reference
      * @param interaction
      *   Sent if the message is a response to an Interaction
      * @param thread
      *   The thread that was started from this message, includes thread member
      *   object
      * @param components
      *   Sent if the message contains components like buttons, action rows, or
      *   other interactive components
      * @param stickerItems
      *   Sent if the message contains stickers
      * @param position
      *   A generally increasing integer (there may be gaps or duplicates) that
      *   represents the approximate position of the message in a thread, it can
      *   be used to estimate the relative position of the message in a thread
      *   in company with total_message_sent on parent thread
      * @param roleSubscriptionData
      *   Data of the role subscription purchase or renewal that prompted this
      *   ROLE_SUBSCRIPTION_PURCHASE message
      */
    def make20(
        id: MessageId,
        channelId: TextChannelId,
        author: UndefOr[MessageAuthor] = UndefOrUndefined(Some("author")),
        content: UndefOr[String] = UndefOrUndefined(Some("content")),
        timestamp: UndefOr[OffsetDateTime] = UndefOrUndefined(Some("timestamp")),
        editedTimestamp: JsonOption[OffsetDateTime] = JsonUndefined(Some("edited_timestamp")),
        tts: UndefOr[Boolean] = UndefOrUndefined(Some("tts")),
        mentionEveryone: UndefOr[Boolean] = UndefOrUndefined(Some("mention_everyone")),
        mentions: UndefOr[Seq[User]] = UndefOrUndefined(Some("mentions")),
        mentionRoles: UndefOr[Seq[RoleId]] = UndefOrUndefined(Some("mention_roles")),
        mentionChannels: UndefOr[Seq[Message.ChannelMention]] = UndefOrUndefined(Some("mention_channels")),
        attachments: UndefOr[Seq[Attachment]] = UndefOrUndefined(Some("attachments")),
        embeds: UndefOr[Seq[Embed]] = UndefOrUndefined(Some("embeds")),
        reactions: UndefOr[Seq[Reaction]] = UndefOrUndefined(Some("reactions")),
        nonce: UndefOr[IntOrString] = UndefOrUndefined(Some("nonce")),
        pinned: UndefOr[Boolean] = UndefOrUndefined(Some("pinned")),
        webhookId: UndefOr[WebhookId] = UndefOrUndefined(Some("webhook_id")),
        tpe: UndefOr[Message.MessageType] = UndefOrUndefined(Some("tpe")),
        activity: UndefOr[Message.MessageActivity] = UndefOrUndefined(Some("activity")),
        application: UndefOr[Message.MessageApplicationStub] = UndefOrUndefined(Some("application")),
        applicationId: UndefOr[ApplicationId] = UndefOrUndefined(Some("application_id")),
        messageReference: UndefOr[MessageReference] = UndefOrUndefined(Some("message_reference")),
        flags: UndefOr[Message.MessageFlags] = UndefOrUndefined(Some("flags")),
        referencedMessage: JsonOption[Message] = JsonUndefined(Some("referenced_message")),
        interaction: UndefOr[Message.MessageInteractionStub] = UndefOrUndefined(Some("interaction")),
        thread: UndefOr[Channel] = UndefOrUndefined(Some("thread")),
        components: UndefOr[Seq[Component]] = UndefOrUndefined(Some("components")),
        stickerItems: UndefOr[Seq[Sticker.StickerItem]] = UndefOrUndefined(Some("sticker_items")),
        position: UndefOr[Int] = UndefOrUndefined(Some("position")),
        roleSubscriptionData: UndefOr[Message.RoleSubscriptionData] = UndefOrUndefined(Some("role_subscription_data"))
    ): Partial = makeRawFromFields(
      "id"                      := id,
      "channel_id"              := channelId,
      "author"                 :=? author,
      "content"                :=? content,
      "timestamp"              :=? timestamp,
      "edited_timestamp"       :=? editedTimestamp,
      "tts"                    :=? tts,
      "mention_everyone"       :=? mentionEveryone,
      "mentions"               :=? mentions,
      "mention_roles"          :=? mentionRoles,
      "mention_channels"       :=? mentionChannels,
      "attachments"            :=? attachments,
      "embeds"                 :=? embeds,
      "reactions"              :=? reactions,
      "nonce"                  :=? nonce,
      "pinned"                 :=? pinned,
      "webhook_id"             :=? webhookId,
      "type"                   :=? tpe,
      "activity"               :=? activity,
      "application"            :=? application,
      "application_id"         :=? applicationId,
      "message_reference"      :=? messageReference,
      "flags"                  :=? flags,
      "referenced_message"     :=? referencedMessage,
      "interaction"            :=? interaction,
      "thread"                 :=? thread,
      "components"             :=? components,
      "sticker_items"          :=? stickerItems,
      "position"               :=? position,
      "role_subscription_data" :=? roleSubscriptionData
    )
  }

  sealed case class MessageType private (value: Int) extends DiscordEnum[Int]
  object MessageType extends DiscordEnumCompanion[Int, MessageType] {
    val DEFAULT: MessageType = MessageType(0)

    val RECIPIENT_ADD: MessageType = MessageType(1)

    val RECIPIENT_REMOVE: MessageType = MessageType(2)

    val CALL: MessageType = MessageType(3)

    val CHANNEL_NAME_CHANGE: MessageType = MessageType(4)

    val CHANNEL_ICON_CHANGE: MessageType = MessageType(5)

    val CHANNEL_PINNED_MESSAGE: MessageType = MessageType(6)

    val USER_JOIN: MessageType = MessageType(7)

    val GUILD_BOOST: MessageType = MessageType(8)

    val GUILD_BOOST_TIER_1: MessageType = MessageType(9)

    val GUILD_BOOST_TIER_2: MessageType = MessageType(10)

    val GUILD_BOOST_TIER_3: MessageType = MessageType(11)

    val CHANNEL_FOLLOW_ADD: MessageType = MessageType(12)

    val GUILD_DISCOVERY_DISQUALIFIED: MessageType = MessageType(14)

    val GUILD_DISCOVERY_REQUALIFIED: MessageType = MessageType(15)

    val GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING: MessageType = MessageType(16)

    val GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING: MessageType = MessageType(17)

    val THREAD_CREATED: MessageType = MessageType(18)

    val REPLY: MessageType = MessageType(19)

    val CHAT_INPUT_COMMAND: MessageType = MessageType(20)

    val THREAD_STARTER_MESSAGE: MessageType = MessageType(21)

    val GUILD_INVITE_REMINDER: MessageType = MessageType(22)

    val CONTEXT_MENU_COMMAND: MessageType = MessageType(23)

    val AUTO_MODERATION_ACTION: MessageType = MessageType(24)

    val ROLE_SUBSCRIPTION_PURCHASE: MessageType = MessageType(25)

    val INTERACTION_PREMIUM_UPSELL: MessageType = MessageType(26)

    val STAGE_START: MessageType = MessageType(27)

    val STAGE_END: MessageType = MessageType(28)

    val STAGE_SPEAKER: MessageType = MessageType(29)

    val STAGE_TOPIC: MessageType = MessageType(31)

    val GUILD_APPLICATION_PREMIUM_SUBSCRIPTION: MessageType = MessageType(32)

    def unknown(value: Int): MessageType = new MessageType(value)

    val values: Seq[MessageType] = Seq(
      DEFAULT,
      RECIPIENT_ADD,
      RECIPIENT_REMOVE,
      CALL,
      CHANNEL_NAME_CHANGE,
      CHANNEL_ICON_CHANGE,
      CHANNEL_PINNED_MESSAGE,
      USER_JOIN,
      GUILD_BOOST,
      GUILD_BOOST_TIER_1,
      GUILD_BOOST_TIER_2,
      GUILD_BOOST_TIER_3,
      CHANNEL_FOLLOW_ADD,
      GUILD_DISCOVERY_DISQUALIFIED,
      GUILD_DISCOVERY_REQUALIFIED,
      GUILD_DISCOVERY_GRACE_PERIOD_INITIAL_WARNING,
      GUILD_DISCOVERY_GRACE_PERIOD_FINAL_WARNING,
      THREAD_CREATED,
      REPLY,
      CHAT_INPUT_COMMAND,
      THREAD_STARTER_MESSAGE,
      GUILD_INVITE_REMINDER,
      CONTEXT_MENU_COMMAND,
      AUTO_MODERATION_ACTION,
      ROLE_SUBSCRIPTION_PURCHASE,
      INTERACTION_PREMIUM_UPSELL,
      STAGE_START,
      STAGE_END,
      STAGE_SPEAKER,
      STAGE_TOPIC,
      GUILD_APPLICATION_PREMIUM_SUBSCRIPTION
    )

    implicit class MessageTypeBitFieldOps(private val here: MessageType) extends AnyVal {

      def toInt: Int = here.value

      def ++(there: MessageType): MessageType = MessageType(here.value | there.value)

      def --(there: MessageType): MessageType = MessageType(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }

  class MessageInteractionStub(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    override def values: Seq[() => Any] = Seq()
  }
  object MessageInteractionStub extends DiscordObjectCompanion[MessageInteractionStub] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageInteractionStub =
      new MessageInteractionStub(json, cache)

    def make20(): MessageInteractionStub = makeRawFromFields()
  }

  class MessageApplicationStub(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    override def values: Seq[() => Any] = Seq()
  }
  object MessageApplicationStub extends DiscordObjectCompanion[MessageApplicationStub] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageApplicationStub =
      new MessageApplicationStub(json, cache)

    def make20(): MessageApplicationStub = makeRawFromFields()
  }

  class ChannelMention(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Id of the channel */
    @inline def id: TextGuildChannelId = selectDynamic[TextGuildChannelId]("id")

    @inline def withId(newValue: TextGuildChannelId): ChannelMention =
      objWith(ChannelMention, "id", newValue)

    /** Id of the guild containing the channel */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): ChannelMention = objWith(ChannelMention, "guild_id", newValue)

    /** The type of channel */
    @inline def tpe: Channel.ChannelType = selectDynamic[Channel.ChannelType]("type")

    @inline def withTpe(newValue: Channel.ChannelType): ChannelMention =
      objWith(ChannelMention, "type", newValue)

    /** The name of the channel */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): ChannelMention = objWith(ChannelMention, "name", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => guildId, () => tpe, () => name)
  }
  object ChannelMention extends DiscordObjectCompanion[ChannelMention] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelMention =
      new ChannelMention(json, cache)

    /**
      * @param id
      *   Id of the channel
      * @param guildId
      *   Id of the guild containing the channel
      * @param tpe
      *   The type of channel
      * @param name
      *   The name of the channel
      */
    def make20(
        id: TextGuildChannelId,
        guildId: GuildId,
        tpe: Channel.ChannelType,
        name: String
    ): ChannelMention = makeRawFromFields("id" := id, "guild_id" := guildId, "type" := tpe, "name" := name)
  }

  class MessageActivity(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Type of message activity */
    @inline def tpe: MessageActivity.MessageActivityType = selectDynamic[MessageActivity.MessageActivityType]("type")

    @inline def withTpe(newValue: MessageActivity.MessageActivityType): MessageActivity =
      objWith(MessageActivity, "type", newValue)

    /** party_id from a Rich Presence event */
    @inline def partyId: UndefOr[String] = selectDynamic[UndefOr[String]]("party_id")

    @inline def withPartyId(newValue: UndefOr[String]): MessageActivity =
      objWithUndef(MessageActivity, "party_id", newValue)

    override def values: Seq[() => Any] = Seq(() => tpe, () => partyId)
  }
  object MessageActivity extends DiscordObjectCompanion[MessageActivity] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageActivity =
      new MessageActivity(json, cache)

    /**
      * @param tpe
      *   Type of message activity
      * @param partyId
      *   party_id from a Rich Presence event
      */
    def make20(
        tpe: MessageActivity.MessageActivityType,
        partyId: UndefOr[String] = UndefOrUndefined(Some("party_id"))
    ): MessageActivity = makeRawFromFields("type" := tpe, "party_id" :=? partyId)

    sealed case class MessageActivityType private (value: Int) extends DiscordEnum[Int]
    object MessageActivityType extends DiscordEnumCompanion[Int, MessageActivityType] {
      val JOIN: MessageActivityType = MessageActivityType(1)

      val SPECTATE: MessageActivityType = MessageActivityType(2)

      val LISTEN: MessageActivityType = MessageActivityType(3)

      val JOIN_REQUEST: MessageActivityType = MessageActivityType(5)

      def unknown(value: Int): MessageActivityType = new MessageActivityType(value)

      val values: Seq[MessageActivityType] = Seq(JOIN, SPECTATE, LISTEN, JOIN_REQUEST)
    }
  }

  sealed case class MessageFlags private (value: Int) extends DiscordEnum[Int]
  object MessageFlags                                 extends DiscordEnumCompanion[Int, MessageFlags] {

    /**
      * This message has been published to subscribed channels (via Channel
      * Following)
      */
    val CROSSPOSTED: MessageFlags = MessageFlags(1 << 0)

    /**
      * This message originated from a message in another channel (via Channel
      * Following)
      */
    val IS_CROSSPOST: MessageFlags = MessageFlags(1 << 1)

    /** Do not include any embeds when serializing this message */
    val SUPPRESS_EMBEDS: MessageFlags = MessageFlags(1 << 2)

    /**
      * The source message for this crosspost has been deleted (via Channel
      * Following)
      */
    val SOURCE_MESSAGE_DELETED: MessageFlags = MessageFlags(1 << 3)

    /** This message came from the urgent message system */
    val URGENT: MessageFlags = MessageFlags(1 << 4)

    /**
      * This message has an associated thread, with the same id as the message
      */
    val HAS_THREAD: MessageFlags = MessageFlags(1 << 5)

    /** This message is only visible to the user who invoked the Interaction */
    val EPHEMERAL: MessageFlags = MessageFlags(1 << 6)

    /** This message is an Interaction Response and the bot is "thinking" */
    val LOADING: MessageFlags = MessageFlags(1 << 7)

    /**
      * This message failed to mention some roles and add their members to the
      * thread
      */
    val FAILED_TO_MENTION_SOME_ROLES_IN_THREAD: MessageFlags = MessageFlags(1 << 8)

    /** This message will not trigger push and desktop notifications */
    val SUPPRESS_NOTIFICATIONS: MessageFlags = MessageFlags(1 << 12)

    /** This message is a voice message */
    val IS_VOICE_MESSAGE: MessageFlags = MessageFlags(1 << 13)

    def unknown(value: Int): MessageFlags = new MessageFlags(value)

    val values: Seq[MessageFlags] = Seq(
      CROSSPOSTED,
      IS_CROSSPOST,
      SUPPRESS_EMBEDS,
      SOURCE_MESSAGE_DELETED,
      URGENT,
      HAS_THREAD,
      EPHEMERAL,
      LOADING,
      FAILED_TO_MENTION_SOME_ROLES_IN_THREAD,
      SUPPRESS_NOTIFICATIONS,
      IS_VOICE_MESSAGE
    )

    implicit class MessageFlagsBitFieldOps(private val here: MessageFlags) extends AnyVal {

      def toInt: Int = here.value

      def ++(there: MessageFlags): MessageFlags = MessageFlags(here.value | there.value)

      def --(there: MessageFlags): MessageFlags = MessageFlags(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }

  class RoleSubscriptionData(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The id of the sku and listing that the user is subscribed to */
    @inline def roleSubscriptionListingId: RawSnowflake = selectDynamic[RawSnowflake]("role_subscription_listing_id")

    @inline def withRoleSubscriptionListingId(newValue: RawSnowflake): RoleSubscriptionData =
      objWith(RoleSubscriptionData, "role_subscription_listing_id", newValue)

    /** The name of the tier that the user is subscribed to */
    @inline def tierName: String = selectDynamic[String]("tier_name")

    @inline def withTierName(newValue: String): RoleSubscriptionData =
      objWith(RoleSubscriptionData, "tier_name", newValue)

    /** The cumulative number of months that the user has been subscribed for */
    @inline def totalMonthsSubscribed: Int = selectDynamic[Int]("total_months_subscribed")

    @inline def withTotalMonthsSubscribed(newValue: Int): RoleSubscriptionData =
      objWith(RoleSubscriptionData, "total_months_subscribed", newValue)

    /** Whether this notification is for a renewal rather than a new purchase */
    @inline def isRenewal: Boolean = selectDynamic[Boolean]("is_renewal")

    @inline def withIsRenewal(newValue: Boolean): RoleSubscriptionData =
      objWith(RoleSubscriptionData, "is_renewal", newValue)

    override def values: Seq[() => Any] =
      Seq(() => roleSubscriptionListingId, () => tierName, () => totalMonthsSubscribed, () => isRenewal)
  }
  object RoleSubscriptionData extends DiscordObjectCompanion[RoleSubscriptionData] {
    def makeRaw(json: Json, cache: Map[String, Any]): RoleSubscriptionData =
      new RoleSubscriptionData(json, cache)

    /**
      * @param roleSubscriptionListingId
      *   The id of the sku and listing that the user is subscribed to
      * @param tierName
      *   The name of the tier that the user is subscribed to
      * @param totalMonthsSubscribed
      *   The cumulative number of months that the user has been subscribed for
      * @param isRenewal
      *   Whether this notification is for a renewal rather than a new purchase
      */
    def make20(
        roleSubscriptionListingId: RawSnowflake,
        tierName: String,
        totalMonthsSubscribed: Int,
        isRenewal: Boolean
    ): RoleSubscriptionData = makeRawFromFields(
      "role_subscription_listing_id" := roleSubscriptionListingId,
      "tier_name"                    := tierName,
      "total_months_subscribed"      := totalMonthsSubscribed,
      "is_renewal"                   := isRenewal
    )
  }
}

class MessageReference(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Id of the originating message */
  @inline def messageId: UndefOr[MessageId] = selectDynamic[UndefOr[MessageId]]("message_id")

  @inline def withMessageId(newValue: UndefOr[MessageId]): MessageReference =
    objWithUndef(MessageReference, "message_id", newValue)

  /** Id of the originating message's channel */
  @inline def channelId: UndefOr[TextChannelId] = selectDynamic[UndefOr[TextChannelId]]("channel_id")

  @inline def withChannelId(newValue: UndefOr[TextChannelId]): MessageReference =
    objWithUndef(MessageReference, "channel_id", newValue)

  /** Id of the originating message's guild */
  @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

  @inline def withGuildId(newValue: UndefOr[GuildId]): MessageReference =
    objWithUndef(MessageReference, "guild_id", newValue)

  /**
    * When sending, whether to error if the referenced message doesn't exist
    * instead of sending as a normal (non-reply) message, default true
    */
  @inline def failIfNotExists: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("fail_if_not_exists")

  @inline def withFailIfNotExists(newValue: UndefOr[Boolean]): MessageReference =
    objWithUndef(MessageReference, "fail_if_not_exists", newValue)

  override def values: Seq[() => Any] = Seq(() => messageId, () => channelId, () => guildId, () => failIfNotExists)
}
object MessageReference extends DiscordObjectCompanion[MessageReference] {
  def makeRaw(json: Json, cache: Map[String, Any]): MessageReference =
    new MessageReference(json, cache)

  /**
    * @param messageId
    *   Id of the originating message
    * @param channelId
    *   Id of the originating message's channel
    * @param guildId
    *   Id of the originating message's guild
    * @param failIfNotExists
    *   When sending, whether to error if the referenced message doesn't exist
    *   instead of sending as a normal (non-reply) message, default true
    */
  def make20(
      messageId: UndefOr[MessageId] = UndefOrUndefined(Some("message_id")),
      channelId: UndefOr[TextChannelId] = UndefOrUndefined(Some("channel_id")),
      guildId: UndefOr[GuildId] = UndefOrUndefined(Some("guild_id")),
      failIfNotExists: UndefOr[Boolean] = UndefOrUndefined(Some("fail_if_not_exists"))
  ): MessageReference = makeRawFromFields(
    "message_id"         :=? messageId,
    "channel_id"         :=? channelId,
    "guild_id"           :=? guildId,
    "fail_if_not_exists" :=? failIfNotExists
  )
}

class FollowedChannel(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Source channel id */
  @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

  @inline def withChannelId(newValue: TextChannelId): FollowedChannel =
    objWith(FollowedChannel, "channel_id", newValue)

  /** Created target webhook id */
  @inline def webhookId: WebhookId = selectDynamic[WebhookId]("webhook_id")

  @inline def withWebhookId(newValue: WebhookId): FollowedChannel = objWith(FollowedChannel, "webhook_id", newValue)

  override def values: Seq[() => Any] = Seq(() => channelId, () => webhookId)
}
object FollowedChannel extends DiscordObjectCompanion[FollowedChannel] {
  def makeRaw(json: Json, cache: Map[String, Any]): FollowedChannel = new FollowedChannel(json, cache)

  /**
    * @param channelId
    *   Source channel id
    * @param webhookId
    *   Created target webhook id
    */
  def make20(channelId: TextChannelId, webhookId: WebhookId): FollowedChannel =
    makeRawFromFields("channel_id" := channelId, "webhook_id" := webhookId)
}

class Reaction(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Times this emoji has been used to react */
  @inline def count: Int = selectDynamic[Int]("count")

  @inline def withCount(newValue: Int): Reaction = objWith(Reaction, "count", newValue)

  /** Whether the current user reacted using this emoji */
  @inline def me: Boolean = selectDynamic[Boolean]("me")

  @inline def withMe(newValue: Boolean): Reaction = objWith(Reaction, "me", newValue)

  /** Emoji information */
  @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

  @inline def withEmoji(newValue: Emoji): Reaction = objWith(Reaction, "emoji", newValue)

  override def values: Seq[() => Any] = Seq(() => count, () => me, () => emoji)
}
object Reaction extends DiscordObjectCompanion[Reaction] {
  def makeRaw(json: Json, cache: Map[String, Any]): Reaction = new Reaction(json, cache)

  /**
    * @param count
    *   Times this emoji has been used to react
    * @param me
    *   Whether the current user reacted using this emoji
    * @param emoji
    *   Emoji information
    */
  def make20(count: Int, me: Boolean, emoji: Emoji): Reaction =
    makeRawFromFields("count" := count, "me" := me, "emoji" := emoji)
}

class Embed(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Title of embed */
  @inline def title: UndefOr[String] = selectDynamic[UndefOr[String]]("title")

  @inline def withTitle(newValue: UndefOr[String]): Embed = objWithUndef(Embed, "title", newValue)

  /** Type of embed (always "rich" for webhook embeds) */
  @inline def tpe: UndefOr[Embed.EmbedType] = selectDynamic[UndefOr[Embed.EmbedType]]("type")

  @inline def withTpe(newValue: UndefOr[Embed.EmbedType]): Embed = objWithUndef(Embed, "type", newValue)

  /** Description of embed */
  @inline def description: UndefOr[String] = selectDynamic[UndefOr[String]]("description")

  @inline def withDescription(newValue: UndefOr[String]): Embed = objWithUndef(Embed, "description", newValue)

  /** Url of embed */
  @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

  @inline def withUrl(newValue: UndefOr[String]): Embed = objWithUndef(Embed, "url", newValue)

  /** Timestamp of embed content */
  @inline def timestamp: UndefOr[OffsetDateTime] = selectDynamic[UndefOr[OffsetDateTime]]("timestamp")

  @inline def withTimestamp(newValue: UndefOr[OffsetDateTime]): Embed =
    objWithUndef(Embed, "timestamp", newValue)

  /** Color code of the embed */
  @inline def color: UndefOr[Int] = selectDynamic[UndefOr[Int]]("color")

  @inline def withColor(newValue: UndefOr[Int]): Embed = objWithUndef(Embed, "color", newValue)

  /** Footer information */
  @inline def footer: UndefOr[Embed.EmbedFooter] = selectDynamic[UndefOr[Embed.EmbedFooter]]("footer")

  @inline def withFooter(newValue: UndefOr[Embed.EmbedFooter]): Embed =
    objWithUndef(Embed, "footer", newValue)

  /** Image information */
  @inline def image: UndefOr[Embed.EmbedImage] = selectDynamic[UndefOr[Embed.EmbedImage]]("image")

  @inline def withImage(newValue: UndefOr[Embed.EmbedImage]): Embed = objWithUndef(Embed, "image", newValue)

  /** Thumbnail information */
  @inline def thumbnail: UndefOr[Embed.EmbedThumbnail] = selectDynamic[UndefOr[Embed.EmbedThumbnail]]("thumbnail")

  @inline def withThumbnail(newValue: UndefOr[Embed.EmbedThumbnail]): Embed =
    objWithUndef(Embed, "thumbnail", newValue)

  /** Video information */
  @inline def video: UndefOr[Embed.EmbedVideo] = selectDynamic[UndefOr[Embed.EmbedVideo]]("video")

  @inline def withVideo(newValue: UndefOr[Embed.EmbedVideo]): Embed = objWithUndef(Embed, "video", newValue)

  /** Provider information */
  @inline def provider: UndefOr[Embed.EmbedProvider] = selectDynamic[UndefOr[Embed.EmbedProvider]]("provider")

  @inline def withProvider(newValue: UndefOr[Embed.EmbedProvider]): Embed =
    objWithUndef(Embed, "provider", newValue)

  /** Author information */
  @inline def author: UndefOr[Embed.EmbedAuthor] = selectDynamic[UndefOr[Embed.EmbedAuthor]]("author")

  @inline def withAuthor(newValue: UndefOr[Embed.EmbedAuthor]): Embed =
    objWithUndef(Embed, "author", newValue)

  /** Fields information */
  @inline def fields: UndefOr[Seq[Embed.EmbedField]] = selectDynamic[UndefOr[Seq[Embed.EmbedField]]]("fields")

  @inline def withFields(newValue: UndefOr[Seq[Embed.EmbedField]]): Embed =
    objWithUndef(Embed, "fields", newValue)

  override def values: Seq[() => Any] = Seq(
    () => title,
    () => tpe,
    () => description,
    () => url,
    () => timestamp,
    () => color,
    () => footer,
    () => image,
    () => thumbnail,
    () => video,
    () => provider,
    () => author,
    () => fields
  )
}
object Embed extends DiscordObjectCompanion[Embed] {
  def makeRaw(json: Json, cache: Map[String, Any]): Embed = new Embed(json, cache)

  /**
    * @param title
    *   Title of embed
    * @param tpe
    *   Type of embed (always "rich" for webhook embeds)
    * @param description
    *   Description of embed
    * @param url
    *   Url of embed
    * @param timestamp
    *   Timestamp of embed content
    * @param color
    *   Color code of the embed
    * @param footer
    *   Footer information
    * @param image
    *   Image information
    * @param thumbnail
    *   Thumbnail information
    * @param video
    *   Video information
    * @param provider
    *   Provider information
    * @param author
    *   Author information
    * @param fields
    *   Fields information
    */
  def make20(
      title: UndefOr[String] = UndefOrUndefined(Some("title")),
      tpe: UndefOr[Embed.EmbedType] = UndefOrUndefined(Some("tpe")),
      description: UndefOr[String] = UndefOrUndefined(Some("description")),
      url: UndefOr[String] = UndefOrUndefined(Some("url")),
      timestamp: UndefOr[OffsetDateTime] = UndefOrUndefined(Some("timestamp")),
      color: UndefOr[Int] = UndefOrUndefined(Some("color")),
      footer: UndefOr[Embed.EmbedFooter] = UndefOrUndefined(Some("footer")),
      image: UndefOr[Embed.EmbedImage] = UndefOrUndefined(Some("image")),
      thumbnail: UndefOr[Embed.EmbedThumbnail] = UndefOrUndefined(Some("thumbnail")),
      video: UndefOr[Embed.EmbedVideo] = UndefOrUndefined(Some("video")),
      provider: UndefOr[Embed.EmbedProvider] = UndefOrUndefined(Some("provider")),
      author: UndefOr[Embed.EmbedAuthor] = UndefOrUndefined(Some("author")),
      fields: UndefOr[Seq[Embed.EmbedField]] = UndefOrUndefined(Some("fields"))
  ): Embed = makeRawFromFields(
    "title"       :=? title,
    "type"        :=? tpe,
    "description" :=? description,
    "url"         :=? url,
    "timestamp"   :=? timestamp,
    "color"       :=? color,
    "footer"      :=? footer,
    "image"       :=? image,
    "thumbnail"   :=? thumbnail,
    "video"       :=? video,
    "provider"    :=? provider,
    "author"      :=? author,
    "fields"      :=? fields
  )

  sealed case class EmbedType private (value: String) extends DiscordEnum[String]
  object EmbedType                                    extends DiscordEnumCompanion[String, EmbedType] {

    /** Generic embed rendered from embed attributes */
    val Rich: EmbedType = EmbedType("rich")

    /** Image embed */
    val Image: EmbedType = EmbedType("image")

    /** Video embed */
    val Video: EmbedType = EmbedType("video")

    /** Animated gif image embed rendered as a video embed */
    val Gifv: EmbedType = EmbedType("gifv")

    /** Article embed */
    val Article: EmbedType = EmbedType("article")

    /** Link embed */
    val Link: EmbedType = EmbedType("link")

    def unknown(value: String): EmbedType = new EmbedType(value)

    val values: Seq[EmbedType] = Seq(Rich, Image, Video, Gifv, Article, Link)
  }

  class EmbedThumbnail(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Source url of thumbnail (only supports http(s) and attachments) */
    @inline def url: String = selectDynamic[String]("url")

    @inline def withUrl(newValue: String): EmbedThumbnail = objWith(EmbedThumbnail, "url", newValue)

    /** A proxied url of the thumbnail */
    @inline def proxyUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_url")

    @inline def withProxyUrl(newValue: UndefOr[String]): EmbedThumbnail =
      objWithUndef(EmbedThumbnail, "proxy_url", newValue)

    /** Height of thumbnail */
    @inline def height: UndefOr[Int] = selectDynamic[UndefOr[Int]]("height")

    @inline def withHeight(newValue: UndefOr[Int]): EmbedThumbnail = objWithUndef(EmbedThumbnail, "height", newValue)

    /** Width of thumbnail */
    @inline def width: UndefOr[Int] = selectDynamic[UndefOr[Int]]("width")

    @inline def withWidth(newValue: UndefOr[Int]): EmbedThumbnail = objWithUndef(EmbedThumbnail, "width", newValue)

    override def values: Seq[() => Any] = Seq(() => url, () => proxyUrl, () => height, () => width)
  }
  object EmbedThumbnail extends DiscordObjectCompanion[EmbedThumbnail] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedThumbnail =
      new EmbedThumbnail(json, cache)

    /**
      * @param url
      *   Source url of thumbnail (only supports http(s) and attachments)
      * @param proxyUrl
      *   A proxied url of the thumbnail
      * @param height
      *   Height of thumbnail
      * @param width
      *   Width of thumbnail
      */
    def make20(
        url: String,
        proxyUrl: UndefOr[String] = UndefOrUndefined(Some("proxy_url")),
        height: UndefOr[Int] = UndefOrUndefined(Some("height")),
        width: UndefOr[Int] = UndefOrUndefined(Some("width"))
    ): EmbedThumbnail =
      makeRawFromFields("url" := url, "proxy_url" :=? proxyUrl, "height" :=? height, "width" :=? width)
  }

  class EmbedVideo(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Source url of video */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    @inline def withUrl(newValue: UndefOr[String]): EmbedVideo = objWithUndef(EmbedVideo, "url", newValue)

    /** A proxied url of the video */
    @inline def proxyUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_url")

    @inline def withProxyUrl(newValue: UndefOr[String]): EmbedVideo = objWithUndef(EmbedVideo, "proxy_url", newValue)

    /** Height of video */
    @inline def height: UndefOr[Int] = selectDynamic[UndefOr[Int]]("height")

    @inline def withHeight(newValue: UndefOr[Int]): EmbedVideo = objWithUndef(EmbedVideo, "height", newValue)

    /** Width of video */
    @inline def width: UndefOr[Int] = selectDynamic[UndefOr[Int]]("width")

    @inline def withWidth(newValue: UndefOr[Int]): EmbedVideo = objWithUndef(EmbedVideo, "width", newValue)

    override def values: Seq[() => Any] = Seq(() => url, () => proxyUrl, () => height, () => width)
  }
  object EmbedVideo extends DiscordObjectCompanion[EmbedVideo] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedVideo = new EmbedVideo(json, cache)

    /**
      * @param url
      *   Source url of video
      * @param proxyUrl
      *   A proxied url of the video
      * @param height
      *   Height of video
      * @param width
      *   Width of video
      */
    def make20(
        url: UndefOr[String] = UndefOrUndefined(Some("url")),
        proxyUrl: UndefOr[String] = UndefOrUndefined(Some("proxy_url")),
        height: UndefOr[Int] = UndefOrUndefined(Some("height")),
        width: UndefOr[Int] = UndefOrUndefined(Some("width"))
    ): EmbedVideo = makeRawFromFields("url" :=? url, "proxy_url" :=? proxyUrl, "height" :=? height, "width" :=? width)
  }

  class EmbedImage(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Source url of image (only supports http(s) and attachments) */
    @inline def url: String = selectDynamic[String]("url")

    @inline def withUrl(newValue: String): EmbedImage = objWith(EmbedImage, "url", newValue)

    /** A proxied url of the image */
    @inline def proxyUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_url")

    @inline def withProxyUrl(newValue: UndefOr[String]): EmbedImage = objWithUndef(EmbedImage, "proxy_url", newValue)

    /** Height of image */
    @inline def height: UndefOr[Int] = selectDynamic[UndefOr[Int]]("height")

    @inline def withHeight(newValue: UndefOr[Int]): EmbedImage = objWithUndef(EmbedImage, "height", newValue)

    /** Width of image */
    @inline def width: UndefOr[Int] = selectDynamic[UndefOr[Int]]("width")

    @inline def withWidth(newValue: UndefOr[Int]): EmbedImage = objWithUndef(EmbedImage, "width", newValue)

    override def values: Seq[() => Any] = Seq(() => url, () => proxyUrl, () => height, () => width)
  }
  object EmbedImage extends DiscordObjectCompanion[EmbedImage] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedImage = new EmbedImage(json, cache)

    /**
      * @param url
      *   Source url of image (only supports http(s) and attachments)
      * @param proxyUrl
      *   A proxied url of the image
      * @param height
      *   Height of image
      * @param width
      *   Width of image
      */
    def make20(
        url: String,
        proxyUrl: UndefOr[String] = UndefOrUndefined(Some("proxy_url")),
        height: UndefOr[Int] = UndefOrUndefined(Some("height")),
        width: UndefOr[Int] = UndefOrUndefined(Some("width"))
    ): EmbedImage = makeRawFromFields("url" := url, "proxy_url" :=? proxyUrl, "height" :=? height, "width" :=? width)
  }

  class EmbedProvider(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Name of provider */
    @inline def name: UndefOr[String] = selectDynamic[UndefOr[String]]("name")

    @inline def withName(newValue: UndefOr[String]): EmbedProvider = objWithUndef(EmbedProvider, "name", newValue)

    /** Url of provider */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    @inline def withUrl(newValue: UndefOr[String]): EmbedProvider = objWithUndef(EmbedProvider, "url", newValue)

    override def values: Seq[() => Any] = Seq(() => name, () => url)
  }
  object EmbedProvider extends DiscordObjectCompanion[EmbedProvider] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedProvider = new EmbedProvider(json, cache)

    /**
      * @param name
      *   Name of provider
      * @param url
      *   Url of provider
      */
    def make20(
        name: UndefOr[String] = UndefOrUndefined(Some("name")),
        url: UndefOr[String] = UndefOrUndefined(Some("url"))
    ): EmbedProvider = makeRawFromFields("name" :=? name, "url" :=? url)
  }

  class EmbedAuthor(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Name of author */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): EmbedAuthor = objWith(EmbedAuthor, "name", newValue)

    /** Url of author (only supports http(s)) */
    @inline def url: UndefOr[String] = selectDynamic[UndefOr[String]]("url")

    @inline def withUrl(newValue: UndefOr[String]): EmbedAuthor = objWithUndef(EmbedAuthor, "url", newValue)

    /** Url of author icon (only supports http(s) and attachments) */
    @inline def iconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("icon_url")

    @inline def withIconUrl(newValue: UndefOr[String]): EmbedAuthor = objWithUndef(EmbedAuthor, "icon_url", newValue)

    /** A proxied url of author icon */
    @inline def proxyIconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_icon_url")

    @inline def withProxyIconUrl(newValue: UndefOr[String]): EmbedAuthor =
      objWithUndef(EmbedAuthor, "proxy_icon_url", newValue)

    override def values: Seq[() => Any] = Seq(() => name, () => url, () => iconUrl, () => proxyIconUrl)
  }
  object EmbedAuthor extends DiscordObjectCompanion[EmbedAuthor] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedAuthor = new EmbedAuthor(json, cache)

    /**
      * @param name
      *   Name of author
      * @param url
      *   Url of author (only supports http(s))
      * @param iconUrl
      *   Url of author icon (only supports http(s) and attachments)
      * @param proxyIconUrl
      *   A proxied url of author icon
      */
    def make20(
        name: String,
        url: UndefOr[String] = UndefOrUndefined(Some("url")),
        iconUrl: UndefOr[String] = UndefOrUndefined(Some("icon_url")),
        proxyIconUrl: UndefOr[String] = UndefOrUndefined(Some("proxy_icon_url"))
    ): EmbedAuthor =
      makeRawFromFields("name" := name, "url" :=? url, "icon_url" :=? iconUrl, "proxy_icon_url" :=? proxyIconUrl)
  }

  class EmbedFooter(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Footer text */
    @inline def text: String = selectDynamic[String]("text")

    @inline def withText(newValue: String): EmbedFooter = objWith(EmbedFooter, "text", newValue)

    /** Url of footer icon (only supports http(s) and attachments) */
    @inline def iconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("icon_url")

    @inline def withIconUrl(newValue: UndefOr[String]): EmbedFooter = objWithUndef(EmbedFooter, "icon_url", newValue)

    /** A proxied url of footer icon */
    @inline def proxyIconUrl: UndefOr[String] = selectDynamic[UndefOr[String]]("proxy_icon_url")

    @inline def withProxyIconUrl(newValue: UndefOr[String]): EmbedFooter =
      objWithUndef(EmbedFooter, "proxy_icon_url", newValue)

    override def values: Seq[() => Any] = Seq(() => text, () => iconUrl, () => proxyIconUrl)
  }
  object EmbedFooter extends DiscordObjectCompanion[EmbedFooter] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedFooter = new EmbedFooter(json, cache)

    /**
      * @param text
      *   Footer text
      * @param iconUrl
      *   Url of footer icon (only supports http(s) and attachments)
      * @param proxyIconUrl
      *   A proxied url of footer icon
      */
    def make20(
        text: String,
        iconUrl: UndefOr[String] = UndefOrUndefined(Some("icon_url")),
        proxyIconUrl: UndefOr[String] = UndefOrUndefined(Some("proxy_icon_url"))
    ): EmbedFooter = makeRawFromFields("text" := text, "icon_url" :=? iconUrl, "proxy_icon_url" :=? proxyIconUrl)
  }

  class EmbedField(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Name of the field */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): EmbedField = objWith(EmbedField, "name", newValue)

    /** Value of the field */
    @inline def value: String = selectDynamic[String]("value")

    @inline def withValue(newValue: String): EmbedField = objWith(EmbedField, "value", newValue)

    /** Whether or not this field should display inline */
    @inline def inline: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("inline")

    @inline def withInline(newValue: UndefOr[Boolean]): EmbedField = objWithUndef(EmbedField, "inline", newValue)

    override def values: Seq[() => Any] = Seq(() => name, () => value, () => inline)
  }
  object EmbedField extends DiscordObjectCompanion[EmbedField] {
    def makeRaw(json: Json, cache: Map[String, Any]): EmbedField = new EmbedField(json, cache)

    /**
      * @param name
      *   Name of the field
      * @param value
      *   Value of the field
      * @param inline
      *   Whether or not this field should display inline
      */
    def make20(
        name: String,
        value: String,
        inline: UndefOr[Boolean] = UndefOrUndefined(Some("inline"))
    ): EmbedField = makeRawFromFields("name" := name, "value" := value, "inline" :=? inline)
  }
}

class Attachment(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** Attachment id */
  @inline def id: Snowflake[Attachment] = selectDynamic[Snowflake[Attachment]]("id")

  @inline def withId(newValue: Snowflake[Attachment]): Attachment = objWith(Attachment, "id", newValue)

  /** Name of file attached */
  @inline def filename: String = selectDynamic[String]("filename")

  @inline def withFilename(newValue: String): Attachment = objWith(Attachment, "filename", newValue)

  /** Description for the file (max 1024 characters) */
  @inline def description: UndefOr[String] = selectDynamic[UndefOr[String]]("description")

  @inline def withDescription(newValue: UndefOr[String]): Attachment =
    objWithUndef(Attachment, "description", newValue)

  /** The attachment's media type */
  @inline def contentType: UndefOr[String] = selectDynamic[UndefOr[String]]("content_type")

  @inline def withContentType(newValue: UndefOr[String]): Attachment =
    objWithUndef(Attachment, "content_type", newValue)

  /** Size of file in bytes */
  @inline def size: Int = selectDynamic[Int]("size")

  @inline def withSize(newValue: Int): Attachment = objWith(Attachment, "size", newValue)

  /** Source url of file */
  @inline def url: String = selectDynamic[String]("url")

  @inline def withUrl(newValue: String): Attachment = objWith(Attachment, "url", newValue)

  /** A proxied url of file */
  @inline def proxyUrl: String = selectDynamic[String]("proxy_url")

  @inline def withProxyUrl(newValue: String): Attachment = objWith(Attachment, "proxy_url", newValue)

  /** Height of file (if image) */
  @inline def height: JsonOption[Int] = selectDynamic[JsonOption[Int]]("height")

  @inline def withHeight(newValue: JsonOption[Int]): Attachment = objWithUndef(Attachment, "height", newValue)

  /** Width of file (if image) */
  @inline def width: JsonOption[Int] = selectDynamic[JsonOption[Int]]("width")

  @inline def withWidth(newValue: JsonOption[Int]): Attachment = objWithUndef(Attachment, "width", newValue)

  /** Whether this attachment is ephemeral */
  @inline def ephemeral: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("ephemeral")

  @inline def withEphemeral(newValue: UndefOr[Boolean]): Attachment = objWithUndef(Attachment, "ephemeral", newValue)

  /** The duration of the audio file (currently for voice messages) */
  @inline def durationSecs: UndefOr[Float] = selectDynamic[UndefOr[Float]]("duration_secs")

  @inline def withDurationSecs(newValue: UndefOr[Float]): Attachment =
    objWithUndef(Attachment, "duration_secs", newValue)

  /**
    * Base64 encoded bytearray representing a sampled waveform (currently for
    * voice messages)
    */
  @inline def waveform: UndefOr[String] = selectDynamic[UndefOr[String]]("waveform")

  @inline def withWaveform(newValue: UndefOr[String]): Attachment = objWithUndef(Attachment, "waveform", newValue)

  /** Attachment flags combined as a bitfield */
  @inline def flags: UndefOr[Attachment.AttachmentFlags] = selectDynamic[UndefOr[Attachment.AttachmentFlags]]("flags")

  @inline def withFlags(newValue: UndefOr[Attachment.AttachmentFlags]): Attachment =
    objWithUndef(Attachment, "flags", newValue)

  override def values: Seq[() => Any] = Seq(
    () => id,
    () => filename,
    () => description,
    () => contentType,
    () => size,
    () => url,
    () => proxyUrl,
    () => height,
    () => width,
    () => ephemeral,
    () => durationSecs,
    () => waveform,
    () => flags
  )
}
object Attachment extends DiscordObjectCompanion[Attachment] {
  def makeRaw(json: Json, cache: Map[String, Any]): Attachment = new Attachment(json, cache)

  /**
    * @param id
    *   Attachment id
    * @param filename
    *   Name of file attached
    * @param description
    *   Description for the file (max 1024 characters)
    * @param contentType
    *   The attachment's media type
    * @param size
    *   Size of file in bytes
    * @param url
    *   Source url of file
    * @param proxyUrl
    *   A proxied url of file
    * @param height
    *   Height of file (if image)
    * @param width
    *   Width of file (if image)
    * @param ephemeral
    *   Whether this attachment is ephemeral
    * @param durationSecs
    *   The duration of the audio file (currently for voice messages)
    * @param waveform
    *   Base64 encoded bytearray representing a sampled waveform (currently for
    *   voice messages)
    * @param flags
    *   Attachment flags combined as a bitfield
    */
  def make20(
      id: Snowflake[Attachment],
      filename: String,
      description: UndefOr[String] = UndefOrUndefined(Some("description")),
      contentType: UndefOr[String] = UndefOrUndefined(Some("content_type")),
      size: Int,
      url: String,
      proxyUrl: String,
      height: JsonOption[Int] = JsonUndefined(Some("height")),
      width: JsonOption[Int] = JsonUndefined(Some("width")),
      ephemeral: UndefOr[Boolean] = UndefOrUndefined(Some("ephemeral")),
      durationSecs: UndefOr[Float] = UndefOrUndefined(Some("duration_secs")),
      waveform: UndefOr[String] = UndefOrUndefined(Some("waveform")),
      flags: UndefOr[Attachment.AttachmentFlags] = UndefOrUndefined(Some("flags"))
  ): Attachment = makeRawFromFields(
    "id"             := id,
    "filename"       := filename,
    "description"   :=? description,
    "content_type"  :=? contentType,
    "size"           := size,
    "url"            := url,
    "proxy_url"      := proxyUrl,
    "height"        :=? height,
    "width"         :=? width,
    "ephemeral"     :=? ephemeral,
    "duration_secs" :=? durationSecs,
    "waveform"      :=? waveform,
    "flags"         :=? flags
  )

  sealed case class AttachmentFlags private (value: Int) extends DiscordEnum[Int]
  object AttachmentFlags                                 extends DiscordEnumCompanion[Int, AttachmentFlags] {

    /** This attachment has been edited using the remix feature on mobile */
    val IS_REMIX: AttachmentFlags = AttachmentFlags(1 << 2)

    def unknown(value: Int): AttachmentFlags = new AttachmentFlags(value)

    val values: Seq[AttachmentFlags] = Seq(IS_REMIX)

    implicit class AttachmentFlagsBitFieldOps(private val here: AttachmentFlags) extends AnyVal {

      def toInt: Int = here.value

      def ++(there: AttachmentFlags): AttachmentFlags = AttachmentFlags(here.value | there.value)

      def --(there: AttachmentFlags): AttachmentFlags = AttachmentFlags(here.value & ~there.value)

      def isNone: Boolean = here.value == 0
    }
  }
}

class AllowedMentions(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

  /** An array of allowed mention types to parse from the content. */
  @inline def parse: UndefOr[Seq[AllowedMentions.AllowedMentionsType]] =
    selectDynamic[UndefOr[Seq[AllowedMentions.AllowedMentionsType]]]("parse")

  @inline def withParse(
      newValue: UndefOr[Seq[AllowedMentions.AllowedMentionsType]]
  ): AllowedMentions = objWithUndef(AllowedMentions, "parse", newValue)

  /** Array of role_ids to mention (Max size of 100) */
  @inline def roles: UndefOr[Seq[RoleId]] = selectDynamic[UndefOr[Seq[RoleId]]]("roles")

  @inline def withRoles(newValue: UndefOr[Seq[RoleId]]): AllowedMentions =
    objWithUndef(AllowedMentions, "roles", newValue)

  /** Array of user_ids to mention (Max size of 100) */
  @inline def users: UndefOr[Seq[UserId]] = selectDynamic[UndefOr[Seq[UserId]]]("users")

  @inline def withUsers(newValue: UndefOr[Seq[UserId]]): AllowedMentions =
    objWithUndef(AllowedMentions, "users", newValue)

  /**
    * For replies, whether to mention the author of the message being replied to
    * (default false)
    */
  @inline def repliedUser: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("replied_user")

  @inline def withRepliedUser(newValue: UndefOr[Boolean]): AllowedMentions =
    objWithUndef(AllowedMentions, "replied_user", newValue)

  override def values: Seq[() => Any] = Seq(() => parse, () => roles, () => users, () => repliedUser)
}
object AllowedMentions extends DiscordObjectCompanion[AllowedMentions] {
  def makeRaw(json: Json, cache: Map[String, Any]): AllowedMentions = new AllowedMentions(json, cache)

  /**
    * @param parse
    *   An array of allowed mention types to parse from the content.
    * @param roles
    *   Array of role_ids to mention (Max size of 100)
    * @param users
    *   Array of user_ids to mention (Max size of 100)
    * @param repliedUser
    *   For replies, whether to mention the author of the message being replied
    *   to (default false)
    */
  def make20(
      parse: UndefOr[Seq[AllowedMentions.AllowedMentionsType]] = UndefOrUndefined(Some("parse")),
      roles: UndefOr[Seq[RoleId]] = UndefOrUndefined(Some("roles")),
      users: UndefOr[Seq[UserId]] = UndefOrUndefined(Some("users")),
      repliedUser: UndefOr[Boolean] = UndefOrUndefined(Some("replied_user"))
  ): AllowedMentions =
    makeRawFromFields("parse" :=? parse, "roles" :=? roles, "users" :=? users, "replied_user" :=? repliedUser)

  sealed case class AllowedMentionsType private (value: String) extends DiscordEnum[String]
  object AllowedMentionsType extends DiscordEnumCompanion[String, AllowedMentionsType] {

    /** Controls role mentions */
    val RoleMentions: AllowedMentionsType = AllowedMentionsType("roles")

    /** Controls user mentions */
    val UserMentions: AllowedMentionsType = AllowedMentionsType("users")

    /** Controls @everyone and @here mentions */
    val EveryoneMentions: AllowedMentionsType = AllowedMentionsType("everyone")

    def unknown(value: String): AllowedMentionsType = new AllowedMentionsType(value)

    val values: Seq[AllowedMentionsType] = Seq(RoleMentions, UserMentions, EveryoneMentions)
  }
}
