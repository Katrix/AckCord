//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.requests

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/requests/UserRequests.yaml

import ackcord.data._
import ackcord.data.base._
import io.circe.Json
import sttp.model.Method

object UserRequests {

  /**
    * Returns the user object of the requester's account. For OAuth2, this
    * requires the identify scope, which will return the object without an
    * email, and optionally the email scope, which returns the object with an
    * email.
    */
  val getCurrentUser: Request[Unit, User] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me").toRequest(Method.GET)
    )

  /** Returns a user object for a given user ID. */
  def getUser(
      userId: UserId
  ): Request[Unit, User] =
    Request.restRequest(
      route = (Route.Empty / "users" / Parameters[UserId]("userId", userId)).toRequest(Method.GET)
    )

  class ModifyCurrentUserBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /**
      * User's username, if changed may cause the user's discriminator to be
      * randomized.
      */
    @inline def username: UndefOr[String] = selectDynamic[UndefOr[String]]("username")

    /** If passed, modifies the user's avatar */
    @inline def avatar: JsonOption[ImageData] = selectDynamic[JsonOption[ImageData]]("avatar")

    override def values: Seq[() => Any] = Seq(() => username, () => avatar)
  }
  object ModifyCurrentUserBody extends DiscordObjectCompanion[ModifyCurrentUserBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): ModifyCurrentUserBody = new ModifyCurrentUserBody(json, cache)

    /**
      * @param username
      *   User's username, if changed may cause the user's discriminator to be
      *   randomized.
      * @param avatar
      *   If passed, modifies the user's avatar
      */
    def make20(
        username: UndefOr[String] = UndefOrUndefined,
        avatar: JsonOption[ImageData] = JsonUndefined
    ): ModifyCurrentUserBody = makeRawFromFields("username" :=? username, "avatar" :=? avatar)

  }

  /**
    * Modify the requester's user account settings. Returns a user object on
    * success. Fires a User Update Gateway event.
    */
  def modifyCurrentUser(
      body: ModifyCurrentUserBody
  ): Request[ModifyCurrentUserBody, User] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me").toRequest(Method.PATCH),
      params = body
    )

  class GetCurrentUserGuildsQuery(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Get guilds before this guild ID */
    @inline def before: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("before")

    /** Get guilds after this guild ID */
    @inline def after: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("after")

    /** Max number of guilds to return (1-200) */
    @inline def limit: UndefOr[Int] = selectDynamic[UndefOr[Int]]("limit")

    /** Include approximate member and presence counts in response */
    @inline def withCounts: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("with_counts")

    override def values: Seq[() => Any] = Seq(() => before, () => after, () => limit, () => withCounts)
  }
  object GetCurrentUserGuildsQuery extends DiscordObjectCompanion[GetCurrentUserGuildsQuery] {
    def makeRaw(json: Json, cache: Map[String, Any]): GetCurrentUserGuildsQuery =
      new GetCurrentUserGuildsQuery(json, cache)

    /**
      * @param before
      *   Get guilds before this guild ID
      * @param after
      *   Get guilds after this guild ID
      * @param limit
      *   Max number of guilds to return (1-200)
      * @param withCounts
      *   Include approximate member and presence counts in response
      */
    def make20(
        before: UndefOr[GuildId] = UndefOrUndefined,
        after: UndefOr[GuildId] = UndefOrUndefined,
        limit: UndefOr[Int] = UndefOrUndefined,
        withCounts: UndefOr[Boolean] = UndefOrUndefined
    ): GetCurrentUserGuildsQuery =
      makeRawFromFields("before" :=? before, "after" :=? after, "limit" :=? limit, "with_counts" :=? withCounts)

  }

  class GetCurrentUserGuildsResult(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def id: GuildId = selectDynamic[GuildId]("id")

    @inline def name: String = selectDynamic[String]("name")

    @inline def icon: Option[ImageHash] = selectDynamic[Option[ImageHash]]("icon")

    @inline def owner: Boolean = selectDynamic[Boolean]("owner")

    @inline def permissions: Permissions = selectDynamic[Permissions]("permissions")

    @inline def features: Seq[Guild.GuildFeature] = selectDynamic[Seq[Guild.GuildFeature]]("features")

    @inline def approximateMemberCount: UndefOr[Int] = selectDynamic[UndefOr[Int]]("approximate_member_count")

    @inline def approximatePresenceCount: UndefOr[Int] = selectDynamic[UndefOr[Int]]("approximate_presence_count")

    override def values: Seq[() => Any] = Seq(
      () => id,
      () => name,
      () => icon,
      () => owner,
      () => permissions,
      () => features,
      () => approximateMemberCount,
      () => approximatePresenceCount
    )
  }
  object GetCurrentUserGuildsResult extends DiscordObjectCompanion[GetCurrentUserGuildsResult] {
    def makeRaw(json: Json, cache: Map[String, Any]): GetCurrentUserGuildsResult =
      new GetCurrentUserGuildsResult(json, cache)

    def make20(
        id: GuildId,
        name: String,
        icon: Option[ImageHash],
        owner: Boolean,
        permissions: Permissions,
        features: Seq[Guild.GuildFeature],
        approximateMemberCount: UndefOr[Int] = UndefOrUndefined,
        approximatePresenceCount: UndefOr[Int] = UndefOrUndefined
    ): GetCurrentUserGuildsResult = makeRawFromFields(
      "id"                          := id,
      "name"                        := name,
      "icon"                        := icon,
      "owner"                       := owner,
      "permissions"                 := permissions,
      "features"                    := features,
      "approximate_member_count"   :=? approximateMemberCount,
      "approximate_presence_count" :=? approximatePresenceCount
    )

  }

  /**
    * Returns a list of partial guild objects the current user is a member of.
    * Requires the guilds OAuth2 scope.
    */
  def getCurrentUserGuilds(
      query: GetCurrentUserGuildsQuery = GetCurrentUserGuildsQuery.make20()
  ): Request[Unit, Seq[GetCurrentUserGuildsResult]] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me" / "guilds" +? Parameters.query("before", query.before) +? Parameters.query(
        "after",
        query.after
      ) +? Parameters.query("limit", query.limit) +? Parameters.query("with_counts", query.withCounts))
        .toRequest(Method.GET)
    )

  /**
    * Returns a guild member object for the current user. Requires the
    * guilds.members.read OAuth2 scope.
    */
  def getCurrentUserGuildMember(
      guildId: GuildId
  ): Request[Unit, GuildMember] =
    Request.restRequest(
      route =
        (Route.Empty / "users" / "@me" / "guilds" / Parameters[GuildId]("guildId", guildId, major = true) / "member")
          .toRequest(Method.GET)
    )

  /**
    * Leave a guild. Returns a 204 empty response on success. Fires a Guild
    * Delete Gateway event and a Guild Member Remove Gateway event.
    */
  def leaveGuild(
      guildId: GuildId
  ): Request[Unit, Unit] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me" / "guilds" / Parameters[GuildId]("guildId", guildId, major = true))
        .toRequest(Method.DELETE)
    )

  class CreateDMBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** The recipient to open a DM channel with */
    @inline def recipientId: UserId = selectDynamic[UserId]("recipient_id")

    override def values: Seq[() => Any] = Seq(() => recipientId)
  }
  object CreateDMBody extends DiscordObjectCompanion[CreateDMBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): CreateDMBody = new CreateDMBody(json, cache)

    /** @param recipientId The recipient to open a DM channel with */
    def make20(recipientId: UserId): CreateDMBody = makeRawFromFields("recipient_id" := recipientId)

  }

  /**
    * Create a new DM channel with a user. Returns a DM channel object (if one
    * already exists, it will be returned instead).
    */
  def createDM(
      body: CreateDMBody
  ): Request[CreateDMBody, DMChannel] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me" / "channels").toRequest(Method.POST),
      params = body
    )

  class CreateGroupDMBody(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Access tokens of users that have granted your app the gdm.join scope */
    @inline def accessTokens: Seq[String] = selectDynamic[Seq[String]]("access_tokens")

    /** A dictionary of user ids to their respective nicknames */
    @inline def nicks: Map[UserId, String] = selectDynamic[Map[UserId, String]]("nicks")

    override def values: Seq[() => Any] = Seq(() => accessTokens, () => nicks)
  }
  object CreateGroupDMBody extends DiscordObjectCompanion[CreateGroupDMBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): CreateGroupDMBody = new CreateGroupDMBody(json, cache)

    /**
      * @param accessTokens
      *   Access tokens of users that have granted your app the gdm.join scope
      * @param nicks
      *   A dictionary of user ids to their respective nicknames
      */
    def make20(accessTokens: Seq[String], nicks: Map[UserId, String]): CreateGroupDMBody =
      makeRawFromFields("access_tokens" := accessTokens, "nicks" := nicks)

  }

  /**
    * Create a new group DM channel with multiple users. Returns a DM channel
    * object. This endpoint was intended to be used with the now-deprecated
    * GameBridge SDK. Fires a Channel Create Gateway event.
    */
  def createGroupDM(
      body: CreateGroupDMBody
  ): Request[CreateGroupDMBody, GroupDMChannel] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me" / "channels").toRequest(Method.POST),
      params = body
    )

  /**
    * Returns a list of connection objects. Requires the connections OAuth2
    * scope.
    */
  val getUserConnections: Request[Unit, Seq[Connection]] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me" / "connections").toRequest(Method.GET)
    )

  /**
    * Returns the application role connection for the user. Requires an OAuth2
    * access token with role_connections.write scope for the application
    * specified in the path.
    */
  def getUserApplicationRoleConnection(
      applicationId: ApplicationId
  ): Request[Unit, ApplicationRoleConnection] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me" / "applications" / Parameters[ApplicationId](
        "applicationId",
        applicationId
      ) / "role-connection").toRequest(Method.GET)
    )

  class UpdateUserApplicationRoleConnectionBody(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /**
      * The vanity name of the platform a bot has connected (max 50 characters)
      */
    @inline def platformName: UndefOr[String] = selectDynamic[UndefOr[String]]("platform_name")

    /** The username on the platform a bot has connected (max 100 characters) */
    @inline def platformUsername: UndefOr[String] = selectDynamic[UndefOr[String]]("platform_username")

    /**
      * Object mapping application role connection metadata keys to their
      * string-ified value (max 100 characters) for the user on the platform a
      * bot has connected
      */
    @inline def metadata: UndefOr[Map[String, String]] = selectDynamic[UndefOr[Map[String, String]]]("metadata")

    override def values: Seq[() => Any] = Seq(() => platformName, () => platformUsername, () => metadata)
  }
  object UpdateUserApplicationRoleConnectionBody
      extends DiscordObjectCompanion[UpdateUserApplicationRoleConnectionBody] {
    def makeRaw(json: Json, cache: Map[String, Any]): UpdateUserApplicationRoleConnectionBody =
      new UpdateUserApplicationRoleConnectionBody(json, cache)

    /**
      * @param platformName
      *   The vanity name of the platform a bot has connected (max 50
      *   characters)
      * @param platformUsername
      *   The username on the platform a bot has connected (max 100 characters)
      * @param metadata
      *   Object mapping application role connection metadata keys to their
      *   string-ified value (max 100 characters) for the user on the platform a
      *   bot has connected
      */
    def make20(
        platformName: UndefOr[String] = UndefOrUndefined,
        platformUsername: UndefOr[String] = UndefOrUndefined,
        metadata: UndefOr[Map[String, String]] = UndefOrUndefined
    ): UpdateUserApplicationRoleConnectionBody = makeRawFromFields(
      "platform_name"     :=? platformName,
      "platform_username" :=? platformUsername,
      "metadata"          :=? metadata
    )

  }

  /**
    * Updates and returns the application role connection for the user. Requires
    * an OAuth2 access token with role_connections.write scope for the
    * application specified in the path.
    */
  def updateUserApplicationRoleConnection(
      applicationId: ApplicationId,
      body: UpdateUserApplicationRoleConnectionBody
  ): Request[UpdateUserApplicationRoleConnectionBody, ApplicationRoleConnection] =
    Request.restRequest(
      route = (Route.Empty / "users" / "@me" / "applications" / Parameters[ApplicationId](
        "applicationId",
        applicationId
      ) / "role-connection").toRequest(Method.PUT),
      params = body
    )

}
