//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.gateway.data

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/gateway/data/GatewayDispatchEvent.yaml

import java.time.OffsetDateTime

import ackcord.data._
import ackcord.data.base._
import io.circe.Json

sealed trait GatewayDispatchEvent extends DiscordObject

object GatewayDispatchEvent extends DiscordObjectCompanion[GatewayDispatchEvent] {

  def makeRaw(json: Json, cache: Map[String, Any]): GatewayDispatchEvent =
    UnknownGatewayDispatchEvent.makeRaw(json, cache)

  def makeFromType(unknown: UnknownGatewayDispatchEvent, tpe: GatewayDispatchType): GatewayDispatchEvent = tpe match {
    case GatewayDispatchType.Ready                               => unknown.retype(Ready)
    case GatewayDispatchType.Resumed                             => unknown.retype(Resumed)
    case GatewayDispatchType.ApplicationCommandPermissionsUpdate => unknown.retype(ApplicationCommandPermissionsUpdate)
    case GatewayDispatchType.AutoModerationRuleCreate            => unknown.retype(AutoModerationRuleCreate)
    case GatewayDispatchType.AutoModerationRuleUpdate            => unknown.retype(AutoModerationRuleUpdate)
    case GatewayDispatchType.AutoModerationRuleDelete            => unknown.retype(AutoModerationRuleDelete)
    case GatewayDispatchType.AutoModerationActionExecution       => unknown.retype(AutoModerationActionExecution)
    case GatewayDispatchType.ChannelCreate                       => unknown.retype(ChannelCreate)
    case GatewayDispatchType.ChannelUpdate                       => unknown.retype(ChannelUpdate)
    case GatewayDispatchType.ChannelDelete                       => unknown.retype(ChannelDelete)
    case GatewayDispatchType.ThreadCreate                        => unknown.retype(ThreadCreate)
    case GatewayDispatchType.ThreadUpdate                        => unknown.retype(ThreadUpdate)
    case GatewayDispatchType.ThreadDelete                        => unknown.retype(ThreadDelete)
    case GatewayDispatchType.ThreadListSync                      => unknown.retype(ThreadListSync)
    case GatewayDispatchType.ThreadMemberUpdate                  => unknown.retype(ThreadMemberUpdate)
    case GatewayDispatchType.ThreadMembersUpdate                 => unknown.retype(ThreadMembersUpdate)
    case GatewayDispatchType.ChannelPinsUpdate                   => unknown.retype(ChannelPinsUpdate)
    case GatewayDispatchType.GuildCreate                         => unknown.retype(GuildCreate)
    case GatewayDispatchType.GuildUpdate                         => unknown.retype(GuildUpdate)
    case GatewayDispatchType.GuildDelete                         => unknown.retype(GuildDelete)
    case GatewayDispatchType.GuildAuditLogEntryCreate            => unknown.retype(GuildAuditLogEntryCreate)
    case GatewayDispatchType.GuildBanAdd                         => unknown.retype(GuildBanAdd)
    case GatewayDispatchType.GuildBanRemove                      => unknown.retype(GuildBanRemove)
    case GatewayDispatchType.GuildEmojisUpdate                   => unknown.retype(GuildEmojisUpdate)
    case GatewayDispatchType.GuildStickersUpdate                 => unknown.retype(GuildStickersUpdate)
    case GatewayDispatchType.GuildIntegrationsUpdate             => unknown.retype(GuildIntegrationsUpdate)
    case GatewayDispatchType.GuildMemberAdd                      => unknown.retype(GuildMemberAdd)
    case GatewayDispatchType.GuildMemberRemove                   => unknown.retype(GuildMemberRemove)
    case GatewayDispatchType.GuildMemberUpdate                   => unknown.retype(GuildMemberUpdate)
    case GatewayDispatchType.GuildMembersChunk                   => unknown.retype(GuildMembersChunk)
    case GatewayDispatchType.GuildRoleCreate                     => unknown.retype(GuildRoleCreate)
    case GatewayDispatchType.GuildRoleUpdate                     => unknown.retype(GuildRoleUpdate)
    case GatewayDispatchType.GuildRoleDelete                     => unknown.retype(GuildRoleDelete)
    case GatewayDispatchType.GuildScheduledEventCreate           => unknown.retype(GuildScheduledEventCreate)
    case GatewayDispatchType.GuildScheduledEventUpdate           => unknown.retype(GuildScheduledEventUpdate)
    case GatewayDispatchType.GuildScheduledEventDelete           => unknown.retype(GuildScheduledEventDelete)
    case GatewayDispatchType.GuildScheduledEventUserAdd          => unknown.retype(GuildScheduledEventUserAdd)
    case GatewayDispatchType.GuildScheduledEventUserRemove       => unknown.retype(GuildScheduledEventUserRemove)
    case GatewayDispatchType.IntegrationCreate                   => unknown.retype(IntegrationCreate)
    case GatewayDispatchType.IntegrationUpdate                   => unknown.retype(IntegrationUpdate)
    case GatewayDispatchType.IntegrationDelete                   => unknown.retype(IntegrationDelete)
    case GatewayDispatchType.InviteCreate                        => unknown.retype(InviteCreate)
    case GatewayDispatchType.InviteDelete                        => unknown.retype(InviteDelete)
    case GatewayDispatchType.MessageCreate                       => unknown.retype(MessageCreate)
    case GatewayDispatchType.MessageUpdate                       => unknown.retype(MessageUpdate)
    case GatewayDispatchType.MessageDelete                       => unknown.retype(MessageDelete)
    case GatewayDispatchType.MessageDeleteBulk                   => unknown.retype(MessageDeleteBulk)
    case GatewayDispatchType.MessageReactionAdd                  => unknown.retype(MessageReactionAdd)
    case GatewayDispatchType.MessageReactionRemove               => unknown.retype(MessageReactionRemove)
    case GatewayDispatchType.MessageReactionRemoveAll            => unknown.retype(MessageReactionRemoveAll)
    case GatewayDispatchType.MessageReactionRemoveEmoji          => unknown.retype(MessageReactionRemoveEmoji)
    case GatewayDispatchType.PresenceUpdate                      => unknown.retype(PresenceUpdate)
    case GatewayDispatchType.TypingStart                         => unknown.retype(TypingStart)
    case GatewayDispatchType.UserUpdate                          => unknown.retype(UserUpdate)
    case GatewayDispatchType.VoiceStateUpdate                    => unknown.retype(VoiceStateUpdate)
    case GatewayDispatchType.VoiceServerUpdate                   => unknown.retype(VoiceServerUpdate)
    case GatewayDispatchType.WebhooksUpdate                      => unknown.retype(WebhooksUpdate)
    case GatewayDispatchType.InteractionCreate                   => unknown.retype(InteractionCreate)
    case GatewayDispatchType.StageInstanceCreate                 => unknown.retype(StageInstanceCreate)
    case GatewayDispatchType.StageInstanceUpdate                 => unknown.retype(StageInstanceUpdate)
    case GatewayDispatchType.StageInstanceDelete                 => unknown.retype(StageInstanceDelete)
    case _                                                       => unknown
  }

  /**
    * The ready event is dispatched when a client has completed the initial
    * handshake with the gateway (for new sessions). The ready event can be the
    * largest and most complex event the gateway will send, as it contains all
    * the state required for a client to begin interacting with the rest of the
    * platform.
    *
    * guilds are the guilds of which your bot is a member. They start out as
    * unavailable when you connect to the gateway. As they become available,
    * your bot will be notified via Guild Create events.
    */
  class Ready(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** API version */
    @inline def v: Int = selectDynamic[Int]("v")

    @inline def withV(newValue: Int): Ready = objWith(Ready, "v", newValue)

    /** Information about the user including email */
    @inline def user: User = selectDynamic[User]("user")

    @inline def withUser(newValue: User): Ready = objWith(Ready, "user", newValue)

    /** Guilds the user is in */
    @inline def guilds: Seq[UnavailableGuild] = selectDynamic[Seq[UnavailableGuild]]("guilds")

    @inline def withGuilds(newValue: Seq[UnavailableGuild]): Ready = objWith(Ready, "guilds", newValue)

    /** Used for resuming connections */
    @inline def sessionId: String = selectDynamic[String]("session_id")

    @inline def withSessionId(newValue: String): Ready = objWith(Ready, "session_id", newValue)

    /** Gateway URL for resuming connections */
    @inline def resumeGatewayUrl: String = selectDynamic[String]("resume_gateway_url")

    @inline def withResumeGatewayUrl(newValue: String): Ready = objWith(Ready, "resume_gateway_url", newValue)

    /**
      * Shard information associated with this session, if sent when identifying
      */
    @inline def shard: UndefOr[Seq[Int]] = selectDynamic[UndefOr[Seq[Int]]]("shard")

    @inline def withShard(newValue: UndefOr[Seq[Int]]): Ready = objWithUndef(Ready, "shard", newValue)

    /** Contains id and flags */
    @inline def application: Ready.ReadyApplication = selectDynamic[Ready.ReadyApplication]("application")

    @inline def withApplication(newValue: Ready.ReadyApplication): Ready =
      objWith(Ready, "application", newValue)

    override def values: Seq[() => Any] =
      Seq(() => v, () => user, () => guilds, () => sessionId, () => resumeGatewayUrl, () => shard, () => application)
  }
  object Ready extends DiscordObjectCompanion[Ready] {
    def makeRaw(json: Json, cache: Map[String, Any]): Ready = new Ready(json, cache)

    /**
      * @param v
      *   API version
      * @param user
      *   Information about the user including email
      * @param guilds
      *   Guilds the user is in
      * @param sessionId
      *   Used for resuming connections
      * @param resumeGatewayUrl
      *   Gateway URL for resuming connections
      * @param shard
      *   Shard information associated with this session, if sent when
      *   identifying
      * @param application
      *   Contains id and flags
      */
    def make20(
        v: Int,
        user: User,
        guilds: Seq[UnavailableGuild],
        sessionId: String,
        resumeGatewayUrl: String,
        shard: UndefOr[Seq[Int]] = UndefOrUndefined,
        application: Ready.ReadyApplication
    ): Ready = makeRawFromFields(
      "v"                  := v,
      "user"               := user,
      "guilds"             := guilds,
      "session_id"         := sessionId,
      "resume_gateway_url" := resumeGatewayUrl,
      "shard"             :=? shard,
      "application"        := application
    )

    class ReadyApplication(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      @inline def id: ApplicationId = selectDynamic[ApplicationId]("id")

      @inline def withId(newValue: ApplicationId): ReadyApplication = objWith(ReadyApplication, "id", newValue)

      @inline def flags: Application.Flags = selectDynamic[Application.Flags]("flags")

      @inline def withFlags(newValue: Application.Flags): ReadyApplication =
        objWith(ReadyApplication, "flags", newValue)

      override def values: Seq[() => Any] = Seq(() => id, () => flags)
    }
    object ReadyApplication extends DiscordObjectCompanion[ReadyApplication] {
      def makeRaw(json: Json, cache: Map[String, Any]): ReadyApplication =
        new ReadyApplication(json, cache)

      def make20(id: ApplicationId, flags: Application.Flags): ReadyApplication =
        makeRawFromFields("id" := id, "flags" := flags)
    }
  }

  /**
    * The resumed event is dispatched when a client has sent a resume payload to
    * the gateway (for resuming existing sessions).
    */
  class Resumed(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    override def values: Seq[() => Any] = Seq()
  }
  object Resumed extends DiscordObjectCompanion[Resumed] {
    def makeRaw(json: Json, cache: Map[String, Any]): Resumed = new Resumed(json, cache)

    def make20(): Resumed = makeRawFromFields()
  }

  /**
    * APPLICATION_COMMAND_PERMISSIONS_UPDATE event, sent when an application
    * command's permissions are updated. The inner payload is an application
    * command permissions object.
    */
  class ApplicationCommandPermissionsUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: ApplicationCommandPermissionsUpdate.ApplicationCommandPermissionsStub =
      ApplicationCommandPermissionsUpdate.ApplicationCommandPermissionsStub.makeRaw(json, extensionCache("data"))

    @inline def withData(
        newValue: ApplicationCommandPermissionsUpdate.ApplicationCommandPermissionsStub
    ): ApplicationCommandPermissionsUpdate =
      objWithJson(ApplicationCommandPermissionsUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ApplicationCommandPermissionsUpdate extends DiscordObjectCompanion[ApplicationCommandPermissionsUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ApplicationCommandPermissionsUpdate =
      new ApplicationCommandPermissionsUpdate(json, cache)

    def make20(
        data: ApplicationCommandPermissionsUpdate.ApplicationCommandPermissionsStub
    ): ApplicationCommandPermissionsUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))

    class ApplicationCommandPermissionsStub(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object ApplicationCommandPermissionsStub extends DiscordObjectCompanion[ApplicationCommandPermissionsStub] {
      def makeRaw(json: Json, cache: Map[String, Any]): ApplicationCommandPermissionsStub =
        new ApplicationCommandPermissionsStub(json, cache)

      def make20(): ApplicationCommandPermissionsStub = makeRawFromFields()
    }
  }

  /**
    * Sent when a rule is created. The inner payload is an auto moderation rule
    * object.
    */
  class AutoModerationRuleCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: AutoModerationRule = AutoModerationRule.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: AutoModerationRule): AutoModerationRuleCreate =
      objWithJson(AutoModerationRuleCreate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object AutoModerationRuleCreate extends DiscordObjectCompanion[AutoModerationRuleCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationRuleCreate =
      new AutoModerationRuleCreate(json, cache)

    def make20(data: AutoModerationRule): AutoModerationRuleCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("data", data)
    )
  }

  /**
    * Sent when a rule is updated. The inner payload is an auto moderation rule
    * object.
    */
  class AutoModerationRuleUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: AutoModerationRule = AutoModerationRule.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: AutoModerationRule): AutoModerationRuleUpdate =
      objWithJson(AutoModerationRuleUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object AutoModerationRuleUpdate extends DiscordObjectCompanion[AutoModerationRuleUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationRuleUpdate =
      new AutoModerationRuleUpdate(json, cache)

    def make20(data: AutoModerationRule): AutoModerationRuleUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("data", data)
    )
  }

  /**
    * Sent when a rule is deleted. The inner payload is an auto moderation rule
    * object.
    */
  class AutoModerationRuleDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: AutoModerationRule = AutoModerationRule.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: AutoModerationRule): AutoModerationRuleDelete =
      objWithJson(AutoModerationRuleDelete, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object AutoModerationRuleDelete extends DiscordObjectCompanion[AutoModerationRuleDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationRuleDelete =
      new AutoModerationRuleDelete(json, cache)

    def make20(data: AutoModerationRule): AutoModerationRuleDelete = makeRawFromFields(
      DiscordObjectFrom.FromExtension("data", data)
    )
  }

  /**
    * Sent when a rule is triggered and an action is executed (e.g. when a
    * message is blocked).
    */
  class AutoModerationActionExecution(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild in which action was executed */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): AutoModerationActionExecution =
      objWith(AutoModerationActionExecution, "guild_id", newValue)

    /** Action which was executed */
    @inline def action: AutoModerationRule.AutoModerationRuleAction =
      selectDynamic[AutoModerationRule.AutoModerationRuleAction]("action")

    @inline def withAction(newValue: AutoModerationRule.AutoModerationRuleAction): AutoModerationActionExecution =
      objWith(AutoModerationActionExecution, "action", newValue)

    /** ID of the rule which action belongs to */
    @inline def ruleId: Snowflake[AutoModerationRule] = selectDynamic[Snowflake[AutoModerationRule]]("rule_id")

    @inline def withRuleId(newValue: Snowflake[AutoModerationRule]): AutoModerationActionExecution =
      objWith(AutoModerationActionExecution, "rule_id", newValue)

    /** Trigger type of rule which was triggered */
    @inline def ruleTriggerType: AutoModerationRule.AutoModerationRuleTriggerType =
      selectDynamic[AutoModerationRule.AutoModerationRuleTriggerType]("rule_trigger_type")

    @inline def withRuleTriggerType(
        newValue: AutoModerationRule.AutoModerationRuleTriggerType
    ): AutoModerationActionExecution = objWith(AutoModerationActionExecution, "rule_trigger_type", newValue)

    /** ID of the user which generated the content which triggered the rule */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    @inline def withUserId(newValue: UserId): AutoModerationActionExecution =
      objWith(AutoModerationActionExecution, "user_id", newValue)

    /** ID of the channel in which user content was posted */
    @inline def channelId: UndefOr[TextGuildChannelId] = selectDynamic[UndefOr[TextGuildChannelId]]("channel_id")

    @inline def withChannelId(newValue: UndefOr[TextGuildChannelId]): AutoModerationActionExecution =
      objWithUndef(AutoModerationActionExecution, "channel_id", newValue)

    /** ID of any user message which content belongs to */
    @inline def messageId: UndefOr[MessageId] = selectDynamic[UndefOr[MessageId]]("message_id")

    @inline def withMessageId(newValue: UndefOr[MessageId]): AutoModerationActionExecution =
      objWithUndef(AutoModerationActionExecution, "message_id", newValue)

    /**
      * ID of any system auto moderation messages posted as a result of this
      * action
      */
    @inline def alertSystemMessageId: UndefOr[MessageId] = selectDynamic[UndefOr[MessageId]]("alert_system_message_id")

    @inline def withAlertSystemMessageId(newValue: UndefOr[MessageId]): AutoModerationActionExecution =
      objWithUndef(AutoModerationActionExecution, "alert_system_message_id", newValue)

    /** User-generated text content */
    @inline def content: String = selectDynamic[String]("content")

    @inline def withContent(newValue: String): AutoModerationActionExecution =
      objWith(AutoModerationActionExecution, "content", newValue)

    /** Word or phrase configured in the rule that triggered the rule */
    @inline def matchedKeyword: Option[String] = selectDynamic[Option[String]]("matched_keyword")

    @inline def withMatchedKeyword(newValue: Option[String]): AutoModerationActionExecution =
      objWith(AutoModerationActionExecution, "matched_keyword", newValue)

    /** Substring in content that triggered the rule */
    @inline def matchedContent: Option[String] = selectDynamic[Option[String]]("matched_content")

    @inline def withMatchedContent(newValue: Option[String]): AutoModerationActionExecution =
      objWith(AutoModerationActionExecution, "matched_content", newValue)

    override def values: Seq[() => Any] = Seq(
      () => guildId,
      () => action,
      () => ruleId,
      () => ruleTriggerType,
      () => userId,
      () => channelId,
      () => messageId,
      () => alertSystemMessageId,
      () => content,
      () => matchedKeyword,
      () => matchedContent
    )
  }
  object AutoModerationActionExecution extends DiscordObjectCompanion[AutoModerationActionExecution] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationActionExecution =
      new AutoModerationActionExecution(json, cache)

    /**
      * @param guildId
      *   ID of the guild in which action was executed
      * @param action
      *   Action which was executed
      * @param ruleId
      *   ID of the rule which action belongs to
      * @param ruleTriggerType
      *   Trigger type of rule which was triggered
      * @param userId
      *   ID of the user which generated the content which triggered the rule
      * @param channelId
      *   ID of the channel in which user content was posted
      * @param messageId
      *   ID of any user message which content belongs to
      * @param alertSystemMessageId
      *   ID of any system auto moderation messages posted as a result of this
      *   action
      * @param content
      *   User-generated text content
      * @param matchedKeyword
      *   Word or phrase configured in the rule that triggered the rule
      * @param matchedContent
      *   Substring in content that triggered the rule
      */
    def make20(
        guildId: GuildId,
        action: AutoModerationRule.AutoModerationRuleAction,
        ruleId: Snowflake[AutoModerationRule],
        ruleTriggerType: AutoModerationRule.AutoModerationRuleTriggerType,
        userId: UserId,
        channelId: UndefOr[TextGuildChannelId] = UndefOrUndefined,
        messageId: UndefOr[MessageId] = UndefOrUndefined,
        alertSystemMessageId: UndefOr[MessageId] = UndefOrUndefined,
        content: String,
        matchedKeyword: Option[String],
        matchedContent: Option[String]
    ): AutoModerationActionExecution = makeRawFromFields(
      "guild_id"                 := guildId,
      "action"                   := action,
      "rule_id"                  := ruleId,
      "rule_trigger_type"        := ruleTriggerType,
      "user_id"                  := userId,
      "channel_id"              :=? channelId,
      "message_id"              :=? messageId,
      "alert_system_message_id" :=? alertSystemMessageId,
      "content"                  := content,
      "matched_keyword"          := matchedKeyword,
      "matched_content"          := matchedContent
    )
  }

  /**
    * Sent when a new guild channel is created, relevant to the current user.
    * The inner payload is a channel object.
    */
  class ChannelCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: GuildChannel = GuildChannel.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: GuildChannel): ChannelCreate =
      objWithJson(ChannelCreate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ChannelCreate extends DiscordObjectCompanion[ChannelCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelCreate = new ChannelCreate(json, cache)

    def make20(data: GuildChannel): ChannelCreate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))
  }

  /**
    * Sent when a channel is updated. The inner payload is a channel object.
    * This is not sent when the field last_message_id is altered. To keep track
    * of the last_message_id changes, you must listen for Message Create events
    * (or Thread Create events for GUILD_FORUM channels).
    *
    * This event may reference roles or guild members that no longer exist in
    * the guild.
    */
  class ChannelUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: GuildChannel = GuildChannel.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: GuildChannel): ChannelUpdate =
      objWithJson(ChannelUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ChannelUpdate extends DiscordObjectCompanion[ChannelUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelUpdate = new ChannelUpdate(json, cache)

    def make20(data: GuildChannel): ChannelUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))
  }

  /**
    * Sent when a channel relevant to the current user is deleted. The inner
    * payload is a channel object.
    */
  class ChannelDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: GuildChannel = GuildChannel.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: GuildChannel): ChannelDelete =
      objWithJson(ChannelDelete, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ChannelDelete extends DiscordObjectCompanion[ChannelDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelDelete = new ChannelDelete(json, cache)

    def make20(data: GuildChannel): ChannelDelete = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))
  }

  /**
    * Sent when a thread is created, relevant to the current user, or when the
    * current user is added to a thread. The inner payload is a channel object.
    *   - When a thread is created, includes an additional newly_created boolean
    *     field.
    *   - When being added to an existing private thread, includes a thread
    *     member object.
    */
  class ThreadCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: ThreadChannel = ThreadChannel.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: ThreadChannel): ThreadCreate =
      objWithJson(ThreadCreate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ThreadCreate extends DiscordObjectCompanion[ThreadCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadCreate = new ThreadCreate(json, cache)

    def make20(data: ThreadChannel): ThreadCreate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))
  }

  /**
    * Sent when a thread is updated. The inner payload is a channel object. This
    * is not sent when the field last_message_id is altered. To keep track of
    * the last_message_id changes, you must listen for Message Create events.
    */
  class ThreadUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def data: ThreadChannel = ThreadChannel.makeRaw(json, extensionCache("data"))

    @inline def withData(newValue: ThreadChannel): ThreadUpdate =
      objWithJson(ThreadUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ThreadUpdate extends DiscordObjectCompanion[ThreadUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadUpdate = new ThreadUpdate(json, cache)

    def make20(data: ThreadChannel): ThreadUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))
  }

  /**
    * Sent when a thread relevant to the current user is deleted. The inner
    * payload is a subset of the channel object, containing just the id,
    * guild_id, parent_id, and type.
    */
  class ThreadDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def id: ThreadChannelId = selectDynamic[ThreadChannelId]("id")

    @inline def withId(newValue: ThreadChannelId): ThreadDelete = objWith(ThreadDelete, "id", newValue)

    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): ThreadDelete = objWith(ThreadDelete, "guild_id", newValue)

    @inline def parentId: GuildChannelId = selectDynamic[GuildChannelId]("parent_id")

    @inline def withParentId(newValue: GuildChannelId): ThreadDelete =
      objWith(ThreadDelete, "parent_id", newValue)

    @inline def tpe: Channel.ChannelType = selectDynamic[Channel.ChannelType]("type")

    @inline def withTpe(newValue: Channel.ChannelType): ThreadDelete =
      objWith(ThreadDelete, "type", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => guildId, () => parentId, () => tpe)
  }
  object ThreadDelete extends DiscordObjectCompanion[ThreadDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadDelete = new ThreadDelete(json, cache)

    def make20(
        id: ThreadChannelId,
        guildId: GuildId,
        parentId: GuildChannelId,
        tpe: Channel.ChannelType
    ): ThreadDelete = makeRawFromFields("id" := id, "guild_id" := guildId, "parent_id" := parentId, "type" := tpe)
  }

  /** Sent when the current user gains access to a channel. */
  class ThreadListSync(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): ThreadListSync = objWith(ThreadListSync, "guild_id", newValue)

    /**
      * Parent channel IDs whose threads are being synced. If omitted, then
      * threads were synced for the entire guild. This array may contain
      * channel_ids that have no active threads as well, so you know to clear
      * that data.
      */
    @inline def channelIds: Seq[GuildChannelId] = selectDynamic[Seq[GuildChannelId]]("channel_ids")

    @inline def withChannelIds(newValue: Seq[GuildChannelId]): ThreadListSync =
      objWith(ThreadListSync, "channel_ids", newValue)

    /**
      * All active threads in the given channels that the current user can
      * access
      */
    @inline def threads: Seq[ThreadChannel] = selectDynamic[Seq[ThreadChannel]]("threads")

    @inline def withThreads(newValue: Seq[ThreadChannel]): ThreadListSync =
      objWith(ThreadListSync, "threads", newValue)

    /**
      * All thread member objects from the synced threads for the current user,
      * indicating which threads the current user has been added to
      */
    @inline def members: Seq[Channel.ThreadMember] = selectDynamic[Seq[Channel.ThreadMember]]("members")

    @inline def withMembers(newValue: Seq[Channel.ThreadMember]): ThreadListSync =
      objWith(ThreadListSync, "members", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => channelIds, () => threads, () => members)
  }
  object ThreadListSync extends DiscordObjectCompanion[ThreadListSync] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadListSync =
      new ThreadListSync(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param channelIds
      *   Parent channel IDs whose threads are being synced. If omitted, then
      *   threads were synced for the entire guild. This array may contain
      *   channel_ids that have no active threads as well, so you know to clear
      *   that data.
      * @param threads
      *   All active threads in the given channels that the current user can
      *   access
      * @param members
      *   All thread member objects from the synced threads for the current
      *   user, indicating which threads the current user has been added to
      */
    def make20(
        guildId: GuildId,
        channelIds: Seq[GuildChannelId],
        threads: Seq[ThreadChannel],
        members: Seq[Channel.ThreadMember]
    ): ThreadListSync =
      makeRawFromFields("guild_id" := guildId, "channel_ids" := channelIds, "threads" := threads, "members" := members)
  }

  /**
    * Sent when the thread member object for the current user is updated. The
    * inner payload is a thread member object with an extra guild_id field. This
    * event is documented for completeness, but unlikely to be used by most
    * bots. For bots, this event largely is just a signal that you are a member
    * of the thread. See the threads docs for more details
    */
  class ThreadMemberUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): ThreadMemberUpdate = objWith(ThreadMemberUpdate, "guild_id", newValue)

    /** Rest of the thread member object */
    @inline def threadMember: Channel.ThreadMember = Channel.ThreadMember.makeRaw(json, extensionCache("thread_member"))

    @inline def withThreadMember(newValue: Channel.ThreadMember): ThreadMemberUpdate =
      objWithJson(ThreadMemberUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => guildId, () => threadMember)
  }
  object ThreadMemberUpdate extends DiscordObjectCompanion[ThreadMemberUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMemberUpdate =
      new ThreadMemberUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param threadMember
      *   Rest of the thread member object
      */
    def make20(guildId: GuildId, threadMember: Channel.ThreadMember): ThreadMemberUpdate =
      makeRawFromFields("guild_id" := guildId, DiscordObjectFrom.FromExtension("thread_member", threadMember))
  }

  /**
    * Sent when anyone is added to or removed from a thread. If the current user
    * does not have the GUILD_MEMBERS Gateway Intent, then this event will only
    * be sent if the current user was added to or removed from the thread.
    */
  class ThreadMembersUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the thread */
    @inline def id: ThreadChannelId = selectDynamic[ThreadChannelId]("id")

    @inline def withId(newValue: ThreadChannelId): ThreadMembersUpdate =
      objWith(ThreadMembersUpdate, "id", newValue)

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): ThreadMembersUpdate = objWith(ThreadMembersUpdate, "guild_id", newValue)

    /** Approximate number of members in the thread, capped at 50 */
    @inline def memberCount: Int = selectDynamic[Int]("member_count")

    @inline def withMemberCount(newValue: Int): ThreadMembersUpdate =
      objWith(ThreadMembersUpdate, "member_count", newValue)

    /** Users who were added to the thread */
    @inline def addedMembers: UndefOr[Seq[Channel.ThreadMember]] =
      selectDynamic[UndefOr[Seq[Channel.ThreadMember]]]("added_members")

    @inline def withAddedMembers(newValue: UndefOr[Seq[Channel.ThreadMember]]): ThreadMembersUpdate =
      objWithUndef(ThreadMembersUpdate, "added_members", newValue)

    /** ID of the users who were removed from the thread */
    @inline def removedMemberIds: UndefOr[Seq[UserId]] = selectDynamic[UndefOr[Seq[UserId]]]("removed_member_ids")

    @inline def withRemovedMemberIds(newValue: UndefOr[Seq[UserId]]): ThreadMembersUpdate =
      objWithUndef(ThreadMembersUpdate, "removed_member_ids", newValue)

    override def values: Seq[() => Any] =
      Seq(() => id, () => guildId, () => memberCount, () => addedMembers, () => removedMemberIds)
  }
  object ThreadMembersUpdate extends DiscordObjectCompanion[ThreadMembersUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMembersUpdate =
      new ThreadMembersUpdate(json, cache)

    /**
      * @param id
      *   ID of the thread
      * @param guildId
      *   ID of the guild
      * @param memberCount
      *   Approximate number of members in the thread, capped at 50
      * @param addedMembers
      *   Users who were added to the thread
      * @param removedMemberIds
      *   ID of the users who were removed from the thread
      */
    def make20(
        id: ThreadChannelId,
        guildId: GuildId,
        memberCount: Int,
        addedMembers: UndefOr[Seq[Channel.ThreadMember]] = UndefOrUndefined,
        removedMemberIds: UndefOr[Seq[UserId]] = UndefOrUndefined
    ): ThreadMembersUpdate = makeRawFromFields(
      "id"                  := id,
      "guild_id"            := guildId,
      "member_count"        := memberCount,
      "added_members"      :=? addedMembers,
      "removed_member_ids" :=? removedMemberIds
    )
  }

  /**
    * Sent when a message is pinned or unpinned in a text channel. This is not
    * sent when a pinned message is deleted.
    */
  class ChannelPinsUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): ChannelPinsUpdate =
      objWithUndef(ChannelPinsUpdate, "guild_id", newValue)

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): ChannelPinsUpdate =
      objWith(ChannelPinsUpdate, "channel_id", newValue)

    /** Time at which the most recent pinned message was pinned */
    @inline def lastPinTimestamp: JsonOption[OffsetDateTime] =
      selectDynamic[JsonOption[OffsetDateTime]]("last_pin_timestamp")

    @inline def withLastPinTimestamp(newValue: JsonOption[OffsetDateTime]): ChannelPinsUpdate =
      objWithUndef(ChannelPinsUpdate, "last_pin_timestamp", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => channelId, () => lastPinTimestamp)
  }
  object ChannelPinsUpdate extends DiscordObjectCompanion[ChannelPinsUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelPinsUpdate =
      new ChannelPinsUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param channelId
      *   ID of the channel
      * @param lastPinTimestamp
      *   Time at which the most recent pinned message was pinned
      */
    def make20(
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        channelId: TextChannelId,
        lastPinTimestamp: JsonOption[OffsetDateTime] = JsonUndefined
    ): ChannelPinsUpdate =
      makeRawFromFields("guild_id" :=? guildId, "channel_id" := channelId, "last_pin_timestamp" :=? lastPinTimestamp)
  }

  /**
    * This event can be sent in three different scenarios:
    *   1. When a user is initially connecting, to lazily load and backfill
    *      information for all unavailable guilds sent in the Ready event.
    *      Guilds that are unavailable due to an outage will send a Guild Delete
    *      event. 2. When a Guild becomes available again to the client. 3. When
    *      the current user joins a new Guild.
    *
    * During an outage, the guild object in scenarios 1 and 3 may be marked as
    * unavailable.
    *
    * The inner payload can be:
    *   1. An available Guild: a guild object with extra fields, as noted below.
    *      2. An unavailable Guild: an unavailable guild object.
    */
  class GuildCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def guild: GuildCreate.GuildCreateGuild =
      GuildCreate.GuildCreateGuild.makeRaw(json, extensionCache("guild"))

    @inline def withGuild(newValue: GuildCreate.GuildCreateGuild): GuildCreate =
      objWithJson(GuildCreate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => guild)
  }
  object GuildCreate extends DiscordObjectCompanion[GuildCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildCreate = new GuildCreate(json, cache)

    def make20(guild: GuildCreate.GuildCreateGuild): GuildCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("guild", guild)
    )

    sealed trait GuildCreateGuild extends DiscordObject

    object GuildCreateGuild extends DiscordObjectCompanion[GuildCreateGuild] {
      override def makeRaw(json: Json, cache: Map[String, Any]): GuildCreateGuild = {
        if (json.hcursor.getOrElse[Boolean]("unavailable")(false).contains(true)) {
          GuildCreateUnavailableGuild.makeRaw(json, cache)
        } else {
          AvailableGuild.makeRaw(json, cache)
        }
      }
    }

    class AvailableGuild(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache)
        with GuildCreateGuild {

      @inline def guild: Guild = Guild.makeRaw(json, extensionCache("guild"))

      @inline def withGuild(newValue: Guild): AvailableGuild =
        objWithJson(AvailableGuild, newValue.json, newValue.cacheCopy)

      /** When this guild was joined at */
      @inline def joinedAt: OffsetDateTime = selectDynamic[OffsetDateTime]("joined_at")

      @inline def withJoinedAt(newValue: OffsetDateTime): AvailableGuild =
        objWith(AvailableGuild, "joined_at", newValue)

      /** True if this is considered a large guild */
      @inline def large: Boolean = selectDynamic[Boolean]("large")

      @inline def withLarge(newValue: Boolean): AvailableGuild = objWith(AvailableGuild, "large", newValue)

      /** Total number of members in this guild */
      @inline def memberCount: Int = selectDynamic[Int]("member_count")

      @inline def withMemberCount(newValue: Int): AvailableGuild = objWith(AvailableGuild, "member_count", newValue)

      /**
        * States of members currently in voice channels; lacks the guild_id key
        */
      @inline def voiceStates: Seq[VoiceState] = selectDynamic[Seq[VoiceState]]("voice_states")

      @inline def withVoiceStates(newValue: Seq[VoiceState]): AvailableGuild =
        objWith(AvailableGuild, "voice_states", newValue)

      /** Users in the guild */
      @inline def members: Seq[GuildMember] = selectDynamic[Seq[GuildMember]]("members")

      @inline def withMembers(newValue: Seq[GuildMember]): AvailableGuild =
        objWith(AvailableGuild, "members", newValue)

      /** Channels in the guild */
      @inline def channels: Seq[GuildChannel] = selectDynamic[Seq[GuildChannel]]("channels")

      @inline def withChannels(newValue: Seq[GuildChannel]): AvailableGuild =
        objWith(AvailableGuild, "channels", newValue)

      /**
        * All active threads in the guild that current user has permission to
        * view
        */
      @inline def threads: Seq[ThreadChannel] = selectDynamic[Seq[ThreadChannel]]("threads")

      @inline def withThreads(newValue: Seq[ThreadChannel]): AvailableGuild =
        objWith(AvailableGuild, "threads", newValue)

      /**
        * Presences of the members in the guild, will only include non-offline
        * members if the size is greater than large threshold
        */
      @inline def presences: Seq[AvailableGuild.AvailableGuildPresenceUpdate] =
        selectDynamic[Seq[AvailableGuild.AvailableGuildPresenceUpdate]]("presences")

      @inline def withPresences(
          newValue: Seq[AvailableGuild.AvailableGuildPresenceUpdate]
      ): AvailableGuild = objWith(AvailableGuild, "presences", newValue)

      /** Stage instances in the guild */
      @inline def stageInstances: Seq[StageInstance] = selectDynamic[Seq[StageInstance]]("stage_instances")

      @inline def withStageInstances(newValue: Seq[StageInstance]): AvailableGuild =
        objWith(AvailableGuild, "stage_instances", newValue)

      /** Scheduled events in the guild */
      @inline def guildScheduledEvents: Seq[GuildScheduledEvent] =
        selectDynamic[Seq[GuildScheduledEvent]]("guild_scheduled_events")

      @inline def withGuildScheduledEvents(newValue: Seq[GuildScheduledEvent]): AvailableGuild =
        objWith(AvailableGuild, "guild_scheduled_events", newValue)

      override def values: Seq[() => Any] = Seq(
        () => guild,
        () => joinedAt,
        () => large,
        () => memberCount,
        () => voiceStates,
        () => members,
        () => channels,
        () => threads,
        () => presences,
        () => stageInstances,
        () => guildScheduledEvents
      )
    }
    object AvailableGuild extends DiscordObjectCompanion[AvailableGuild] {
      def makeRaw(json: Json, cache: Map[String, Any]): AvailableGuild =
        new AvailableGuild(json, cache)

      /**
        * @param joinedAt
        *   When this guild was joined at
        * @param large
        *   True if this is considered a large guild
        * @param memberCount
        *   Total number of members in this guild
        * @param voiceStates
        *   States of members currently in voice channels; lacks the guild_id
        *   key
        * @param members
        *   Users in the guild
        * @param channels
        *   Channels in the guild
        * @param threads
        *   All active threads in the guild that current user has permission to
        *   view
        * @param presences
        *   Presences of the members in the guild, will only include non-offline
        *   members if the size is greater than large threshold
        * @param stageInstances
        *   Stage instances in the guild
        * @param guildScheduledEvents
        *   Scheduled events in the guild
        */
      def make20(
          guild: Guild,
          joinedAt: OffsetDateTime,
          large: Boolean,
          memberCount: Int,
          voiceStates: Seq[VoiceState],
          members: Seq[GuildMember],
          channels: Seq[GuildChannel],
          threads: Seq[ThreadChannel],
          presences: Seq[AvailableGuild.AvailableGuildPresenceUpdate],
          stageInstances: Seq[StageInstance],
          guildScheduledEvents: Seq[GuildScheduledEvent]
      ): AvailableGuild = makeRawFromFields(
        DiscordObjectFrom.FromExtension("guild", guild),
        "joined_at"              := joinedAt,
        "large"                  := large,
        "member_count"           := memberCount,
        "voice_states"           := voiceStates,
        "members"                := members,
        "channels"               := channels,
        "threads"                := threads,
        "presences"              := presences,
        "stage_instances"        := stageInstances,
        "guild_scheduled_events" := guildScheduledEvents
      )

      class AvailableGuildPresenceUpdate(json: Json, cache: Map[String, Any] = Map.empty)
          extends DiscordObject(json, cache) {

        @inline def presenceUpdate: PresenceUpdate = PresenceUpdate.makeRaw(json, extensionCache("presenceUpdate"))

        @inline def withPresenceUpdate(newValue: PresenceUpdate): AvailableGuildPresenceUpdate =
          objWithJson(AvailableGuildPresenceUpdate, newValue.json, newValue.cacheCopy)

        override def values: Seq[() => Any] = Seq(() => presenceUpdate)
      }
      object AvailableGuildPresenceUpdate extends DiscordObjectCompanion[AvailableGuildPresenceUpdate] {
        def makeRaw(json: Json, cache: Map[String, Any]): AvailableGuildPresenceUpdate =
          new AvailableGuildPresenceUpdate(json, cache)

        def make20(presenceUpdate: PresenceUpdate): AvailableGuildPresenceUpdate =
          makeRawFromFields(DiscordObjectFrom.FromExtension("presenceUpdate", presenceUpdate))
      }
    }

    class GuildCreateUnavailableGuild(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache)
        with GuildCreateGuild {

      @inline def guild: UnavailableGuild = UnavailableGuild.makeRaw(json, extensionCache("guild"))

      @inline def withGuild(newValue: UnavailableGuild): GuildCreateUnavailableGuild =
        objWithJson(GuildCreateUnavailableGuild, newValue.json, newValue.cacheCopy)

      override def values: Seq[() => Any] = Seq(() => guild)
    }
    object GuildCreateUnavailableGuild extends DiscordObjectCompanion[GuildCreateUnavailableGuild] {
      def makeRaw(json: Json, cache: Map[String, Any]): GuildCreateUnavailableGuild =
        new GuildCreateUnavailableGuild(json, cache)

      def make20(guild: UnavailableGuild): GuildCreateUnavailableGuild =
        makeRawFromFields(DiscordObjectFrom.FromExtension("guild", guild))
    }
  }

  /** Sent when a guild is updated. The inner payload is a guild object. */
  class GuildUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def guild: Guild = Guild.makeRaw(json, extensionCache("guild"))

    @inline def withGuild(newValue: Guild): GuildUpdate = objWithJson(GuildUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => guild)
  }
  object GuildUpdate extends DiscordObjectCompanion[GuildUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildUpdate = new GuildUpdate(json, cache)

    def make20(guild: Guild): GuildUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("guild", guild))
  }

  /**
    * Sent when a guild becomes or was already unavailable due to an outage, or
    * when the user leaves or is removed from a guild. The inner payload is an
    * unavailable guild object. If the unavailable field is not set, the user
    * was removed from the guild.
    */
  class GuildDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def unavailableGuild: UnavailableGuild = UnavailableGuild.makeRaw(json, extensionCache("unavailable_guild"))

    @inline def withUnavailableGuild(newValue: UnavailableGuild): GuildDelete =
      objWithJson(GuildDelete, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => unavailableGuild)
  }
  object GuildDelete extends DiscordObjectCompanion[GuildDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildDelete = new GuildDelete(json, cache)

    def make20(unavailableGuild: UnavailableGuild): GuildDelete = makeRawFromFields(
      DiscordObjectFrom.FromExtension("unavailable_guild", unavailableGuild)
    )
  }

  /**
    * Sent when a guild audit log entry is created. The inner payload is an
    * Audit Log Entry object. This event is only sent to bots with the
    * VIEW_AUDIT_LOG permission.
    */
  class GuildAuditLogEntryCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def auditLogEntry: AuditLog.AuditLogEntry =
      AuditLog.AuditLogEntry.makeRaw(json, extensionCache("audit_log_entry"))

    @inline def withAuditLogEntry(newValue: AuditLog.AuditLogEntry): GuildAuditLogEntryCreate =
      objWithJson(GuildAuditLogEntryCreate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => auditLogEntry)
  }
  object GuildAuditLogEntryCreate extends DiscordObjectCompanion[GuildAuditLogEntryCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildAuditLogEntryCreate =
      new GuildAuditLogEntryCreate(json, cache)

    def make20(auditLogEntry: AuditLog.AuditLogEntry): GuildAuditLogEntryCreate =
      makeRawFromFields(DiscordObjectFrom.FromExtension("audit_log_entry", auditLogEntry))
  }

  /** Sent when a user is banned from a guild. */
  class GuildBanAdd(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildBanAdd = objWith(GuildBanAdd, "guild_id", newValue)

    /** User who was banned */
    @inline def user: User = selectDynamic[User]("user")

    @inline def withUser(newValue: User): GuildBanAdd = objWith(GuildBanAdd, "user", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => user)
  }
  object GuildBanAdd extends DiscordObjectCompanion[GuildBanAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildBanAdd = new GuildBanAdd(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param user
      *   User who was banned
      */
    def make20(guildId: GuildId, user: User): GuildBanAdd = makeRawFromFields("guild_id" := guildId, "user" := user)
  }

  /** Sent when a user is unbanned from a guild. */
  class GuildBanRemove(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildBanRemove = objWith(GuildBanRemove, "guild_id", newValue)

    /** User who was unbanned */
    @inline def user: User = selectDynamic[User]("user")

    @inline def withUser(newValue: User): GuildBanRemove = objWith(GuildBanRemove, "user", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => user)
  }
  object GuildBanRemove extends DiscordObjectCompanion[GuildBanRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildBanRemove =
      new GuildBanRemove(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param user
      *   User who was unbanned
      */
    def make20(guildId: GuildId, user: User): GuildBanRemove = makeRawFromFields("guild_id" := guildId, "user" := user)
  }

  /** Sent when a guild's emojis have been updated. */
  class GuildEmojisUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildEmojisUpdate = objWith(GuildEmojisUpdate, "guild_id", newValue)

    /** Array of emojis */
    @inline def emojis: Seq[Emoji] = selectDynamic[Seq[Emoji]]("emojis")

    @inline def withEmojis(newValue: Seq[Emoji]): GuildEmojisUpdate = objWith(GuildEmojisUpdate, "emojis", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => emojis)
  }
  object GuildEmojisUpdate extends DiscordObjectCompanion[GuildEmojisUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildEmojisUpdate =
      new GuildEmojisUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param emojis
      *   Array of emojis
      */
    def make20(guildId: GuildId, emojis: Seq[Emoji]): GuildEmojisUpdate =
      makeRawFromFields("guild_id" := guildId, "emojis" := emojis)
  }

  /** Sent when a guild's stickers have been updated. */
  class GuildStickersUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildStickersUpdate = objWith(GuildStickersUpdate, "guild_id", newValue)

    /** Array of stickers */
    @inline def stickers: Seq[Sticker] = selectDynamic[Seq[Sticker]]("stickers")

    @inline def withStickers(newValue: Seq[Sticker]): GuildStickersUpdate =
      objWith(GuildStickersUpdate, "stickers", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => stickers)
  }
  object GuildStickersUpdate extends DiscordObjectCompanion[GuildStickersUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildStickersUpdate =
      new GuildStickersUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param stickers
      *   Array of stickers
      */
    def make20(guildId: GuildId, stickers: Seq[Sticker]): GuildStickersUpdate =
      makeRawFromFields("guild_id" := guildId, "stickers" := stickers)
  }

  /** Sent when a guild integration is updated. */
  class GuildIntegrationsUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild whose integrations were updated */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildIntegrationsUpdate =
      objWith(GuildIntegrationsUpdate, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId)
  }
  object GuildIntegrationsUpdate extends DiscordObjectCompanion[GuildIntegrationsUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildIntegrationsUpdate =
      new GuildIntegrationsUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild whose integrations were updated
      */
    def make20(guildId: GuildId): GuildIntegrationsUpdate = makeRawFromFields("guild_id" := guildId)
  }

  /**
    * Sent when a new user joins a guild. The inner payload is a guild member
    * object with an extra guild_id key:
    */
  class GuildMemberAdd(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildMemberAdd = objWith(GuildMemberAdd, "guild_id", newValue)

    @inline def guildMember: GuildMember = GuildMember.makeRaw(json, extensionCache("guild_member"))

    @inline def withGuildMember(newValue: GuildMember): GuildMemberAdd =
      objWithJson(GuildMemberAdd, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => guildId, () => guildMember)
  }
  object GuildMemberAdd extends DiscordObjectCompanion[GuildMemberAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMemberAdd =
      new GuildMemberAdd(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      */
    def make20(guildId: GuildId, guildMember: GuildMember): GuildMemberAdd =
      makeRawFromFields("guild_id" := guildId, DiscordObjectFrom.FromExtension("guild_member", guildMember))
  }

  /** Sent when a user is removed from a guild (leave/kick/ban). */
  class GuildMemberRemove(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildMemberRemove = objWith(GuildMemberRemove, "guild_id", newValue)

    /** User who was removed */
    @inline def user: User = selectDynamic[User]("user")

    @inline def withUser(newValue: User): GuildMemberRemove = objWith(GuildMemberRemove, "user", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => user)
  }
  object GuildMemberRemove extends DiscordObjectCompanion[GuildMemberRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMemberRemove =
      new GuildMemberRemove(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param user
      *   User who was removed
      */
    def make20(guildId: GuildId, user: User): GuildMemberRemove =
      makeRawFromFields("guild_id" := guildId, "user" := user)
  }

  /**
    * Sent when a guild member is updated. This will also fire when the user
    * object of a guild member changes.
    */
  class GuildMemberUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildMemberUpdate = objWith(GuildMemberUpdate, "guild_id", newValue)

    /** User role ids */
    @inline def roles: Seq[RoleId] = selectDynamic[Seq[RoleId]]("roles")

    @inline def withRoles(newValue: Seq[RoleId]): GuildMemberUpdate = objWith(GuildMemberUpdate, "roles", newValue)

    /** User */
    @inline def user: User = selectDynamic[User]("user")

    @inline def withUser(newValue: User): GuildMemberUpdate = objWith(GuildMemberUpdate, "user", newValue)

    /** Nickname of the user in the guild */
    @inline def nick: JsonOption[String] = selectDynamic[JsonOption[String]]("nick")

    @inline def withNick(newValue: JsonOption[String]): GuildMemberUpdate =
      objWithUndef(GuildMemberUpdate, "nick", newValue)

    /** Member's guild avatar hash */
    @inline def avatar: Option[ImageHash] = selectDynamic[Option[ImageHash]]("avatar")

    @inline def withAvatar(newValue: Option[ImageHash]): GuildMemberUpdate =
      objWith(GuildMemberUpdate, "avatar", newValue)

    /** When the user joined the guild */
    @inline def joinedAt: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("joined_at")

    @inline def withJoinedAt(newValue: Option[OffsetDateTime]): GuildMemberUpdate =
      objWith(GuildMemberUpdate, "joined_at", newValue)

    /** When the user starting boosting the guild */
    @inline def premiumSince: JsonOption[OffsetDateTime] = selectDynamic[JsonOption[OffsetDateTime]]("premium_since")

    @inline def withPremiumSince(newValue: JsonOption[OffsetDateTime]): GuildMemberUpdate =
      objWithUndef(GuildMemberUpdate, "premium_since", newValue)

    /** Whether the user is deafened in voice channels */
    @inline def deaf: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("deaf")

    @inline def withDeaf(newValue: UndefOr[Boolean]): GuildMemberUpdate =
      objWithUndef(GuildMemberUpdate, "deaf", newValue)

    /** Whether the user is muted in voice channels */
    @inline def mute: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("mute")

    @inline def withMute(newValue: UndefOr[Boolean]): GuildMemberUpdate =
      objWithUndef(GuildMemberUpdate, "mute", newValue)

    /**
      * Whether the user has not yet passed the guild's Membership Screening
      * requirements
      */
    @inline def pending: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("pending")

    @inline def withPending(newValue: UndefOr[Boolean]): GuildMemberUpdate =
      objWithUndef(GuildMemberUpdate, "pending", newValue)

    /**
      * When the user's timeout will expire and the user will be able to
      * communicate in the guild again, null or a time in the past if the user
      * is not timed out
      */
    @inline def communicationDisabledUntil: JsonOption[OffsetDateTime] =
      selectDynamic[JsonOption[OffsetDateTime]]("communication_disabled_until")

    @inline def withCommunicationDisabledUntil(newValue: JsonOption[OffsetDateTime]): GuildMemberUpdate =
      objWithUndef(GuildMemberUpdate, "communication_disabled_until", newValue)

    override def values: Seq[() => Any] = Seq(
      () => guildId,
      () => roles,
      () => user,
      () => nick,
      () => avatar,
      () => joinedAt,
      () => premiumSince,
      () => deaf,
      () => mute,
      () => pending,
      () => communicationDisabledUntil
    )
  }
  object GuildMemberUpdate extends DiscordObjectCompanion[GuildMemberUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMemberUpdate =
      new GuildMemberUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param roles
      *   User role ids
      * @param user
      *   User
      * @param nick
      *   Nickname of the user in the guild
      * @param avatar
      *   Member's guild avatar hash
      * @param joinedAt
      *   When the user joined the guild
      * @param premiumSince
      *   When the user starting boosting the guild
      * @param deaf
      *   Whether the user is deafened in voice channels
      * @param mute
      *   Whether the user is muted in voice channels
      * @param pending
      *   Whether the user has not yet passed the guild's Membership Screening
      *   requirements
      * @param communicationDisabledUntil
      *   When the user's timeout will expire and the user will be able to
      *   communicate in the guild again, null or a time in the past if the user
      *   is not timed out
      */
    def make20(
        guildId: GuildId,
        roles: Seq[RoleId],
        user: User,
        nick: JsonOption[String] = JsonUndefined,
        avatar: Option[ImageHash],
        joinedAt: Option[OffsetDateTime],
        premiumSince: JsonOption[OffsetDateTime] = JsonUndefined,
        deaf: UndefOr[Boolean] = UndefOrUndefined,
        mute: UndefOr[Boolean] = UndefOrUndefined,
        pending: UndefOr[Boolean] = UndefOrUndefined,
        communicationDisabledUntil: JsonOption[OffsetDateTime] = JsonUndefined
    ): GuildMemberUpdate = makeRawFromFields(
      "guild_id"                      := guildId,
      "roles"                         := roles,
      "user"                          := user,
      "nick"                         :=? nick,
      "avatar"                        := avatar,
      "joined_at"                     := joinedAt,
      "premium_since"                :=? premiumSince,
      "deaf"                         :=? deaf,
      "mute"                         :=? mute,
      "pending"                      :=? pending,
      "communication_disabled_until" :=? communicationDisabledUntil
    )
  }

  /**
    * Sent in response to Guild Request Members. You can use the chunk_index and
    * chunk_count to calculate how many chunks are left for your request.
    */
  class GuildMembersChunk(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildMembersChunk = objWith(GuildMembersChunk, "guild_id", newValue)

    /** Set of guild members */
    @inline def members: Seq[GuildMember] = selectDynamic[Seq[GuildMember]]("members")

    @inline def withMembers(newValue: Seq[GuildMember]): GuildMembersChunk =
      objWith(GuildMembersChunk, "members", newValue)

    /**
      * Chunk index in the expected chunks for this response (0 <= chunk_index <
      * chunk_count)
      */
    @inline def chunkIndex: Int = selectDynamic[Int]("chunk_index")

    @inline def withChunkIndex(newValue: Int): GuildMembersChunk = objWith(GuildMembersChunk, "chunk_index", newValue)

    /** Total number of expected chunks for this response */
    @inline def chunkCount: Int = selectDynamic[Int]("chunk_count")

    @inline def withChunkCount(newValue: Int): GuildMembersChunk = objWith(GuildMembersChunk, "chunk_count", newValue)

    /**
      * When passing an invalid ID to REQUEST_GUILD_MEMBERS, it will be returned
      * here
      */
    @inline def notFound: UndefOr[Seq[UserId]] = selectDynamic[UndefOr[Seq[UserId]]]("not_found")

    @inline def withNotFound(newValue: UndefOr[Seq[UserId]]): GuildMembersChunk =
      objWithUndef(GuildMembersChunk, "not_found", newValue)

    /**
      * When passing true to REQUEST_GUILD_MEMBERS, presences of the returned
      * members will be here
      */
    @inline def presences: UndefOr[Seq[PresenceUpdate]] = selectDynamic[UndefOr[Seq[PresenceUpdate]]]("presences")

    @inline def withPresences(newValue: UndefOr[Seq[PresenceUpdate]]): GuildMembersChunk =
      objWithUndef(GuildMembersChunk, "presences", newValue)

    /** Nonce used in the Guild Members Request */
    @inline def nonce: UndefOr[String] = selectDynamic[UndefOr[String]]("nonce")

    @inline def withNonce(newValue: UndefOr[String]): GuildMembersChunk =
      objWithUndef(GuildMembersChunk, "nonce", newValue)

    override def values: Seq[() => Any] = Seq(
      () => guildId,
      () => members,
      () => chunkIndex,
      () => chunkCount,
      () => notFound,
      () => presences,
      () => nonce
    )
  }
  object GuildMembersChunk extends DiscordObjectCompanion[GuildMembersChunk] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMembersChunk =
      new GuildMembersChunk(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param members
      *   Set of guild members
      * @param chunkIndex
      *   Chunk index in the expected chunks for this response (0 <= chunk_index
      *   < chunk_count)
      * @param chunkCount
      *   Total number of expected chunks for this response
      * @param notFound
      *   When passing an invalid ID to REQUEST_GUILD_MEMBERS, it will be
      *   returned here
      * @param presences
      *   When passing true to REQUEST_GUILD_MEMBERS, presences of the returned
      *   members will be here
      * @param nonce
      *   Nonce used in the Guild Members Request
      */
    def make20(
        guildId: GuildId,
        members: Seq[GuildMember],
        chunkIndex: Int,
        chunkCount: Int,
        notFound: UndefOr[Seq[UserId]] = UndefOrUndefined,
        presences: UndefOr[Seq[PresenceUpdate]] = UndefOrUndefined,
        nonce: UndefOr[String] = UndefOrUndefined
    ): GuildMembersChunk = makeRawFromFields(
      "guild_id"    := guildId,
      "members"     := members,
      "chunk_index" := chunkIndex,
      "chunk_count" := chunkCount,
      "not_found"  :=? notFound,
      "presences"  :=? presences,
      "nonce"      :=? nonce
    )
  }

  /** Sent when a guild role is created. */
  class GuildRoleCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildRoleCreate = objWith(GuildRoleCreate, "guild_id", newValue)

    /** Role that was created */
    @inline def role: Role = selectDynamic[Role]("role")

    @inline def withRole(newValue: Role): GuildRoleCreate = objWith(GuildRoleCreate, "role", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => role)
  }
  object GuildRoleCreate extends DiscordObjectCompanion[GuildRoleCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildRoleCreate =
      new GuildRoleCreate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param role
      *   Role that was created
      */
    def make20(guildId: GuildId, role: Role): GuildRoleCreate = makeRawFromFields("guild_id" := guildId, "role" := role)
  }

  /** Sent when a guild role is updated. */
  class GuildRoleUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildRoleUpdate = objWith(GuildRoleUpdate, "guild_id", newValue)

    /** Role that was updated */
    @inline def role: Role = selectDynamic[Role]("role")

    @inline def withRole(newValue: Role): GuildRoleUpdate = objWith(GuildRoleUpdate, "role", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => role)
  }
  object GuildRoleUpdate extends DiscordObjectCompanion[GuildRoleUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildRoleUpdate =
      new GuildRoleUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param role
      *   Role that was updated
      */
    def make20(guildId: GuildId, role: Role): GuildRoleUpdate = makeRawFromFields("guild_id" := guildId, "role" := role)
  }

  /** Sent when a guild role is deleted. */
  class GuildRoleDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildRoleDelete = objWith(GuildRoleDelete, "guild_id", newValue)

    /** ID of the role */
    @inline def roleId: RoleId = selectDynamic[RoleId]("role_id")

    @inline def withRoleId(newValue: RoleId): GuildRoleDelete = objWith(GuildRoleDelete, "role_id", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => roleId)
  }
  object GuildRoleDelete extends DiscordObjectCompanion[GuildRoleDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildRoleDelete =
      new GuildRoleDelete(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param roleId
      *   ID of the role
      */
    def make20(guildId: GuildId, roleId: RoleId): GuildRoleDelete =
      makeRawFromFields("guild_id" := guildId, "role_id" := roleId)
  }

  /**
    * Sent when a guild scheduled event is created. The inner payload is a guild
    * scheduled event object.
    */
  class GuildScheduledEventCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def scheduledEvent: GuildScheduledEvent =
      GuildScheduledEvent.makeRaw(json, extensionCache("scheduled_event"))

    @inline def withScheduledEvent(newValue: GuildScheduledEvent): GuildScheduledEventCreate =
      objWithJson(GuildScheduledEventCreate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => scheduledEvent)
  }
  object GuildScheduledEventCreate extends DiscordObjectCompanion[GuildScheduledEventCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventCreate =
      new GuildScheduledEventCreate(json, cache)

    def make20(scheduledEvent: GuildScheduledEvent): GuildScheduledEventCreate =
      makeRawFromFields(DiscordObjectFrom.FromExtension("scheduled_event", scheduledEvent))
  }

  /**
    * Sent when a guild scheduled event is updated. The inner payload is a guild
    * scheduled event object.
    */
  class GuildScheduledEventUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def scheduledEvent: GuildScheduledEvent =
      GuildScheduledEvent.makeRaw(json, extensionCache("scheduled_event"))

    @inline def withScheduledEvent(newValue: GuildScheduledEvent): GuildScheduledEventUpdate =
      objWithJson(GuildScheduledEventUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => scheduledEvent)
  }
  object GuildScheduledEventUpdate extends DiscordObjectCompanion[GuildScheduledEventUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventUpdate =
      new GuildScheduledEventUpdate(json, cache)

    def make20(scheduledEvent: GuildScheduledEvent): GuildScheduledEventUpdate =
      makeRawFromFields(DiscordObjectFrom.FromExtension("scheduled_event", scheduledEvent))
  }

  /**
    * Sent when a guild scheduled event is deleted. The inner payload is a guild
    * scheduled event object.
    */
  class GuildScheduledEventDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def scheduledEvent: GuildScheduledEvent =
      GuildScheduledEvent.makeRaw(json, extensionCache("scheduled_event"))

    @inline def withScheduledEvent(newValue: GuildScheduledEvent): GuildScheduledEventDelete =
      objWithJson(GuildScheduledEventDelete, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => scheduledEvent)
  }
  object GuildScheduledEventDelete extends DiscordObjectCompanion[GuildScheduledEventDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventDelete =
      new GuildScheduledEventDelete(json, cache)

    def make20(scheduledEvent: GuildScheduledEvent): GuildScheduledEventDelete =
      makeRawFromFields(DiscordObjectFrom.FromExtension("scheduled_event", scheduledEvent))
  }

  /** Sent when a user has subscribed to a guild scheduled event. */
  class GuildScheduledEventUserAdd(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def guildScheduledEventId: Snowflake[GuildScheduledEvent] =
      selectDynamic[Snowflake[GuildScheduledEvent]]("guild_scheduled_event_id")

    @inline def withGuildScheduledEventId(newValue: Snowflake[GuildScheduledEvent]): GuildScheduledEventUserAdd =
      objWith(GuildScheduledEventUserAdd, "guild_scheduled_event_id", newValue)

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    @inline def withUserId(newValue: UserId): GuildScheduledEventUserAdd =
      objWith(GuildScheduledEventUserAdd, "user_id", newValue)

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildScheduledEventUserAdd =
      objWith(GuildScheduledEventUserAdd, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => guildScheduledEventId, () => userId, () => guildId)
  }
  object GuildScheduledEventUserAdd extends DiscordObjectCompanion[GuildScheduledEventUserAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventUserAdd =
      new GuildScheduledEventUserAdd(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param guildId
      *   ID of the guild
      */
    def make20(
        guildScheduledEventId: Snowflake[GuildScheduledEvent],
        userId: UserId,
        guildId: GuildId
    ): GuildScheduledEventUserAdd =
      makeRawFromFields("guild_scheduled_event_id" := guildScheduledEventId, "user_id" := userId, "guild_id" := guildId)
  }

  /** Sent when a user has unsubscribed  to a guild scheduled event. */
  class GuildScheduledEventUserRemove(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def guildScheduledEventId: Snowflake[GuildScheduledEvent] =
      selectDynamic[Snowflake[GuildScheduledEvent]]("guild_scheduled_event_id")

    @inline def withGuildScheduledEventId(newValue: Snowflake[GuildScheduledEvent]): GuildScheduledEventUserRemove =
      objWith(GuildScheduledEventUserRemove, "guild_scheduled_event_id", newValue)

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    @inline def withUserId(newValue: UserId): GuildScheduledEventUserRemove =
      objWith(GuildScheduledEventUserRemove, "user_id", newValue)

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): GuildScheduledEventUserRemove =
      objWith(GuildScheduledEventUserRemove, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => guildScheduledEventId, () => userId, () => guildId)
  }
  object GuildScheduledEventUserRemove extends DiscordObjectCompanion[GuildScheduledEventUserRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventUserRemove =
      new GuildScheduledEventUserRemove(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param guildId
      *   ID of the guild
      */
    def make20(
        guildScheduledEventId: Snowflake[GuildScheduledEvent],
        userId: UserId,
        guildId: GuildId
    ): GuildScheduledEventUserRemove =
      makeRawFromFields("guild_scheduled_event_id" := guildScheduledEventId, "user_id" := userId, "guild_id" := guildId)
  }

  /**
    * Sent when an integration is created. The inner payload is an integration
    * object with an additional guild_id key:
    */
  class IntegrationCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def integration: Integration = Integration.makeRaw(json, extensionCache("integration"))

    @inline def withIntegration(newValue: Integration): IntegrationCreate =
      objWithJson(IntegrationCreate, newValue.json, newValue.cacheCopy)

    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): IntegrationCreate = objWith(IntegrationCreate, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => integration, () => guildId)
  }
  object IntegrationCreate extends DiscordObjectCompanion[IntegrationCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): IntegrationCreate =
      new IntegrationCreate(json, cache)

    def make20(integration: Integration, guildId: GuildId): IntegrationCreate =
      makeRawFromFields(DiscordObjectFrom.FromExtension("integration", integration), "guild_id" := guildId)
  }

  /**
    * Sent when an integration is updated. The inner payload is an integration
    * object with an additional guild_id key:
    */
  class IntegrationUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def integration: Integration = Integration.makeRaw(json, extensionCache("integration"))

    @inline def withIntegration(newValue: Integration): IntegrationUpdate =
      objWithJson(IntegrationUpdate, newValue.json, newValue.cacheCopy)

    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): IntegrationUpdate = objWith(IntegrationUpdate, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => integration, () => guildId)
  }
  object IntegrationUpdate extends DiscordObjectCompanion[IntegrationUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): IntegrationUpdate =
      new IntegrationUpdate(json, cache)

    def make20(integration: Integration, guildId: GuildId): IntegrationUpdate =
      makeRawFromFields(DiscordObjectFrom.FromExtension("integration", integration), "guild_id" := guildId)
  }

  /** Sent when an integration is deleted. */
  class IntegrationDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** Integration ID */
    @inline def id: Snowflake[Integration] = selectDynamic[Snowflake[Integration]]("id")

    @inline def withId(newValue: Snowflake[Integration]): IntegrationDelete =
      objWith(IntegrationDelete, "id", newValue)

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): IntegrationDelete = objWith(IntegrationDelete, "guild_id", newValue)

    /** ID of the bot/OAuth2 application for this discord integration */
    @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

    @inline def withApplicationId(newValue: UndefOr[ApplicationId]): IntegrationDelete =
      objWithUndef(IntegrationDelete, "application_id", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => guildId, () => applicationId)
  }
  object IntegrationDelete extends DiscordObjectCompanion[IntegrationDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): IntegrationDelete =
      new IntegrationDelete(json, cache)

    /**
      * @param id
      *   Integration ID
      * @param guildId
      *   ID of the guild
      * @param applicationId
      *   ID of the bot/OAuth2 application for this discord integration
      */
    def make20(
        id: Snowflake[Integration],
        guildId: GuildId,
        applicationId: UndefOr[ApplicationId] = UndefOrUndefined
    ): IntegrationDelete = makeRawFromFields("id" := id, "guild_id" := guildId, "application_id" :=? applicationId)
  }

  /** Sent when a new invite to a channel is created. */
  class InviteCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** Channel the invite is for */
    @inline def channelId: GuildChannelId = selectDynamic[GuildChannelId]("channel_id")

    @inline def withChannelId(newValue: GuildChannelId): InviteCreate =
      objWith(InviteCreate, "channel_id", newValue)

    /** Unique invite code */
    @inline def code: String = selectDynamic[String]("code")

    @inline def withCode(newValue: String): InviteCreate = objWith(InviteCreate, "code", newValue)

    /** Time at which the invite was created */
    @inline def createdAt: OffsetDateTime = selectDynamic[OffsetDateTime]("created_at")

    @inline def withCreatedAt(newValue: OffsetDateTime): InviteCreate =
      objWith(InviteCreate, "created_at", newValue)

    /** Guild of the invite */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): InviteCreate =
      objWithUndef(InviteCreate, "guild_id", newValue)

    /** User that created the invite */
    @inline def inviter: UndefOr[User] = selectDynamic[UndefOr[User]]("inviter")

    @inline def withInviter(newValue: UndefOr[User]): InviteCreate = objWithUndef(InviteCreate, "inviter", newValue)

    /** How long the invite is valid for (in seconds) */
    @inline def maxAge: Int = selectDynamic[Int]("max_age")

    @inline def withMaxAge(newValue: Int): InviteCreate = objWith(InviteCreate, "max_age", newValue)

    /** Maximum number of times the invite can be used */
    @inline def maxUses: Int = selectDynamic[Int]("max_uses")

    @inline def withMaxUses(newValue: Int): InviteCreate = objWith(InviteCreate, "max_uses", newValue)

    /** Type of target for this voice channel invite */
    @inline def targetType: UndefOr[Invite.InviteTargetType] =
      selectDynamic[UndefOr[Invite.InviteTargetType]]("target_type")

    @inline def withTargetType(newValue: UndefOr[Invite.InviteTargetType]): InviteCreate =
      objWithUndef(InviteCreate, "target_type", newValue)

    /** User whose stream to display for this voice channel stream invite */
    @inline def targetUser: UndefOr[User] = selectDynamic[UndefOr[User]]("target_user")

    @inline def withTargetUser(newValue: UndefOr[User]): InviteCreate =
      objWithUndef(InviteCreate, "target_user", newValue)

    /**
      * Embedded application to open for this voice channel embedded application
      * invite
      */
    @inline def targetApplication: UndefOr[Invite.InviteApplication] =
      selectDynamic[UndefOr[Invite.InviteApplication]]("target_application")

    @inline def withTargetApplication(newValue: UndefOr[Invite.InviteApplication]): InviteCreate =
      objWithUndef(InviteCreate, "target_application", newValue)

    /**
      * Whether or not the invite is temporary (invited users will be kicked on
      * disconnect unless they're assigned a role)
      */
    @inline def temporary: Boolean = selectDynamic[Boolean]("temporary")

    @inline def withTemporary(newValue: Boolean): InviteCreate = objWith(InviteCreate, "temporary", newValue)

    /** How many times the invite has been used (always will be 0) */
    @inline def uses: Int = selectDynamic[Int]("uses")

    @inline def withUses(newValue: Int): InviteCreate = objWith(InviteCreate, "uses", newValue)

    override def values: Seq[() => Any] = Seq(
      () => channelId,
      () => code,
      () => createdAt,
      () => guildId,
      () => inviter,
      () => maxAge,
      () => maxUses,
      () => targetType,
      () => targetUser,
      () => targetApplication,
      () => temporary,
      () => uses
    )
  }
  object InviteCreate extends DiscordObjectCompanion[InviteCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): InviteCreate = new InviteCreate(json, cache)

    /**
      * @param channelId
      *   Channel the invite is for
      * @param code
      *   Unique invite code
      * @param createdAt
      *   Time at which the invite was created
      * @param guildId
      *   Guild of the invite
      * @param inviter
      *   User that created the invite
      * @param maxAge
      *   How long the invite is valid for (in seconds)
      * @param maxUses
      *   Maximum number of times the invite can be used
      * @param targetType
      *   Type of target for this voice channel invite
      * @param targetUser
      *   User whose stream to display for this voice channel stream invite
      * @param targetApplication
      *   Embedded application to open for this voice channel embedded
      *   application invite
      * @param temporary
      *   Whether or not the invite is temporary (invited users will be kicked
      *   on disconnect unless they're assigned a role)
      * @param uses
      *   How many times the invite has been used (always will be 0)
      */
    def make20(
        channelId: GuildChannelId,
        code: String,
        createdAt: OffsetDateTime,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        inviter: UndefOr[User] = UndefOrUndefined,
        maxAge: Int,
        maxUses: Int,
        targetType: UndefOr[Invite.InviteTargetType] = UndefOrUndefined,
        targetUser: UndefOr[User] = UndefOrUndefined,
        targetApplication: UndefOr[Invite.InviteApplication] = UndefOrUndefined,
        temporary: Boolean,
        uses: Int
    ): InviteCreate = makeRawFromFields(
      "channel_id"          := channelId,
      "code"                := code,
      "created_at"          := createdAt,
      "guild_id"           :=? guildId,
      "inviter"            :=? inviter,
      "max_age"             := maxAge,
      "max_uses"            := maxUses,
      "target_type"        :=? targetType,
      "target_user"        :=? targetUser,
      "target_application" :=? targetApplication,
      "temporary"           := temporary,
      "uses"                := uses
    )
  }

  /** Sent when an invite is deleted. */
  class InviteDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** Channel of the invite */
    @inline def channelId: GuildChannelId = selectDynamic[GuildChannelId]("channel_id")

    @inline def withChannelId(newValue: GuildChannelId): InviteDelete =
      objWith(InviteDelete, "channel_id", newValue)

    /** Guild of the invite */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): InviteDelete =
      objWithUndef(InviteDelete, "guild_id", newValue)

    /** Unique invite code */
    @inline def code: String = selectDynamic[String]("code")

    @inline def withCode(newValue: String): InviteDelete = objWith(InviteDelete, "code", newValue)

    override def values: Seq[() => Any] = Seq(() => channelId, () => guildId, () => code)
  }
  object InviteDelete extends DiscordObjectCompanion[InviteDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): InviteDelete = new InviteDelete(json, cache)

    /**
      * @param channelId
      *   Channel of the invite
      * @param guildId
      *   Guild of the invite
      * @param code
      *   Unique invite code
      */
    def make20(
        channelId: GuildChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        code: String
    ): InviteDelete = makeRawFromFields("channel_id" := channelId, "guild_id" :=? guildId, "code" := code)
  }

  /**
    * Sent when a message is created. The inner payload is a message object with
    * the following extra fields:
    */
  class MessageCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def message: Message = Message.makeRaw(json, extensionCache("message"))

    @inline def withMessage(newValue: Message): MessageCreate =
      objWithJson(MessageCreate, newValue.json, newValue.cacheCopy)

    /**
      * ID of the guild the message was sent in - unless it is an ephemeral
      * message
      */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageCreate =
      objWithUndef(MessageCreate, "guild_id", newValue)

    /**
      * Member properties for this message's author. Missing for ephemeral
      * messages and messages from webhooks
      */
    @inline def member: UndefOr[MessageCreate.MessageCreateGuildMember] =
      selectDynamic[UndefOr[MessageCreate.MessageCreateGuildMember]]("member")

    @inline def withMember(
        newValue: UndefOr[MessageCreate.MessageCreateGuildMember]
    ): MessageCreate = objWithUndef(MessageCreate, "member", newValue)

    /**
      * Users specifically mentioned in the message. Array of user objects, with
      * an additional partial member field
      */
    @inline def mentions: Seq[User] = selectDynamic[Seq[User]]("mentions")

    @inline def withMentions(newValue: Seq[User]): MessageCreate = objWith(MessageCreate, "mentions", newValue)

    override def values: Seq[() => Any] = Seq(() => message, () => guildId, () => member, () => mentions)
  }
  object MessageCreate extends DiscordObjectCompanion[MessageCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageCreate = new MessageCreate(json, cache)

    /**
      * @param guildId
      *   ID of the guild the message was sent in - unless it is an ephemeral
      *   message
      * @param member
      *   Member properties for this message's author. Missing for ephemeral
      *   messages and messages from webhooks
      * @param mentions
      *   Users specifically mentioned in the message. Array of user objects,
      *   with an additional partial member field
      */
    def make20(
        message: Message,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        member: UndefOr[MessageCreate.MessageCreateGuildMember] = UndefOrUndefined,
        mentions: Seq[User]
    ): MessageCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("message", message),
      "guild_id" :=? guildId,
      "member"   :=? member,
      "mentions"  := mentions
    )

    class MessageCreateGuildMember(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object MessageCreateGuildMember extends DiscordObjectCompanion[MessageCreateGuildMember] {
      def makeRaw(json: Json, cache: Map[String, Any]): MessageCreateGuildMember =
        new MessageCreateGuildMember(json, cache)

      def make20(): MessageCreateGuildMember = makeRawFromFields()
    }
  }

  /**
    * Sent when a message is updated. The inner payload is a message object with
    * the same extra fields as MESSAGE_CREATE.
    */
  class MessageUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def message: Message.Partial = Message.Partial.makeRaw(json, extensionCache("message"))

    @inline def withMessage(newValue: Message.Partial): MessageUpdate =
      objWithJson(MessageUpdate, newValue.json, newValue.cacheCopy)

    @inline def id: MessageId = selectDynamic[MessageId]("id")

    @inline def withId(newValue: MessageId): MessageUpdate = objWith(MessageUpdate, "id", newValue)

    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): MessageUpdate =
      objWith(MessageUpdate, "channel_id", newValue)

    /**
      * ID of the guild the message was sent in - unless it is an ephemeral
      * message
      */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageUpdate =
      objWithUndef(MessageUpdate, "guild_id", newValue)

    /**
      * Member properties for this message's author. Missing for ephemeral
      * messages and messages from webhooks
      */
    @inline def member: UndefOr[MessageCreate.MessageCreateGuildMember] =
      selectDynamic[UndefOr[MessageCreate.MessageCreateGuildMember]]("member")

    @inline def withMember(
        newValue: UndefOr[MessageCreate.MessageCreateGuildMember]
    ): MessageUpdate = objWithUndef(MessageUpdate, "member", newValue)

    /**
      * Users specifically mentioned in the message. Array of user objects, with
      * an additional partial member field
      */
    @inline def mentions: UndefOr[Seq[User]] = selectDynamic[UndefOr[Seq[User]]]("mentions")

    @inline def withMentions(newValue: UndefOr[Seq[User]]): MessageUpdate =
      objWithUndef(MessageUpdate, "mentions", newValue)

    override def values: Seq[() => Any] =
      Seq(() => message, () => id, () => channelId, () => guildId, () => member, () => mentions)
  }
  object MessageUpdate extends DiscordObjectCompanion[MessageUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageUpdate = new MessageUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild the message was sent in - unless it is an ephemeral
      *   message
      * @param member
      *   Member properties for this message's author. Missing for ephemeral
      *   messages and messages from webhooks
      * @param mentions
      *   Users specifically mentioned in the message. Array of user objects,
      *   with an additional partial member field
      */
    def make20(
        message: Message.Partial,
        id: MessageId,
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        member: UndefOr[MessageCreate.MessageCreateGuildMember] = UndefOrUndefined,
        mentions: UndefOr[Seq[User]] = UndefOrUndefined
    ): MessageUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("message", message),
      "id"         := id,
      "channel_id" := channelId,
      "guild_id"  :=? guildId,
      "member"    :=? member,
      "mentions"  :=? mentions
    )
  }

  /** Sent when a message is deleted. */
  class MessageDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the message */
    @inline def id: MessageId = selectDynamic[MessageId]("id")

    @inline def withId(newValue: MessageId): MessageDelete = objWith(MessageDelete, "id", newValue)

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): MessageDelete =
      objWith(MessageDelete, "channel_id", newValue)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageDelete =
      objWithUndef(MessageDelete, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => id, () => channelId, () => guildId)
  }
  object MessageDelete extends DiscordObjectCompanion[MessageDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageDelete = new MessageDelete(json, cache)

    /**
      * @param id
      *   ID of the message
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      */
    def make20(
        id: MessageId,
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined
    ): MessageDelete = makeRawFromFields("id" := id, "channel_id" := channelId, "guild_id" :=? guildId)
  }

  /** Sent when multiple messages are deleted at once. */
  class MessageDeleteBulk(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** IDs of the messages */
    @inline def ids: Seq[MessageId] = selectDynamic[Seq[MessageId]]("ids")

    @inline def withIds(newValue: Seq[MessageId]): MessageDeleteBulk =
      objWith(MessageDeleteBulk, "ids", newValue)

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): MessageDeleteBulk =
      objWith(MessageDeleteBulk, "channel_id", newValue)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageDeleteBulk =
      objWithUndef(MessageDeleteBulk, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => ids, () => channelId, () => guildId)
  }
  object MessageDeleteBulk extends DiscordObjectCompanion[MessageDeleteBulk] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageDeleteBulk =
      new MessageDeleteBulk(json, cache)

    /**
      * @param ids
      *   IDs of the messages
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      */
    def make20(
        ids: Seq[MessageId],
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined
    ): MessageDeleteBulk = makeRawFromFields("ids" := ids, "channel_id" := channelId, "guild_id" :=? guildId)
  }

  /** Sent when a user adds a reaction to a message. */
  class MessageReactionAdd(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    @inline def withUserId(newValue: UserId): MessageReactionAdd = objWith(MessageReactionAdd, "user_id", newValue)

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): MessageReactionAdd =
      objWith(MessageReactionAdd, "channel_id", newValue)

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    @inline def withMessageId(newValue: MessageId): MessageReactionAdd =
      objWith(MessageReactionAdd, "message_id", newValue)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageReactionAdd =
      objWithUndef(MessageReactionAdd, "guild_id", newValue)

    /** Member who reacted if this happened in a guild */
    @inline def member: UndefOr[GuildMember] = selectDynamic[UndefOr[GuildMember]]("member")

    @inline def withMember(newValue: UndefOr[GuildMember]): MessageReactionAdd =
      objWithUndef(MessageReactionAdd, "member", newValue)

    /** Emoji used to react - example */
    @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

    @inline def withEmoji(newValue: Emoji): MessageReactionAdd = objWith(MessageReactionAdd, "emoji", newValue)

    /** ID of the user who authored the message which was reacted to */
    @inline def messageAuthorId: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("message_author_id")

    @inline def withMessageAuthorId(newValue: UndefOr[UserId]): MessageReactionAdd =
      objWithUndef(MessageReactionAdd, "message_author_id", newValue)

    override def values: Seq[() => Any] = Seq(
      () => userId,
      () => channelId,
      () => messageId,
      () => guildId,
      () => member,
      () => emoji,
      () => messageAuthorId
    )
  }
  object MessageReactionAdd extends DiscordObjectCompanion[MessageReactionAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionAdd =
      new MessageReactionAdd(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param channelId
      *   ID of the channel
      * @param messageId
      *   ID of the message
      * @param guildId
      *   ID of the guild
      * @param member
      *   Member who reacted if this happened in a guild
      * @param emoji
      *   Emoji used to react - example
      * @param messageAuthorId
      *   ID of the user who authored the message which was reacted to
      */
    def make20(
        userId: UserId,
        channelId: TextChannelId,
        messageId: MessageId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        member: UndefOr[GuildMember] = UndefOrUndefined,
        emoji: Emoji,
        messageAuthorId: UndefOr[UserId] = UndefOrUndefined
    ): MessageReactionAdd = makeRawFromFields(
      "user_id"            := userId,
      "channel_id"         := channelId,
      "message_id"         := messageId,
      "guild_id"          :=? guildId,
      "member"            :=? member,
      "emoji"              := emoji,
      "message_author_id" :=? messageAuthorId
    )
  }

  /** Sent when a user removes a reaction from a message. */
  class MessageReactionRemove(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    @inline def withUserId(newValue: UserId): MessageReactionRemove =
      objWith(MessageReactionRemove, "user_id", newValue)

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): MessageReactionRemove =
      objWith(MessageReactionRemove, "channel_id", newValue)

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    @inline def withMessageId(newValue: MessageId): MessageReactionRemove =
      objWith(MessageReactionRemove, "message_id", newValue)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageReactionRemove =
      objWithUndef(MessageReactionRemove, "guild_id", newValue)

    /** Emoji used to react - example */
    @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

    @inline def withEmoji(newValue: Emoji): MessageReactionRemove = objWith(MessageReactionRemove, "emoji", newValue)

    override def values: Seq[() => Any] =
      Seq(() => userId, () => channelId, () => messageId, () => guildId, () => emoji)
  }
  object MessageReactionRemove extends DiscordObjectCompanion[MessageReactionRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionRemove =
      new MessageReactionRemove(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param channelId
      *   ID of the channel
      * @param messageId
      *   ID of the message
      * @param guildId
      *   ID of the guild
      * @param emoji
      *   Emoji used to react - example
      */
    def make20(
        userId: UserId,
        channelId: TextChannelId,
        messageId: MessageId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        emoji: Emoji
    ): MessageReactionRemove = makeRawFromFields(
      "user_id"    := userId,
      "channel_id" := channelId,
      "message_id" := messageId,
      "guild_id"  :=? guildId,
      "emoji"      := emoji
    )
  }

  /** Sent when a user explicitly removes all reactions from a message. */
  class MessageReactionRemoveAll(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): MessageReactionRemoveAll =
      objWith(MessageReactionRemoveAll, "channel_id", newValue)

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    @inline def withMessageId(newValue: MessageId): MessageReactionRemoveAll =
      objWith(MessageReactionRemoveAll, "message_id", newValue)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageReactionRemoveAll =
      objWithUndef(MessageReactionRemoveAll, "guild_id", newValue)

    override def values: Seq[() => Any] = Seq(() => channelId, () => messageId, () => guildId)
  }
  object MessageReactionRemoveAll extends DiscordObjectCompanion[MessageReactionRemoveAll] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionRemoveAll =
      new MessageReactionRemoveAll(json, cache)

    /**
      * @param channelId
      *   ID of the channel
      * @param messageId
      *   ID of the message
      * @param guildId
      *   ID of the guild
      */
    def make20(
        channelId: TextChannelId,
        messageId: MessageId,
        guildId: UndefOr[GuildId] = UndefOrUndefined
    ): MessageReactionRemoveAll =
      makeRawFromFields("channel_id" := channelId, "message_id" := messageId, "guild_id" :=? guildId)
  }

  /**
    * Sent when a bot removes all instances of a given emoji from the reactions
    * of a message.
    */
  class MessageReactionRemoveEmoji(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): MessageReactionRemoveEmoji =
      objWith(MessageReactionRemoveEmoji, "channel_id", newValue)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): MessageReactionRemoveEmoji =
      objWithUndef(MessageReactionRemoveEmoji, "guild_id", newValue)

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    @inline def withMessageId(newValue: MessageId): MessageReactionRemoveEmoji =
      objWith(MessageReactionRemoveEmoji, "message_id", newValue)

    /** Emoji that was removed */
    @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

    @inline def withEmoji(newValue: Emoji): MessageReactionRemoveEmoji =
      objWith(MessageReactionRemoveEmoji, "emoji", newValue)

    override def values: Seq[() => Any] = Seq(() => channelId, () => guildId, () => messageId, () => emoji)
  }
  object MessageReactionRemoveEmoji extends DiscordObjectCompanion[MessageReactionRemoveEmoji] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionRemoveEmoji =
      new MessageReactionRemoveEmoji(json, cache)

    /**
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      * @param messageId
      *   ID of the message
      * @param emoji
      *   Emoji that was removed
      */
    def make20(
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        messageId: MessageId,
        emoji: Emoji
    ): MessageReactionRemoveEmoji =
      makeRawFromFields("channel_id" := channelId, "guild_id" :=? guildId, "message_id" := messageId, "emoji" := emoji)
  }

  /**
    * A user's presence is their current state on a guild. This event is sent
    * when a user's presence or info, such as name or avatar, is updated.
    */
  class PresenceUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** User whose presence is being updated */
    @inline def user: User.Partial = User.Partial.makeRaw(json, extensionCache("user"))

    @inline def withUser(newValue: User.Partial): PresenceUpdate =
      objWithJson(PresenceUpdate, newValue.json, newValue.cacheCopy)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): PresenceUpdate =
      objWithUndef(PresenceUpdate, "guild_id", newValue)

    /** Either "idle", "dnd", "online", or "offline" */
    @inline def status: UndefOr[Status] = selectDynamic[UndefOr[Status]]("status")

    @inline def withStatus(newValue: UndefOr[Status]): PresenceUpdate =
      objWithUndef(PresenceUpdate, "status", newValue)

    /** User's current activities */
    @inline def activities: UndefOr[Seq[Activity]] = selectDynamic[UndefOr[Seq[Activity]]]("activities")

    @inline def withActivities(newValue: UndefOr[Seq[Activity]]): PresenceUpdate =
      objWithUndef(PresenceUpdate, "activities", newValue)

    /** User's platform-dependent status */
    @inline def clientStatus: UndefOr[PresenceUpdate.ClientStatus] =
      selectDynamic[UndefOr[PresenceUpdate.ClientStatus]]("client_status")

    @inline def withClientStatus(newValue: UndefOr[PresenceUpdate.ClientStatus]): PresenceUpdate =
      objWithUndef(PresenceUpdate, "client_status", newValue)

    override def values: Seq[() => Any] =
      Seq(() => user, () => guildId, () => status, () => activities, () => clientStatus)
  }
  object PresenceUpdate extends DiscordObjectCompanion[PresenceUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): PresenceUpdate =
      new PresenceUpdate(json, cache)

    /**
      * @param user
      *   User whose presence is being updated
      * @param guildId
      *   ID of the guild
      * @param status
      *   Either "idle", "dnd", "online", or "offline"
      * @param activities
      *   User's current activities
      * @param clientStatus
      *   User's platform-dependent status
      */
    def make20(
        user: User.Partial,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        status: UndefOr[Status] = UndefOrUndefined,
        activities: UndefOr[Seq[Activity]] = UndefOrUndefined,
        clientStatus: UndefOr[PresenceUpdate.ClientStatus] = UndefOrUndefined
    ): PresenceUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("user", user),
      "guild_id"      :=? guildId,
      "status"        :=? status,
      "activities"    :=? activities,
      "client_status" :=? clientStatus
    )

    /**
      * Active sessions are indicated with an "online", "idle", or "dnd" string
      * per platform. If a user is offline or invisible, the corresponding field
      * is not present.
      */
    class ClientStatus(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /**
        * User's status set for an active desktop (Windows, Linux, Mac)
        * application session
        */
      @inline def desktop: UndefOr[Status] = selectDynamic[UndefOr[Status]]("desktop")

      @inline def withDesktop(newValue: UndefOr[Status]): ClientStatus =
        objWithUndef(ClientStatus, "desktop", newValue)

      /**
        * User's status set for an active mobile (iOS, Android) application
        * session
        */
      @inline def mobile: UndefOr[Status] = selectDynamic[UndefOr[Status]]("mobile")

      @inline def withMobile(newValue: UndefOr[Status]): ClientStatus =
        objWithUndef(ClientStatus, "mobile", newValue)

      /**
        * User's status set for an active web (browser, bot user) application
        * session
        */
      @inline def web: UndefOr[Status] = selectDynamic[UndefOr[Status]]("web")

      @inline def withWeb(newValue: UndefOr[Status]): ClientStatus = objWithUndef(ClientStatus, "web", newValue)

      override def values: Seq[() => Any] = Seq(() => desktop, () => mobile, () => web)
    }
    object ClientStatus extends DiscordObjectCompanion[ClientStatus] {
      def makeRaw(json: Json, cache: Map[String, Any]): ClientStatus =
        new ClientStatus(json, cache)

      /**
        * @param desktop
        *   User's status set for an active desktop (Windows, Linux, Mac)
        *   application session
        * @param mobile
        *   User's status set for an active mobile (iOS, Android) application
        *   session
        * @param web
        *   User's status set for an active web (browser, bot user) application
        *   session
        */
      def make20(
          desktop: UndefOr[Status] = UndefOrUndefined,
          mobile: UndefOr[Status] = UndefOrUndefined,
          web: UndefOr[Status] = UndefOrUndefined
      ): ClientStatus = makeRawFromFields("desktop" :=? desktop, "mobile" :=? mobile, "web" :=? web)
    }
  }

  class Activity(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Activity's name */
    @inline def name: String = selectDynamic[String]("name")

    @inline def withName(newValue: String): Activity = objWith(Activity, "name", newValue)

    /** Activity type */
    @inline def tpe: Activity.ActivityType = selectDynamic[Activity.ActivityType]("type")

    @inline def withTpe(newValue: Activity.ActivityType): Activity = objWith(Activity, "type", newValue)

    /** Stream URL, is validated when type is 1 */
    @inline def url: JsonOption[String] = selectDynamic[JsonOption[String]]("url")

    @inline def withUrl(newValue: JsonOption[String]): Activity = objWithUndef(Activity, "url", newValue)

    /**
      * Unix timestamp (in milliseconds) of when the activity was added to the
      * user's session
      */
    @inline def createdAt: Int = selectDynamic[Int]("created_at")

    @inline def withCreatedAt(newValue: Int): Activity = objWith(Activity, "created_at", newValue)

    /** Unix timestamps for start and/or end of the game */
    @inline def timestamps: UndefOr[Activity.ActivityTimestamps] =
      selectDynamic[UndefOr[Activity.ActivityTimestamps]]("timestamps")

    @inline def withTimestamps(newValue: UndefOr[Activity.ActivityTimestamps]): Activity =
      objWithUndef(Activity, "timestamps", newValue)

    /** Application ID for the game */
    @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

    @inline def withApplicationId(newValue: UndefOr[ApplicationId]): Activity =
      objWithUndef(Activity, "application_id", newValue)

    /** What the player is currently doing */
    @inline def details: JsonOption[String] = selectDynamic[JsonOption[String]]("details")

    @inline def withDetails(newValue: JsonOption[String]): Activity = objWithUndef(Activity, "details", newValue)

    /** User's current party status */
    @inline def state: JsonOption[String] = selectDynamic[JsonOption[String]]("state")

    @inline def withState(newValue: JsonOption[String]): Activity = objWithUndef(Activity, "state", newValue)

    /** Emoji used for a custom status */
    @inline def emoji: JsonOption[Activity.ActivityEmoji] = selectDynamic[JsonOption[Activity.ActivityEmoji]]("emoji")

    @inline def withEmoji(newValue: JsonOption[Activity.ActivityEmoji]): Activity =
      objWithUndef(Activity, "emoji", newValue)

    /** Information for the current party of the player */
    @inline def party: UndefOr[Activity.ActivityParty] = selectDynamic[UndefOr[Activity.ActivityParty]]("party")

    @inline def withParty(newValue: UndefOr[Activity.ActivityParty]): Activity =
      objWithUndef(Activity, "party", newValue)

    /** Images for the presence and their hover texts */
    @inline def assets: UndefOr[Activity.ActivityAssets] = selectDynamic[UndefOr[Activity.ActivityAssets]]("assets")

    @inline def withAssets(newValue: UndefOr[Activity.ActivityAssets]): Activity =
      objWithUndef(Activity, "assets", newValue)

    /** Secrets for Rich Presence joining and spectating */
    @inline def secrets: UndefOr[Activity.ActivitySecrets] = selectDynamic[UndefOr[Activity.ActivitySecrets]]("secrets")

    @inline def withSecrets(newValue: UndefOr[Activity.ActivitySecrets]): Activity =
      objWithUndef(Activity, "secrets", newValue)

    /** Whether or not the activity is an instanced game session */
    @inline def instance: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("instance")

    @inline def withInstance(newValue: UndefOr[Boolean]): Activity = objWithUndef(Activity, "instance", newValue)

    /** Activity flags ORd together, describes what the payload includes */
    @inline def flags: UndefOr[Activity.ActivityFlags] = selectDynamic[UndefOr[Activity.ActivityFlags]]("flags")

    @inline def withFlags(newValue: UndefOr[Activity.ActivityFlags]): Activity =
      objWithUndef(Activity, "flags", newValue)

    /** Custom buttons shown in the Rich Presence (max 2) */
    @inline def buttons: UndefOr[Seq[Activity.ActivityButtons]] =
      selectDynamic[UndefOr[Seq[Activity.ActivityButtons]]]("buttons")

    @inline def withButtons(newValue: UndefOr[Seq[Activity.ActivityButtons]]): Activity =
      objWithUndef(Activity, "buttons", newValue)

    override def values: Seq[() => Any] = Seq(
      () => name,
      () => tpe,
      () => url,
      () => createdAt,
      () => timestamps,
      () => applicationId,
      () => details,
      () => state,
      () => emoji,
      () => party,
      () => assets,
      () => secrets,
      () => instance,
      () => flags,
      () => buttons
    )
  }
  object Activity extends DiscordObjectCompanion[Activity] {
    def makeRaw(json: Json, cache: Map[String, Any]): Activity = new Activity(json, cache)

    /**
      * @param name
      *   Activity's name
      * @param tpe
      *   Activity type
      * @param url
      *   Stream URL, is validated when type is 1
      * @param createdAt
      *   Unix timestamp (in milliseconds) of when the activity was added to the
      *   user's session
      * @param timestamps
      *   Unix timestamps for start and/or end of the game
      * @param applicationId
      *   Application ID for the game
      * @param details
      *   What the player is currently doing
      * @param state
      *   User's current party status
      * @param emoji
      *   Emoji used for a custom status
      * @param party
      *   Information for the current party of the player
      * @param assets
      *   Images for the presence and their hover texts
      * @param secrets
      *   Secrets for Rich Presence joining and spectating
      * @param instance
      *   Whether or not the activity is an instanced game session
      * @param flags
      *   Activity flags ORd together, describes what the payload includes
      * @param buttons
      *   Custom buttons shown in the Rich Presence (max 2)
      */
    def make20(
        name: String,
        tpe: Activity.ActivityType,
        url: JsonOption[String] = JsonUndefined,
        createdAt: Int,
        timestamps: UndefOr[Activity.ActivityTimestamps] = UndefOrUndefined,
        applicationId: UndefOr[ApplicationId] = UndefOrUndefined,
        details: JsonOption[String] = JsonUndefined,
        state: JsonOption[String] = JsonUndefined,
        emoji: JsonOption[Activity.ActivityEmoji] = JsonUndefined,
        party: UndefOr[Activity.ActivityParty] = UndefOrUndefined,
        assets: UndefOr[Activity.ActivityAssets] = UndefOrUndefined,
        secrets: UndefOr[Activity.ActivitySecrets] = UndefOrUndefined,
        instance: UndefOr[Boolean] = UndefOrUndefined,
        flags: UndefOr[Activity.ActivityFlags] = UndefOrUndefined,
        buttons: UndefOr[Seq[Activity.ActivityButtons]] = UndefOrUndefined
    ): Activity = makeRawFromFields(
      "name"            := name,
      "type"            := tpe,
      "url"            :=? url,
      "created_at"      := createdAt,
      "timestamps"     :=? timestamps,
      "application_id" :=? applicationId,
      "details"        :=? details,
      "state"          :=? state,
      "emoji"          :=? emoji,
      "party"          :=? party,
      "assets"         :=? assets,
      "secrets"        :=? secrets,
      "instance"       :=? instance,
      "flags"          :=? flags,
      "buttons"        :=? buttons
    )

    sealed case class ActivityType private (value: Int) extends DiscordEnum[Int]
    object ActivityType                                 extends DiscordEnumCompanion[Int, ActivityType] {

      /** Playing {name} */
      val Game: ActivityType = ActivityType(0)

      /** Streaming {details} */
      val Streaming: ActivityType = ActivityType(1)

      /** Listening to {name} */
      val Listening: ActivityType = ActivityType(2)

      /** Watching {name} */
      val Watching: ActivityType = ActivityType(3)

      /** {emoji} {name} */
      val Custom: ActivityType = ActivityType(4)

      /** Competing in {name} */
      val Competing: ActivityType = ActivityType(5)

      def unknown(value: Int): ActivityType = new ActivityType(value)

      val values: Seq[ActivityType] = Seq(Game, Streaming, Listening, Watching, Custom, Competing)
    }

    class ActivityTimestamps(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Unix time (in milliseconds) of when the activity started */
      @inline def start: UndefOr[Int] = selectDynamic[UndefOr[Int]]("start")

      @inline def withStart(newValue: UndefOr[Int]): ActivityTimestamps =
        objWithUndef(ActivityTimestamps, "start", newValue)

      /** Unix time (in milliseconds) of when the activity ends */
      @inline def end: UndefOr[Int] = selectDynamic[UndefOr[Int]]("end")

      @inline def withEnd(newValue: UndefOr[Int]): ActivityTimestamps =
        objWithUndef(ActivityTimestamps, "end", newValue)

      override def values: Seq[() => Any] = Seq(() => start, () => end)
    }
    object ActivityTimestamps extends DiscordObjectCompanion[ActivityTimestamps] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityTimestamps =
        new ActivityTimestamps(json, cache)

      /**
        * @param start
        *   Unix time (in milliseconds) of when the activity started
        * @param end
        *   Unix time (in milliseconds) of when the activity ends
        */
      def make20(
          start: UndefOr[Int] = UndefOrUndefined,
          end: UndefOr[Int] = UndefOrUndefined
      ): ActivityTimestamps = makeRawFromFields("start" :=? start, "end" :=? end)
    }

    class ActivityEmoji(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Name of the emoji */
      @inline def name: String = selectDynamic[String]("name")

      @inline def withName(newValue: String): ActivityEmoji = objWith(ActivityEmoji, "name", newValue)

      /** ID of the emoji */
      @inline def id: UndefOr[Snowflake[Emoji]] = selectDynamic[UndefOr[Snowflake[Emoji]]]("id")

      @inline def withId(newValue: UndefOr[Snowflake[Emoji]]): ActivityEmoji =
        objWithUndef(ActivityEmoji, "id", newValue)

      /** Whether the emoji is animated */
      @inline def animated: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("animated")

      @inline def withAnimated(newValue: UndefOr[Boolean]): ActivityEmoji =
        objWithUndef(ActivityEmoji, "animated", newValue)

      override def values: Seq[() => Any] = Seq(() => name, () => id, () => animated)
    }
    object ActivityEmoji extends DiscordObjectCompanion[ActivityEmoji] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityEmoji =
        new ActivityEmoji(json, cache)

      /**
        * @param name
        *   Name of the emoji
        * @param id
        *   ID of the emoji
        * @param animated
        *   Whether the emoji is animated
        */
      def make20(
          name: String,
          id: UndefOr[Snowflake[Emoji]] = UndefOrUndefined,
          animated: UndefOr[Boolean] = UndefOrUndefined
      ): ActivityEmoji = makeRawFromFields("name" := name, "id" :=? id, "animated" :=? animated)
    }

    class ActivityParty(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** ID of the party */
      @inline def id: UndefOr[String] = selectDynamic[UndefOr[String]]("id")

      @inline def withId(newValue: UndefOr[String]): ActivityParty = objWithUndef(ActivityParty, "id", newValue)

      /**
        * Array of two integers (current_size, max_size). Used to show the
        * party's current and maximum size
        */
      @inline def size: UndefOr[Seq[Int]] = selectDynamic[UndefOr[Seq[Int]]]("size")

      @inline def withSize(newValue: UndefOr[Seq[Int]]): ActivityParty =
        objWithUndef(ActivityParty, "size", newValue)

      override def values: Seq[() => Any] = Seq(() => id, () => size)
    }
    object ActivityParty extends DiscordObjectCompanion[ActivityParty] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityParty =
        new ActivityParty(json, cache)

      /**
        * @param id
        *   ID of the party
        * @param size
        *   Array of two integers (current_size, max_size). Used to show the
        *   party's current and maximum size
        */
      def make20(
          id: UndefOr[String] = UndefOrUndefined,
          size: UndefOr[Seq[Int]] = UndefOrUndefined
      ): ActivityParty = makeRawFromFields("id" :=? id, "size" :=? size)
    }

    class ActivityAssets(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** See Activity Asset Image */
      @inline def largeImage: UndefOr[String] = selectDynamic[UndefOr[String]]("large_image")

      @inline def withLargeImage(newValue: UndefOr[String]): ActivityAssets =
        objWithUndef(ActivityAssets, "large_image", newValue)

      /** Text displayed when hovering over the large image of the activity */
      @inline def largeText: UndefOr[String] = selectDynamic[UndefOr[String]]("large_text")

      @inline def withLargeText(newValue: UndefOr[String]): ActivityAssets =
        objWithUndef(ActivityAssets, "large_text", newValue)

      /** See Activity Asset Image */
      @inline def smallImage: UndefOr[String] = selectDynamic[UndefOr[String]]("small_image")

      @inline def withSmallImage(newValue: UndefOr[String]): ActivityAssets =
        objWithUndef(ActivityAssets, "small_image", newValue)

      /** Text displayed when hovering over the small image of the activity */
      @inline def smallText: UndefOr[String] = selectDynamic[UndefOr[String]]("small_text")

      @inline def withSmallText(newValue: UndefOr[String]): ActivityAssets =
        objWithUndef(ActivityAssets, "small_text", newValue)

      override def values: Seq[() => Any] = Seq(() => largeImage, () => largeText, () => smallImage, () => smallText)
    }
    object ActivityAssets extends DiscordObjectCompanion[ActivityAssets] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityAssets =
        new ActivityAssets(json, cache)

      /**
        * @param largeImage
        *   See Activity Asset Image
        * @param largeText
        *   Text displayed when hovering over the large image of the activity
        * @param smallImage
        *   See Activity Asset Image
        * @param smallText
        *   Text displayed when hovering over the small image of the activity
        */
      def make20(
          largeImage: UndefOr[String] = UndefOrUndefined,
          largeText: UndefOr[String] = UndefOrUndefined,
          smallImage: UndefOr[String] = UndefOrUndefined,
          smallText: UndefOr[String] = UndefOrUndefined
      ): ActivityAssets = makeRawFromFields(
        "large_image" :=? largeImage,
        "large_text"  :=? largeText,
        "small_image" :=? smallImage,
        "small_text"  :=? smallText
      )
    }

    class ActivitySecrets(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Secret for joining a party */
      @inline def join: UndefOr[String] = selectDynamic[UndefOr[String]]("join")

      @inline def withJoin(newValue: UndefOr[String]): ActivitySecrets =
        objWithUndef(ActivitySecrets, "join", newValue)

      /** Secret for spectating a game */
      @inline def spectate: UndefOr[String] = selectDynamic[UndefOr[String]]("spectate")

      @inline def withSpectate(newValue: UndefOr[String]): ActivitySecrets =
        objWithUndef(ActivitySecrets, "spectate", newValue)

      /** Secret for a specific instanced match */
      @inline def matchSecret: UndefOr[String] = selectDynamic[UndefOr[String]]("match")

      @inline def withMatchSecret(newValue: UndefOr[String]): ActivitySecrets =
        objWithUndef(ActivitySecrets, "match", newValue)

      override def values: Seq[() => Any] = Seq(() => join, () => spectate, () => matchSecret)
    }
    object ActivitySecrets extends DiscordObjectCompanion[ActivitySecrets] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivitySecrets =
        new ActivitySecrets(json, cache)

      /**
        * @param join
        *   Secret for joining a party
        * @param spectate
        *   Secret for spectating a game
        * @param matchSecret
        *   Secret for a specific instanced match
        */
      def make20(
          join: UndefOr[String] = UndefOrUndefined,
          spectate: UndefOr[String] = UndefOrUndefined,
          matchSecret: UndefOr[String] = UndefOrUndefined
      ): ActivitySecrets = makeRawFromFields("join" :=? join, "spectate" :=? spectate, "match" :=? matchSecret)
    }

    sealed case class ActivityFlags private (value: Int) extends DiscordEnum[Int]
    object ActivityFlags                                 extends DiscordEnumCompanion[Int, ActivityFlags] {

      /** 1 << 0 */
      val INSTANCE: ActivityFlags = ActivityFlags(1 << 0)

      /** 1 << 1 */
      val JOIN: ActivityFlags = ActivityFlags(1 << 1)

      /** 1 << 2 */
      val SPECTATE: ActivityFlags = ActivityFlags(1 << 2)

      /** 1 << 3 */
      val JOIN_REQUEST: ActivityFlags = ActivityFlags(1 << 3)

      /** 1 << 4 */
      val SYNC: ActivityFlags = ActivityFlags(1 << 4)

      /** 1 << 5 */
      val PLAY: ActivityFlags = ActivityFlags(1 << 5)

      /** 1 << 6 */
      val PARTY_PRIVACY_FRIENDS: ActivityFlags = ActivityFlags(1 << 6)

      /** 1 << 7 */
      val PARTY_PRIVACY_VOICE_CHANNEL: ActivityFlags = ActivityFlags(1 << 7)

      /** 1 << 8 */
      val EMBEDDED: ActivityFlags = ActivityFlags(1 << 8)

      def unknown(value: Int): ActivityFlags = new ActivityFlags(value)

      val values: Seq[ActivityFlags] = Seq(
        INSTANCE,
        JOIN,
        SPECTATE,
        JOIN_REQUEST,
        SYNC,
        PLAY,
        PARTY_PRIVACY_FRIENDS,
        PARTY_PRIVACY_VOICE_CHANNEL,
        EMBEDDED
      )

      implicit class ActivityFlagsBitFieldOps(private val here: ActivityFlags) extends AnyVal {

        def toInt: Int = here.value

        def ++(there: ActivityFlags): ActivityFlags = ActivityFlags(here.value | there.value)

        def --(there: ActivityFlags): ActivityFlags = ActivityFlags(here.value & ~there.value)

        def isNone: Boolean = here.value == 0
      }
    }

    /**
      * When received over the gateway, the buttons field is an array of
      * strings, which are the button labels. Bots cannot access a user's
      * activity button URLs. When sending, the buttons field must be an array
      * of the below object:
      */
    class ActivityButtons(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object ActivityButtons extends DiscordObjectCompanion[ActivityButtons] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityButtons =
        new ActivityButtons(json, cache)

      def make20(): ActivityButtons = makeRawFromFields()
    }
  }

  /** Sent when a user starts typing in a channel. */
  class TypingStart(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    @inline def withChannelId(newValue: TextChannelId): TypingStart = objWith(TypingStart, "channel_id", newValue)

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    @inline def withGuildId(newValue: UndefOr[GuildId]): TypingStart =
      objWithUndef(TypingStart, "guild_id", newValue)

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    @inline def withUserId(newValue: UserId): TypingStart = objWith(TypingStart, "user_id", newValue)

    /** Unix time (in seconds) of when the user started typing */
    @inline def timestamp: Int = selectDynamic[Int]("timestamp")

    @inline def withTimestamp(newValue: Int): TypingStart = objWith(TypingStart, "timestamp", newValue)

    /** Member who started typing if this happened in a guild */
    @inline def member: UndefOr[GuildMember] = selectDynamic[UndefOr[GuildMember]]("member")

    @inline def withMember(newValue: UndefOr[GuildMember]): TypingStart =
      objWithUndef(TypingStart, "member", newValue)

    override def values: Seq[() => Any] =
      Seq(() => channelId, () => guildId, () => userId, () => timestamp, () => member)
  }
  object TypingStart extends DiscordObjectCompanion[TypingStart] {
    def makeRaw(json: Json, cache: Map[String, Any]): TypingStart = new TypingStart(json, cache)

    /**
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      * @param userId
      *   ID of the user
      * @param timestamp
      *   Unix time (in seconds) of when the user started typing
      * @param member
      *   Member who started typing if this happened in a guild
      */
    def make20(
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        userId: UserId,
        timestamp: Int,
        member: UndefOr[GuildMember] = UndefOrUndefined
    ): TypingStart = makeRawFromFields(
      "channel_id" := channelId,
      "guild_id"  :=? guildId,
      "user_id"    := userId,
      "timestamp"  := timestamp,
      "member"    :=? member
    )
  }

  /**
    * Sent when properties about the current bot's user change. Inner payload is
    * a user object.
    */
  class UserUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def user: User = User.makeRaw(json, extensionCache("user"))

    @inline def withUser(newValue: User): UserUpdate = objWithJson(UserUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => user)
  }
  object UserUpdate extends DiscordObjectCompanion[UserUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): UserUpdate = new UserUpdate(json, cache)

    def make20(user: User): UserUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("user", user))
  }

  /**
    * Sent when someone joins/leaves/moves voice channels. Inner payload is a
    * voice state object.
    */
  class VoiceStateUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def voiceState: VoiceState = VoiceState.makeRaw(json, extensionCache("voice_state"))

    @inline def withVoiceState(newValue: VoiceState): VoiceStateUpdate =
      objWithJson(VoiceStateUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => voiceState)
  }
  object VoiceStateUpdate extends DiscordObjectCompanion[VoiceStateUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): VoiceStateUpdate =
      new VoiceStateUpdate(json, cache)

    def make20(voiceState: VoiceState): VoiceStateUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("voice_state", voiceState)
    )
  }

  /**
    * Sent when a guild's voice server is updated. This is sent when initially
    * connecting to voice, and when the current voice instance fails over to a
    * new server.
    */
  class VoiceServerUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** Voice connection token */
    @inline def token: String = selectDynamic[String]("token")

    @inline def withToken(newValue: String): VoiceServerUpdate = objWith(VoiceServerUpdate, "token", newValue)

    /** Guild this voice server update is for */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): VoiceServerUpdate = objWith(VoiceServerUpdate, "guild_id", newValue)

    /** Voice server host */
    @inline def endpoint: Option[String] = selectDynamic[Option[String]]("endpoint")

    @inline def withEndpoint(newValue: Option[String]): VoiceServerUpdate =
      objWith(VoiceServerUpdate, "endpoint", newValue)

    override def values: Seq[() => Any] = Seq(() => token, () => guildId, () => endpoint)
  }
  object VoiceServerUpdate extends DiscordObjectCompanion[VoiceServerUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): VoiceServerUpdate =
      new VoiceServerUpdate(json, cache)

    /**
      * @param token
      *   Voice connection token
      * @param guildId
      *   Guild this voice server update is for
      * @param endpoint
      *   Voice server host
      */
    def make20(token: String, guildId: GuildId, endpoint: Option[String]): VoiceServerUpdate =
      makeRawFromFields("token" := token, "guild_id" := guildId, "endpoint" := endpoint)
  }

  /** Sent when a guild channel's webhook is created, updated, or deleted. */
  class WebhooksUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def withGuildId(newValue: GuildId): WebhooksUpdate = objWith(WebhooksUpdate, "guild_id", newValue)

    /** ID of the channel */
    @inline def channelId: GuildChannelId = selectDynamic[GuildChannelId]("channel_id")

    @inline def withChannelId(newValue: GuildChannelId): WebhooksUpdate =
      objWith(WebhooksUpdate, "channel_id", newValue)

    override def values: Seq[() => Any] = Seq(() => guildId, () => channelId)
  }
  object WebhooksUpdate extends DiscordObjectCompanion[WebhooksUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): WebhooksUpdate =
      new WebhooksUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param channelId
      *   ID of the channel
      */
    def make20(guildId: GuildId, channelId: GuildChannelId): WebhooksUpdate =
      makeRawFromFields("guild_id" := guildId, "channel_id" := channelId)
  }

  /**
    * Sent when a user uses an Application Command or Message Component. Inner
    * payload is an Interaction. This is intentionally a stub. A proper type can
    * be found in the interactions module.
    */
  class InteractionCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    override def values: Seq[() => Any] = Seq()
  }
  object InteractionCreate extends DiscordObjectCompanion[InteractionCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): InteractionCreate =
      new InteractionCreate(json, cache)

    def make20(): InteractionCreate = makeRawFromFields()
  }

  /**
    * Sent when a Stage instance is created (i.e. the Stage is now "live").
    * Inner payload is a Stage instance
    */
  class StageInstanceCreate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def stageInstance: StageInstance = StageInstance.makeRaw(json, extensionCache("stage_instance"))

    @inline def withStageInstance(newValue: StageInstance): StageInstanceCreate =
      objWithJson(StageInstanceCreate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => stageInstance)
  }
  object StageInstanceCreate extends DiscordObjectCompanion[StageInstanceCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): StageInstanceCreate =
      new StageInstanceCreate(json, cache)

    def make20(stageInstance: StageInstance): StageInstanceCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("stage_instance", stageInstance)
    )
  }

  /**
    * Sent when a Stage instance has been updated. Inner payload is a Stage
    * instance
    */
  class StageInstanceUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def stageInstance: StageInstance = StageInstance.makeRaw(json, extensionCache("stage_instance"))

    @inline def withStageInstance(newValue: StageInstance): StageInstanceUpdate =
      objWithJson(StageInstanceUpdate, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => stageInstance)
  }
  object StageInstanceUpdate extends DiscordObjectCompanion[StageInstanceUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): StageInstanceUpdate =
      new StageInstanceUpdate(json, cache)

    def make20(stageInstance: StageInstance): StageInstanceUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("stage_instance", stageInstance)
    )
  }

  /**
    * Sent when a Stage instance has been deleted (i.e. the Stage has been
    * closed). Inner payload is a Stage instance
    */
  class StageInstanceDelete(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    @inline def stageInstance: StageInstance = StageInstance.makeRaw(json, extensionCache("stage_instance"))

    @inline def withStageInstance(newValue: StageInstance): StageInstanceDelete =
      objWithJson(StageInstanceDelete, newValue.json, newValue.cacheCopy)

    override def values: Seq[() => Any] = Seq(() => stageInstance)
  }
  object StageInstanceDelete extends DiscordObjectCompanion[StageInstanceDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): StageInstanceDelete =
      new StageInstanceDelete(json, cache)

    def make20(stageInstance: StageInstance): StageInstanceDelete = makeRawFromFields(
      DiscordObjectFrom.FromExtension("stage_instance", stageInstance)
    )
  }

  class UnknownGatewayDispatchEvent(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache)
      with GatewayDispatchEvent {

    override def values: Seq[() => Any] = Seq()
  }
  object UnknownGatewayDispatchEvent extends DiscordObjectCompanion[UnknownGatewayDispatchEvent] {
    def makeRaw(json: Json, cache: Map[String, Any]): UnknownGatewayDispatchEvent =
      new UnknownGatewayDispatchEvent(json, cache)

    def make20(): UnknownGatewayDispatchEvent = makeRawFromFields()
  }
}
