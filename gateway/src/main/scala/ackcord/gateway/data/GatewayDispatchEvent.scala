//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode
package ackcord.gateway.data

// THIS FILE IS MACHINE GENERATED!
//
// Do not edit this file directly.
// Instead, edit the file generated/ackcord/gateway/data/GatewayDispatchEvent.yaml

import java.time.OffsetDateTime

import ackcord.data._
import ackcord.data.base._
import io.circe.Json

object GatewayDispatchEvent {

  /**
    * * The ready event is dispatched when a client has completed the initial
    * handshake with the gateway (for new sessions). The ready event can be the
    * largest and most complex event the gateway will send, as it contains all
    * the state required for a client to begin interacting with the rest of the
    * platform.
    *
    * guilds are the guilds of which your bot is a member. They start out as
    * unavailable when you connect to the gateway. As they become available,
    * your bot will be notified via Guild Create events.
    */
  class Ready(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** API version */
    @inline def v: Int = selectDynamic[Int]("v")

    /** Information about the user including email */
    @inline def user: User = selectDynamic[User]("user")

    /** Guilds the user is in */
    @inline def guilds: Seq[UnavailableGuild] = selectDynamic[Seq[UnavailableGuild]]("guilds")

    /** Used for resuming connections */
    @inline def sessionId: String = selectDynamic[String]("session_id")

    /** Gateway URL for resuming connections */
    @inline def resumeGatewayUrl: String = selectDynamic[String]("resume_gateway_url")

    /**
      * Shard information associated with this session, if sent when identifying
      */
    @inline def shard: UndefOr[Seq[Int]] = selectDynamic[UndefOr[Seq[Int]]]("shard")

    /** Contains id and flags */
    @inline def application: Ready.ReadyApplication = selectDynamic[Ready.ReadyApplication]("application")

    override def values: Seq[() => Any] =
      Seq(() => v, () => user, () => guilds, () => sessionId, () => resumeGatewayUrl, () => shard, () => application)
  }
  object Ready extends DiscordObjectCompanion[Ready] {
    def makeRaw(json: Json, cache: Map[String, Any]): Ready = new Ready(json, cache)

    /**
      * @param v
      *   API version
      * @param user
      *   Information about the user including email
      * @param guilds
      *   Guilds the user is in
      * @param sessionId
      *   Used for resuming connections
      * @param resumeGatewayUrl
      *   Gateway URL for resuming connections
      * @param shard
      *   Shard information associated with this session, if sent when
      *   identifying
      * @param application
      *   Contains id and flags
      */
    def make20(
        v: Int,
        user: User,
        guilds: Seq[UnavailableGuild],
        sessionId: String,
        resumeGatewayUrl: String,
        shard: UndefOr[Seq[Int]] = UndefOrUndefined,
        application: Ready.ReadyApplication
    ): Ready = makeRawFromFields(
      "v"                  := v,
      "user"               := user,
      "guilds"             := guilds,
      "session_id"         := sessionId,
      "resume_gateway_url" := resumeGatewayUrl,
      "shard"             :=? shard,
      "application"        := application
    )

    class ReadyApplication(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
      @inline def id: ApplicationId = selectDynamic[ApplicationId]("id")

      @inline def flags: Application.Flags = selectDynamic[Application.Flags]("flags")

      override def values: Seq[() => Any] = Seq(() => id, () => flags)
    }
    object ReadyApplication extends DiscordObjectCompanion[ReadyApplication] {
      def makeRaw(json: Json, cache: Map[String, Any]): ReadyApplication = new ReadyApplication(json, cache)

      def make20(id: ApplicationId, flags: Application.Flags): ReadyApplication =
        makeRawFromFields("id" := id, "flags" := flags)

    }
  }

  /**
    * The resumed event is dispatched when a client has sent a resume payload to
    * the gateway (for resuming existing sessions).
    */
  class Resumed(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    override def values: Seq[() => Any] = Seq()
  }
  object Resumed extends DiscordObjectCompanion[Resumed] {
    def makeRaw(json: Json, cache: Map[String, Any]): Resumed = new Resumed(json, cache)

    def make20(): Resumed = makeRawFromFields()

  }

  /**
    * APPLICATION_COMMAND_PERMISSIONS_UPDATE event, sent when an application
    * command's permissions are updated. The inner payload is an application
    * command permissions object.
    */
  class ApplicationCommandPermissionsUpdate(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {
    @inline def data: ApplicationCommandPermissionsUpdate.ApplicationCommandPermissionsStub =
      ApplicationCommandPermissionsUpdate.ApplicationCommandPermissionsStub.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ApplicationCommandPermissionsUpdate extends DiscordObjectCompanion[ApplicationCommandPermissionsUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ApplicationCommandPermissionsUpdate =
      new ApplicationCommandPermissionsUpdate(json, cache)

    def make20(
        data: ApplicationCommandPermissionsUpdate.ApplicationCommandPermissionsStub
    ): ApplicationCommandPermissionsUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))

    class ApplicationCommandPermissionsStub(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object ApplicationCommandPermissionsStub extends DiscordObjectCompanion[ApplicationCommandPermissionsStub] {
      def makeRaw(json: Json, cache: Map[String, Any]): ApplicationCommandPermissionsStub =
        new ApplicationCommandPermissionsStub(json, cache)

      def make20(): ApplicationCommandPermissionsStub = makeRawFromFields()

    }
  }

  /**
    * Sent when a rule is created. The inner payload is an auto moderation rule
    * object.
    */
  class AutoModerationRuleCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: AutoModerationRule = AutoModerationRule.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object AutoModerationRuleCreate extends DiscordObjectCompanion[AutoModerationRuleCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationRuleCreate =
      new AutoModerationRuleCreate(json, cache)

    def make20(data: AutoModerationRule): AutoModerationRuleCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("data", data)
    )

  }

  /**
    * Sent when a rule is updated. The inner payload is an auto moderation rule
    * object.
    */
  class AutoModerationRuleUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: AutoModerationRule = AutoModerationRule.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object AutoModerationRuleUpdate extends DiscordObjectCompanion[AutoModerationRuleUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationRuleUpdate =
      new AutoModerationRuleUpdate(json, cache)

    def make20(data: AutoModerationRule): AutoModerationRuleUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("data", data)
    )

  }

  /**
    * Sent when a rule is deleted. The inner payload is an auto moderation rule
    * object.
    */
  class AutoModerationRuleDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: AutoModerationRule = AutoModerationRule.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object AutoModerationRuleDelete extends DiscordObjectCompanion[AutoModerationRuleDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationRuleDelete =
      new AutoModerationRuleDelete(json, cache)

    def make20(data: AutoModerationRule): AutoModerationRuleDelete = makeRawFromFields(
      DiscordObjectFrom.FromExtension("data", data)
    )

  }

  /**
    * Sent when a rule is triggered and an action is executed (e.g. when a
    * message is blocked).
    */
  class AutoModerationActionExecution(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {

    /** ID of the guild in which action was executed */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Action which was executed */
    @inline def action: AutoModerationRule.AutoModerationRuleAction =
      selectDynamic[AutoModerationRule.AutoModerationRuleAction]("action")

    /** ID of the rule which action belongs to */
    @inline def ruleId: Snowflake[AutoModerationRule] = selectDynamic[Snowflake[AutoModerationRule]]("rule_id")

    /** Trigger type of rule which was triggered */
    @inline def ruleTriggerType: AutoModerationRule.AutoModerationRuleTriggerType =
      selectDynamic[AutoModerationRule.AutoModerationRuleTriggerType]("rule_trigger_type")

    /** ID of the user which generated the content which triggered the rule */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    /** ID of the channel in which user content was posted */
    @inline def channelId: UndefOr[TextGuildChannelId] = selectDynamic[UndefOr[TextGuildChannelId]]("channel_id")

    /** ID of any user message which content belongs to */
    @inline def messageId: UndefOr[MessageId] = selectDynamic[UndefOr[MessageId]]("message_id")

    /**
      * ID of any system auto moderation messages posted as a result of this
      * action
      */
    @inline def alertSystemMessageId: UndefOr[MessageId] = selectDynamic[UndefOr[MessageId]]("alert_system_message_id")

    /** User-generated text content */
    @inline def content: String = selectDynamic[String]("content")

    /** Word or phrase configured in the rule that triggered the rule */
    @inline def matchedKeyword: Option[String] = selectDynamic[Option[String]]("matched_keyword")

    /** Substring in content that triggered the rule */
    @inline def matchedContent: Option[String] = selectDynamic[Option[String]]("matched_content")

    override def values: Seq[() => Any] = Seq(
      () => guildId,
      () => action,
      () => ruleId,
      () => ruleTriggerType,
      () => userId,
      () => channelId,
      () => messageId,
      () => alertSystemMessageId,
      () => content,
      () => matchedKeyword,
      () => matchedContent
    )
  }
  object AutoModerationActionExecution extends DiscordObjectCompanion[AutoModerationActionExecution] {
    def makeRaw(json: Json, cache: Map[String, Any]): AutoModerationActionExecution =
      new AutoModerationActionExecution(json, cache)

    /**
      * @param guildId
      *   ID of the guild in which action was executed
      * @param action
      *   Action which was executed
      * @param ruleId
      *   ID of the rule which action belongs to
      * @param ruleTriggerType
      *   Trigger type of rule which was triggered
      * @param userId
      *   ID of the user which generated the content which triggered the rule
      * @param channelId
      *   ID of the channel in which user content was posted
      * @param messageId
      *   ID of any user message which content belongs to
      * @param alertSystemMessageId
      *   ID of any system auto moderation messages posted as a result of this
      *   action
      * @param content
      *   User-generated text content
      * @param matchedKeyword
      *   Word or phrase configured in the rule that triggered the rule
      * @param matchedContent
      *   Substring in content that triggered the rule
      */
    def make20(
        guildId: GuildId,
        action: AutoModerationRule.AutoModerationRuleAction,
        ruleId: Snowflake[AutoModerationRule],
        ruleTriggerType: AutoModerationRule.AutoModerationRuleTriggerType,
        userId: UserId,
        channelId: UndefOr[TextGuildChannelId] = UndefOrUndefined,
        messageId: UndefOr[MessageId] = UndefOrUndefined,
        alertSystemMessageId: UndefOr[MessageId] = UndefOrUndefined,
        content: String,
        matchedKeyword: Option[String],
        matchedContent: Option[String]
    ): AutoModerationActionExecution = makeRawFromFields(
      "guild_id"                 := guildId,
      "action"                   := action,
      "rule_id"                  := ruleId,
      "rule_trigger_type"        := ruleTriggerType,
      "user_id"                  := userId,
      "channel_id"              :=? channelId,
      "message_id"              :=? messageId,
      "alert_system_message_id" :=? alertSystemMessageId,
      "content"                  := content,
      "matched_keyword"          := matchedKeyword,
      "matched_content"          := matchedContent
    )

  }

  /**
    * Sent when a new guild channel is created, relevant to the current user.
    * The inner payload is a channel object.
    */
  class ChannelCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: GuildChannel = GuildChannel.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ChannelCreate extends DiscordObjectCompanion[ChannelCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelCreate = new ChannelCreate(json, cache)

    def make20(data: GuildChannel): ChannelCreate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))

  }

  /**
    * * Sent when a channel is updated. The inner payload is a channel object.
    * This is not sent when the field last_message_id is altered. To keep track
    * of the last_message_id changes, you must listen for Message Create events
    * (or Thread Create events for GUILD_FORUM channels).
    *
    * This event may reference roles or guild members that no longer exist in
    * the guild.
    */
  class ChannelUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: GuildChannel = GuildChannel.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ChannelUpdate extends DiscordObjectCompanion[ChannelUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelUpdate = new ChannelUpdate(json, cache)

    def make20(data: GuildChannel): ChannelUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))

  }

  /**
    * Sent when a channel relevant to the current user is deleted. The inner
    * payload is a channel object.
    */
  class ChannelDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: GuildChannel = GuildChannel.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ChannelDelete extends DiscordObjectCompanion[ChannelDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelDelete = new ChannelDelete(json, cache)

    def make20(data: GuildChannel): ChannelDelete = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))

  }

  /**
    * * Sent when a thread is created, relevant to the current user, or when the
    * current user is added to a thread. The inner payload is a channel object.
    *   - When a thread is created, includes an additional newly_created boolean
    *     field.
    *   - When being added to an existing private thread, includes a thread
    *     member object.
    */
  class ThreadCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: ThreadChannel = ThreadChannel.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ThreadCreate extends DiscordObjectCompanion[ThreadCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadCreate = new ThreadCreate(json, cache)

    def make20(data: ThreadChannel): ThreadCreate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))

  }

  /**
    * Sent when a thread is updated. The inner payload is a channel object. This
    * is not sent when the field last_message_id is altered. To keep track of
    * the last_message_id changes, you must listen for Message Create events.
    */
  class ThreadUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def data: ThreadChannel = ThreadChannel.makeRaw(json, extensionCache("data"))

    override def values: Seq[() => Any] = Seq(() => data)
  }
  object ThreadUpdate extends DiscordObjectCompanion[ThreadUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadUpdate = new ThreadUpdate(json, cache)

    def make20(data: ThreadChannel): ThreadUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("data", data))

  }

  /**
    * Sent when a thread relevant to the current user is deleted. The inner
    * payload is a subset of the channel object, containing just the id,
    * guild_id, parent_id, and type.
    */
  class ThreadDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def id: ThreadChannelId = selectDynamic[ThreadChannelId]("id")

    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def parentId: GuildChannelId = selectDynamic[GuildChannelId]("parent_id")

    @inline def tpe: Channel.ChannelType = selectDynamic[Channel.ChannelType]("type")

    override def values: Seq[() => Any] = Seq(() => id, () => guildId, () => parentId, () => tpe)
  }
  object ThreadDelete extends DiscordObjectCompanion[ThreadDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadDelete = new ThreadDelete(json, cache)

    def make20(
        id: ThreadChannelId,
        guildId: GuildId,
        parentId: GuildChannelId,
        tpe: Channel.ChannelType
    ): ThreadDelete = makeRawFromFields("id" := id, "guild_id" := guildId, "parent_id" := parentId, "type" := tpe)

  }

  /** Sent when the current user gains access to a channel. */
  class ThreadListSync(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /**
      * Parent channel IDs whose threads are being synced. If omitted, then
      * threads were synced for the entire guild. This array may contain
      * channel_ids that have no active threads as well, so you know to clear
      * that data.
      */
    @inline def channelIds: Seq[GuildChannelId] = selectDynamic[Seq[GuildChannelId]]("channel_ids")

    /**
      * All active threads in the given channels that the current user can
      * access
      */
    @inline def threads: Seq[ThreadChannel] = selectDynamic[Seq[ThreadChannel]]("threads")

    /**
      * All thread member objects from the synced threads for the current user,
      * indicating which threads the current user has been added to
      */
    @inline def members: Seq[Channel.ThreadMember] = selectDynamic[Seq[Channel.ThreadMember]]("members")

    override def values: Seq[() => Any] = Seq(() => guildId, () => channelIds, () => threads, () => members)
  }
  object ThreadListSync extends DiscordObjectCompanion[ThreadListSync] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadListSync = new ThreadListSync(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param channelIds
      *   Parent channel IDs whose threads are being synced. If omitted, then
      *   threads were synced for the entire guild. This array may contain
      *   channel_ids that have no active threads as well, so you know to clear
      *   that data.
      * @param threads
      *   All active threads in the given channels that the current user can
      *   access
      * @param members
      *   All thread member objects from the synced threads for the current
      *   user, indicating which threads the current user has been added to
      */
    def make20(
        guildId: GuildId,
        channelIds: Seq[GuildChannelId],
        threads: Seq[ThreadChannel],
        members: Seq[Channel.ThreadMember]
    ): ThreadListSync =
      makeRawFromFields("guild_id" := guildId, "channel_ids" := channelIds, "threads" := threads, "members" := members)

  }

  /**
    * Sent when the thread member object for the current user is updated. The
    * inner payload is a thread member object with an extra guild_id field. This
    * event is documented for completeness, but unlikely to be used by most
    * bots. For bots, this event largely is just a signal that you are a member
    * of the thread. See the threads docs for more details
    */
  class ThreadMemberUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Rest of the thread member object */
    @inline def threadMember: Channel.ThreadMember = Channel.ThreadMember.makeRaw(json, extensionCache("thread_member"))

    override def values: Seq[() => Any] = Seq(() => guildId, () => threadMember)
  }
  object ThreadMemberUpdate extends DiscordObjectCompanion[ThreadMemberUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMemberUpdate = new ThreadMemberUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param threadMember
      *   Rest of the thread member object
      */
    def make20(guildId: GuildId, threadMember: Channel.ThreadMember): ThreadMemberUpdate =
      makeRawFromFields("guild_id" := guildId, DiscordObjectFrom.FromExtension("thread_member", threadMember))

  }

  /**
    * Sent when anyone is added to or removed from a thread. If the current user
    * does not have the GUILD_MEMBERS Gateway Intent, then this event will only
    * be sent if the current user was added to or removed from the thread.
    */
  class ThreadMembersUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the thread */
    @inline def id: ThreadChannelId = selectDynamic[ThreadChannelId]("id")

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Approximate number of members in the thread, capped at 50 */
    @inline def memberCount: Int = selectDynamic[Int]("member_count")

    /** Users who were added to the thread */
    @inline def addedMembers: UndefOr[Seq[Channel.ThreadMember]] =
      selectDynamic[UndefOr[Seq[Channel.ThreadMember]]]("added_members")

    /** ID of the users who were removed from the thread */
    @inline def removedMemberIds: UndefOr[Seq[UserId]] = selectDynamic[UndefOr[Seq[UserId]]]("removed_member_ids")

    override def values: Seq[() => Any] =
      Seq(() => id, () => guildId, () => memberCount, () => addedMembers, () => removedMemberIds)
  }
  object ThreadMembersUpdate extends DiscordObjectCompanion[ThreadMembersUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ThreadMembersUpdate = new ThreadMembersUpdate(json, cache)

    /**
      * @param id
      *   ID of the thread
      * @param guildId
      *   ID of the guild
      * @param memberCount
      *   Approximate number of members in the thread, capped at 50
      * @param addedMembers
      *   Users who were added to the thread
      * @param removedMemberIds
      *   ID of the users who were removed from the thread
      */
    def make20(
        id: ThreadChannelId,
        guildId: GuildId,
        memberCount: Int,
        addedMembers: UndefOr[Seq[Channel.ThreadMember]] = UndefOrUndefined,
        removedMemberIds: UndefOr[Seq[UserId]] = UndefOrUndefined
    ): ThreadMembersUpdate = makeRawFromFields(
      "id"                  := id,
      "guild_id"            := guildId,
      "member_count"        := memberCount,
      "added_members"      :=? addedMembers,
      "removed_member_ids" :=? removedMemberIds
    )

  }

  /**
    * Sent when a message is pinned or unpinned in a text channel. This is not
    * sent when a pinned message is deleted.
    */
  class ChannelPinsUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** Time at which the most recent pinned message was pinned */
    @inline def lastPinTimestamp: JsonOption[OffsetDateTime] =
      selectDynamic[JsonOption[OffsetDateTime]]("last_pin_timestamp")

    override def values: Seq[() => Any] = Seq(() => guildId, () => channelId, () => lastPinTimestamp)
  }
  object ChannelPinsUpdate extends DiscordObjectCompanion[ChannelPinsUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): ChannelPinsUpdate = new ChannelPinsUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param channelId
      *   ID of the channel
      * @param lastPinTimestamp
      *   Time at which the most recent pinned message was pinned
      */
    def make20(
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        channelId: TextChannelId,
        lastPinTimestamp: JsonOption[OffsetDateTime] = JsonUndefined
    ): ChannelPinsUpdate =
      makeRawFromFields("guild_id" :=? guildId, "channel_id" := channelId, "last_pin_timestamp" :=? lastPinTimestamp)

  }

  /**
    * * This event can be sent in three different scenarios:
    *   1. When a user is initially connecting, to lazily load and backfill
    *      information for all unavailable guilds sent in the Ready event.
    *      Guilds that are unavailable due to an outage will send a Guild Delete
    *      event. 2. When a Guild becomes available again to the client. 3. When
    *      the current user joins a new Guild.
    *
    * During an outage, the guild object in scenarios 1 and 3 may be marked as
    * unavailable.
    *
    * The inner payload can be:
    *   1. An available Guild: a guild object with extra fields, as noted below.
    *      2. An unavailable Guild: an unavailable guild object.
    */
  class GuildCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def guild: GuildCreate.GuildCreateGuild =
      GuildCreate.GuildCreateGuild.makeRaw(json, extensionCache("guild"))

    override def values: Seq[() => Any] = Seq(() => guild)
  }
  object GuildCreate extends DiscordObjectCompanion[GuildCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildCreate = new GuildCreate(json, cache)

    def make20(guild: GuildCreate.GuildCreateGuild): GuildCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("guild", guild)
    )

    sealed trait GuildCreateGuild extends DiscordObject

    object GuildCreateGuild extends DiscordObjectCompanion[GuildCreateGuild] {
      override def makeRaw(json: Json, cache: Map[String, Any]): GuildCreateGuild = {
        if (json.hcursor.getOrElse[Boolean]("unavailable")(false).contains(true)) {
          GuildCreateUnavailableGuild.makeRaw(json, cache)
        } else {
          AvailableGuild.makeRaw(json, cache)
        }
      }
    }

    class AvailableGuild(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache)
        with GuildCreateGuild {
      @inline def guild: Guild = Guild.makeRaw(json, extensionCache("guild"))

      /** When this guild was joined at */
      @inline def joinedAt: OffsetDateTime = selectDynamic[OffsetDateTime]("joined_at")

      /** True if this is considered a large guild */
      @inline def large: Boolean = selectDynamic[Boolean]("large")

      /** Total number of members in this guild */
      @inline def memberCount: Int = selectDynamic[Int]("member_count")

      /**
        * States of members currently in voice channels; lacks the guild_id key
        */
      @inline def voiceStates: Seq[VoiceState] = selectDynamic[Seq[VoiceState]]("voice_states")

      /** Users in the guild */
      @inline def members: Seq[GuildMember] = selectDynamic[Seq[GuildMember]]("members")

      /** Channels in the guild */
      @inline def channels: Seq[GuildChannel] = selectDynamic[Seq[GuildChannel]]("channels")

      /**
        * All active threads in the guild that current user has permission to
        * view
        */
      @inline def threads: Seq[ThreadChannel] = selectDynamic[Seq[ThreadChannel]]("threads")

      /**
        * Presences of the members in the guild, will only include non-offline
        * members if the size is greater than large threshold
        */
      @inline def presences: Seq[AvailableGuild.AvailableGuildPresenceUpdate] =
        selectDynamic[Seq[AvailableGuild.AvailableGuildPresenceUpdate]]("presences")

      /** Stage instances in the guild */
      @inline def stageInstances: Seq[StageInstance] = selectDynamic[Seq[StageInstance]]("stage_instances")

      /** Scheduled events in the guild */
      @inline def guildScheduledEvents: Seq[GuildScheduledEvent] =
        selectDynamic[Seq[GuildScheduledEvent]]("guild_scheduled_events")

      override def values: Seq[() => Any] = Seq(
        () => guild,
        () => joinedAt,
        () => large,
        () => memberCount,
        () => voiceStates,
        () => members,
        () => channels,
        () => threads,
        () => presences,
        () => stageInstances,
        () => guildScheduledEvents
      )
    }
    object AvailableGuild extends DiscordObjectCompanion[AvailableGuild] {
      def makeRaw(json: Json, cache: Map[String, Any]): AvailableGuild = new AvailableGuild(json, cache)

      /**
        * @param joinedAt
        *   When this guild was joined at
        * @param large
        *   True if this is considered a large guild
        * @param memberCount
        *   Total number of members in this guild
        * @param voiceStates
        *   States of members currently in voice channels; lacks the guild_id
        *   key
        * @param members
        *   Users in the guild
        * @param channels
        *   Channels in the guild
        * @param threads
        *   All active threads in the guild that current user has permission to
        *   view
        * @param presences
        *   Presences of the members in the guild, will only include non-offline
        *   members if the size is greater than large threshold
        * @param stageInstances
        *   Stage instances in the guild
        * @param guildScheduledEvents
        *   Scheduled events in the guild
        */
      def make20(
          guild: Guild,
          joinedAt: OffsetDateTime,
          large: Boolean,
          memberCount: Int,
          voiceStates: Seq[VoiceState],
          members: Seq[GuildMember],
          channels: Seq[GuildChannel],
          threads: Seq[ThreadChannel],
          presences: Seq[AvailableGuild.AvailableGuildPresenceUpdate],
          stageInstances: Seq[StageInstance],
          guildScheduledEvents: Seq[GuildScheduledEvent]
      ): AvailableGuild = makeRawFromFields(
        DiscordObjectFrom.FromExtension("guild", guild),
        "joined_at"              := joinedAt,
        "large"                  := large,
        "member_count"           := memberCount,
        "voice_states"           := voiceStates,
        "members"                := members,
        "channels"               := channels,
        "threads"                := threads,
        "presences"              := presences,
        "stage_instances"        := stageInstances,
        "guild_scheduled_events" := guildScheduledEvents
      )

      class AvailableGuildPresenceUpdate(json: Json, cache: Map[String, Any] = Map.empty)
          extends DiscordObject(json, cache) {
        @inline def presenceUpdate: PresenceUpdate = PresenceUpdate.makeRaw(json, extensionCache("presenceUpdate"))

        override def values: Seq[() => Any] = Seq(() => presenceUpdate)
      }
      object AvailableGuildPresenceUpdate extends DiscordObjectCompanion[AvailableGuildPresenceUpdate] {
        def makeRaw(json: Json, cache: Map[String, Any]): AvailableGuildPresenceUpdate =
          new AvailableGuildPresenceUpdate(json, cache)

        def make20(presenceUpdate: PresenceUpdate): AvailableGuildPresenceUpdate = makeRawFromFields(
          DiscordObjectFrom.FromExtension("presenceUpdate", presenceUpdate)
        )

      }
    }

    class GuildCreateUnavailableGuild(json: Json, cache: Map[String, Any] = Map.empty)
        extends DiscordObject(json, cache)
        with GuildCreateGuild {
      @inline def guild: UnavailableGuild = UnavailableGuild.makeRaw(json, extensionCache("guild"))

      override def values: Seq[() => Any] = Seq(() => guild)
    }
    object GuildCreateUnavailableGuild extends DiscordObjectCompanion[GuildCreateUnavailableGuild] {
      def makeRaw(json: Json, cache: Map[String, Any]): GuildCreateUnavailableGuild =
        new GuildCreateUnavailableGuild(json, cache)

      def make20(guild: UnavailableGuild): GuildCreateUnavailableGuild = makeRawFromFields(
        DiscordObjectFrom.FromExtension("guild", guild)
      )

    }
  }

  /** Sent when a guild is updated. The inner payload is a guild object. */
  class GuildUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def guild: Guild = Guild.makeRaw(json, extensionCache("guild"))

    override def values: Seq[() => Any] = Seq(() => guild)
  }
  object GuildUpdate extends DiscordObjectCompanion[GuildUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildUpdate = new GuildUpdate(json, cache)

    def make20(guild: Guild): GuildUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("guild", guild))

  }

  /**
    * Sent when a guild becomes or was already unavailable due to an outage, or
    * when the user leaves or is removed from a guild. The inner payload is an
    * unavailable guild object. If the unavailable field is not set, the user
    * was removed from the guild.
    */
  class GuildDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def unavailableGuild: UnavailableGuild = UnavailableGuild.makeRaw(json, extensionCache("unavailable_guild"))

    override def values: Seq[() => Any] = Seq(() => unavailableGuild)
  }
  object GuildDelete extends DiscordObjectCompanion[GuildDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildDelete = new GuildDelete(json, cache)

    def make20(unavailableGuild: UnavailableGuild): GuildDelete = makeRawFromFields(
      DiscordObjectFrom.FromExtension("unavailable_guild", unavailableGuild)
    )

  }

  /**
    * Sent when a guild audit log entry is created. The inner payload is an
    * Audit Log Entry object. This event is only sent to bots with the
    * VIEW_AUDIT_LOG permission.
    */
  class GuildAuditLogEntryCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def auditLogEntry: AuditLog.AuditLogEntry =
      AuditLog.AuditLogEntry.makeRaw(json, extensionCache("audit_log_entry"))

    override def values: Seq[() => Any] = Seq(() => auditLogEntry)
  }
  object GuildAuditLogEntryCreate extends DiscordObjectCompanion[GuildAuditLogEntryCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildAuditLogEntryCreate =
      new GuildAuditLogEntryCreate(json, cache)

    def make20(auditLogEntry: AuditLog.AuditLogEntry): GuildAuditLogEntryCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("audit_log_entry", auditLogEntry)
    )

  }

  /** Sent when a user is banned from a guild. */
  class GuildBanAdd(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** User who was banned */
    @inline def user: User = selectDynamic[User]("user")

    override def values: Seq[() => Any] = Seq(() => guildId, () => user)
  }
  object GuildBanAdd extends DiscordObjectCompanion[GuildBanAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildBanAdd = new GuildBanAdd(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param user
      *   User who was banned
      */
    def make20(guildId: GuildId, user: User): GuildBanAdd = makeRawFromFields("guild_id" := guildId, "user" := user)

  }

  /** Sent when a user is unbanned from a guild. */
  class GuildBanRemove(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** User who was unbanned */
    @inline def user: User = selectDynamic[User]("user")

    override def values: Seq[() => Any] = Seq(() => guildId, () => user)
  }
  object GuildBanRemove extends DiscordObjectCompanion[GuildBanRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildBanRemove = new GuildBanRemove(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param user
      *   User who was unbanned
      */
    def make20(guildId: GuildId, user: User): GuildBanRemove = makeRawFromFields("guild_id" := guildId, "user" := user)

  }

  /** Sent when a guild's emojis have been updated. */
  class GuildEmojisUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Array of emojis */
    @inline def emojis: Seq[Emoji] = selectDynamic[Seq[Emoji]]("emojis")

    override def values: Seq[() => Any] = Seq(() => guildId, () => emojis)
  }
  object GuildEmojisUpdate extends DiscordObjectCompanion[GuildEmojisUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildEmojisUpdate = new GuildEmojisUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param emojis
      *   Array of emojis
      */
    def make20(guildId: GuildId, emojis: Seq[Emoji]): GuildEmojisUpdate =
      makeRawFromFields("guild_id" := guildId, "emojis" := emojis)

  }

  /** Sent when a guild's stickers have been updated. */
  class GuildStickersUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Array of stickers */
    @inline def stickers: Seq[Sticker] = selectDynamic[Seq[Sticker]]("stickers")

    override def values: Seq[() => Any] = Seq(() => guildId, () => stickers)
  }
  object GuildStickersUpdate extends DiscordObjectCompanion[GuildStickersUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildStickersUpdate = new GuildStickersUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param stickers
      *   Array of stickers
      */
    def make20(guildId: GuildId, stickers: Seq[Sticker]): GuildStickersUpdate =
      makeRawFromFields("guild_id" := guildId, "stickers" := stickers)

  }

  /** Sent when a guild integration is updated. */
  class GuildIntegrationsUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild whose integrations were updated */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    override def values: Seq[() => Any] = Seq(() => guildId)
  }
  object GuildIntegrationsUpdate extends DiscordObjectCompanion[GuildIntegrationsUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildIntegrationsUpdate = new GuildIntegrationsUpdate(json, cache)

    /** @param guildId ID of the guild whose integrations were updated */
    def make20(guildId: GuildId): GuildIntegrationsUpdate = makeRawFromFields("guild_id" := guildId)

  }

  /**
    * Sent when a new user joins a guild. The inner payload is a guild member
    * object with an extra guild_id key:
    */
  class GuildMemberAdd(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    @inline def guildMember: GuildMember = GuildMember.makeRaw(json, extensionCache("guild_member"))

    override def values: Seq[() => Any] = Seq(() => guildId, () => guildMember)
  }
  object GuildMemberAdd extends DiscordObjectCompanion[GuildMemberAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMemberAdd = new GuildMemberAdd(json, cache)

    /** @param guildId ID of the guild */
    def make20(guildId: GuildId, guildMember: GuildMember): GuildMemberAdd =
      makeRawFromFields("guild_id" := guildId, DiscordObjectFrom.FromExtension("guild_member", guildMember))

  }

  /** Sent when a user is removed from a guild (leave/kick/ban). */
  class GuildMemberRemove(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** User who was removed */
    @inline def user: User = selectDynamic[User]("user")

    override def values: Seq[() => Any] = Seq(() => guildId, () => user)
  }
  object GuildMemberRemove extends DiscordObjectCompanion[GuildMemberRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMemberRemove = new GuildMemberRemove(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param user
      *   User who was removed
      */
    def make20(guildId: GuildId, user: User): GuildMemberRemove =
      makeRawFromFields("guild_id" := guildId, "user" := user)

  }

  /**
    * Sent when a guild member is updated. This will also fire when the user
    * object of a guild member changes.
    */
  class GuildMemberUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** User role ids */
    @inline def roles: Seq[RoleId] = selectDynamic[Seq[RoleId]]("roles")

    /** User */
    @inline def user: User = selectDynamic[User]("user")

    /** Nickname of the user in the guild */
    @inline def nick: JsonOption[String] = selectDynamic[JsonOption[String]]("nick")

    /** Member's guild avatar hash */
    @inline def avatar: Option[ImageHash] = selectDynamic[Option[ImageHash]]("avatar")

    /** When the user joined the guild */
    @inline def joinedAt: Option[OffsetDateTime] = selectDynamic[Option[OffsetDateTime]]("joined_at")

    /** When the user starting boosting the guild */
    @inline def premiumSince: JsonOption[OffsetDateTime] = selectDynamic[JsonOption[OffsetDateTime]]("premium_since")

    /** Whether the user is deafened in voice channels */
    @inline def deaf: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("deaf")

    /** Whether the user is muted in voice channels */
    @inline def mute: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("mute")

    /**
      * Whether the user has not yet passed the guild's Membership Screening
      * requirements
      */
    @inline def pending: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("pending")

    /**
      * When the user's timeout will expire and the user will be able to
      * communicate in the guild again, null or a time in the past if the user
      * is not timed out
      */
    @inline def communicationDisabledUntil: JsonOption[OffsetDateTime] =
      selectDynamic[JsonOption[OffsetDateTime]]("communication_disabled_until")

    override def values: Seq[() => Any] = Seq(
      () => guildId,
      () => roles,
      () => user,
      () => nick,
      () => avatar,
      () => joinedAt,
      () => premiumSince,
      () => deaf,
      () => mute,
      () => pending,
      () => communicationDisabledUntil
    )
  }
  object GuildMemberUpdate extends DiscordObjectCompanion[GuildMemberUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMemberUpdate = new GuildMemberUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param roles
      *   User role ids
      * @param user
      *   User
      * @param nick
      *   Nickname of the user in the guild
      * @param avatar
      *   Member's guild avatar hash
      * @param joinedAt
      *   When the user joined the guild
      * @param premiumSince
      *   When the user starting boosting the guild
      * @param deaf
      *   Whether the user is deafened in voice channels
      * @param mute
      *   Whether the user is muted in voice channels
      * @param pending
      *   Whether the user has not yet passed the guild's Membership Screening
      *   requirements
      * @param communicationDisabledUntil
      *   When the user's timeout will expire and the user will be able to
      *   communicate in the guild again, null or a time in the past if the user
      *   is not timed out
      */
    def make20(
        guildId: GuildId,
        roles: Seq[RoleId],
        user: User,
        nick: JsonOption[String] = JsonUndefined,
        avatar: Option[ImageHash],
        joinedAt: Option[OffsetDateTime],
        premiumSince: JsonOption[OffsetDateTime] = JsonUndefined,
        deaf: UndefOr[Boolean] = UndefOrUndefined,
        mute: UndefOr[Boolean] = UndefOrUndefined,
        pending: UndefOr[Boolean] = UndefOrUndefined,
        communicationDisabledUntil: JsonOption[OffsetDateTime] = JsonUndefined
    ): GuildMemberUpdate = makeRawFromFields(
      "guild_id"                      := guildId,
      "roles"                         := roles,
      "user"                          := user,
      "nick"                         :=? nick,
      "avatar"                        := avatar,
      "joined_at"                     := joinedAt,
      "premium_since"                :=? premiumSince,
      "deaf"                         :=? deaf,
      "mute"                         :=? mute,
      "pending"                      :=? pending,
      "communication_disabled_until" :=? communicationDisabledUntil
    )

  }

  /**
    * Sent in response to Guild Request Members. You can use the chunk_index and
    * chunk_count to calculate how many chunks are left for your request.
    */
  class GuildMembersChunk(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Set of guild members */
    @inline def members: Seq[GuildMember] = selectDynamic[Seq[GuildMember]]("members")

    /**
      * Chunk index in the expected chunks for this response (0 <= chunk_index <
      * chunk_count)
      */
    @inline def chunkIndex: Int = selectDynamic[Int]("chunk_index")

    /** Total number of expected chunks for this response */
    @inline def chunkCount: Int = selectDynamic[Int]("chunk_count")

    /**
      * When passing an invalid ID to REQUEST_GUILD_MEMBERS, it will be returned
      * here
      */
    @inline def notFound: UndefOr[Seq[UserId]] = selectDynamic[UndefOr[Seq[UserId]]]("not_found")

    /**
      * When passing true to REQUEST_GUILD_MEMBERS, presences of the returned
      * members will be here
      */
    @inline def presences: UndefOr[Seq[PresenceUpdate]] = selectDynamic[UndefOr[Seq[PresenceUpdate]]]("presences")

    /** Nonce used in the Guild Members Request */
    @inline def nonce: UndefOr[String] = selectDynamic[UndefOr[String]]("nonce")

    override def values: Seq[() => Any] = Seq(
      () => guildId,
      () => members,
      () => chunkIndex,
      () => chunkCount,
      () => notFound,
      () => presences,
      () => nonce
    )
  }
  object GuildMembersChunk extends DiscordObjectCompanion[GuildMembersChunk] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildMembersChunk = new GuildMembersChunk(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param members
      *   Set of guild members
      * @param chunkIndex
      *   Chunk index in the expected chunks for this response (0 <= chunk_index
      *   < chunk_count)
      * @param chunkCount
      *   Total number of expected chunks for this response
      * @param notFound
      *   When passing an invalid ID to REQUEST_GUILD_MEMBERS, it will be
      *   returned here
      * @param presences
      *   When passing true to REQUEST_GUILD_MEMBERS, presences of the returned
      *   members will be here
      * @param nonce
      *   Nonce used in the Guild Members Request
      */
    def make20(
        guildId: GuildId,
        members: Seq[GuildMember],
        chunkIndex: Int,
        chunkCount: Int,
        notFound: UndefOr[Seq[UserId]] = UndefOrUndefined,
        presences: UndefOr[Seq[PresenceUpdate]] = UndefOrUndefined,
        nonce: UndefOr[String] = UndefOrUndefined
    ): GuildMembersChunk = makeRawFromFields(
      "guild_id"    := guildId,
      "members"     := members,
      "chunk_index" := chunkIndex,
      "chunk_count" := chunkCount,
      "not_found"  :=? notFound,
      "presences"  :=? presences,
      "nonce"      :=? nonce
    )

  }

  /** Sent when a guild role is created. */
  class GuildRoleCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Role that was created */
    @inline def role: Role = selectDynamic[Role]("role")

    override def values: Seq[() => Any] = Seq(() => guildId, () => role)
  }
  object GuildRoleCreate extends DiscordObjectCompanion[GuildRoleCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildRoleCreate = new GuildRoleCreate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param role
      *   Role that was created
      */
    def make20(guildId: GuildId, role: Role): GuildRoleCreate = makeRawFromFields("guild_id" := guildId, "role" := role)

  }

  /** Sent when a guild role is updated. */
  class GuildRoleUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Role that was updated */
    @inline def role: Role = selectDynamic[Role]("role")

    override def values: Seq[() => Any] = Seq(() => guildId, () => role)
  }
  object GuildRoleUpdate extends DiscordObjectCompanion[GuildRoleUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildRoleUpdate = new GuildRoleUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param role
      *   Role that was updated
      */
    def make20(guildId: GuildId, role: Role): GuildRoleUpdate = makeRawFromFields("guild_id" := guildId, "role" := role)

  }

  /** Sent when a guild role is deleted. */
  class GuildRoleDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** ID of the role */
    @inline def roleId: RoleId = selectDynamic[RoleId]("role_id")

    override def values: Seq[() => Any] = Seq(() => guildId, () => roleId)
  }
  object GuildRoleDelete extends DiscordObjectCompanion[GuildRoleDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildRoleDelete = new GuildRoleDelete(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param roleId
      *   ID of the role
      */
    def make20(guildId: GuildId, roleId: RoleId): GuildRoleDelete =
      makeRawFromFields("guild_id" := guildId, "role_id" := roleId)

  }

  /**
    * Sent when a guild scheduled event is created. The inner payload is a guild
    * scheduled event object.
    */
  class GuildScheduledEventCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def scheduledEvent: GuildScheduledEvent =
      GuildScheduledEvent.makeRaw(json, extensionCache("scheduled_event"))

    override def values: Seq[() => Any] = Seq(() => scheduledEvent)
  }
  object GuildScheduledEventCreate extends DiscordObjectCompanion[GuildScheduledEventCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventCreate =
      new GuildScheduledEventCreate(json, cache)

    def make20(scheduledEvent: GuildScheduledEvent): GuildScheduledEventCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("scheduled_event", scheduledEvent)
    )

  }

  /**
    * Sent when a guild scheduled event is updated. The inner payload is a guild
    * scheduled event object.
    */
  class GuildScheduledEventUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def scheduledEvent: GuildScheduledEvent =
      GuildScheduledEvent.makeRaw(json, extensionCache("scheduled_event"))

    override def values: Seq[() => Any] = Seq(() => scheduledEvent)
  }
  object GuildScheduledEventUpdate extends DiscordObjectCompanion[GuildScheduledEventUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventUpdate =
      new GuildScheduledEventUpdate(json, cache)

    def make20(scheduledEvent: GuildScheduledEvent): GuildScheduledEventUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("scheduled_event", scheduledEvent)
    )

  }

  /**
    * Sent when a guild scheduled event is deleted. The inner payload is a guild
    * scheduled event object.
    */
  class GuildScheduledEventDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def scheduledEvent: GuildScheduledEvent =
      GuildScheduledEvent.makeRaw(json, extensionCache("scheduled_event"))

    override def values: Seq[() => Any] = Seq(() => scheduledEvent)
  }
  object GuildScheduledEventDelete extends DiscordObjectCompanion[GuildScheduledEventDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventDelete =
      new GuildScheduledEventDelete(json, cache)

    def make20(scheduledEvent: GuildScheduledEvent): GuildScheduledEventDelete = makeRawFromFields(
      DiscordObjectFrom.FromExtension("scheduled_event", scheduledEvent)
    )

  }

  /** Sent when a user has subscribed to a guild scheduled event. */
  class GuildScheduledEventUserAdd(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def guildScheduledEventId: Snowflake[GuildScheduledEvent] =
      selectDynamic[Snowflake[GuildScheduledEvent]]("guild_scheduled_event_id")

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    override def values: Seq[() => Any] = Seq(() => guildScheduledEventId, () => userId, () => guildId)
  }
  object GuildScheduledEventUserAdd extends DiscordObjectCompanion[GuildScheduledEventUserAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventUserAdd =
      new GuildScheduledEventUserAdd(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param guildId
      *   ID of the guild
      */
    def make20(
        guildScheduledEventId: Snowflake[GuildScheduledEvent],
        userId: UserId,
        guildId: GuildId
    ): GuildScheduledEventUserAdd =
      makeRawFromFields("guild_scheduled_event_id" := guildScheduledEventId, "user_id" := userId, "guild_id" := guildId)

  }

  /** Sent when a user has unsubscribed  to a guild scheduled event. */
  class GuildScheduledEventUserRemove(json: Json, cache: Map[String, Any] = Map.empty)
      extends DiscordObject(json, cache) {
    @inline def guildScheduledEventId: Snowflake[GuildScheduledEvent] =
      selectDynamic[Snowflake[GuildScheduledEvent]]("guild_scheduled_event_id")

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    override def values: Seq[() => Any] = Seq(() => guildScheduledEventId, () => userId, () => guildId)
  }
  object GuildScheduledEventUserRemove extends DiscordObjectCompanion[GuildScheduledEventUserRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): GuildScheduledEventUserRemove =
      new GuildScheduledEventUserRemove(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param guildId
      *   ID of the guild
      */
    def make20(
        guildScheduledEventId: Snowflake[GuildScheduledEvent],
        userId: UserId,
        guildId: GuildId
    ): GuildScheduledEventUserRemove =
      makeRawFromFields("guild_scheduled_event_id" := guildScheduledEventId, "user_id" := userId, "guild_id" := guildId)

  }

  /**
    * Sent when an integration is created. The inner payload is an integration
    * object with an additional guild_id key:
    */
  class IntegrationCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def integration: Integration = Integration.makeRaw(json, extensionCache("integration"))

    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    override def values: Seq[() => Any] = Seq(() => integration, () => guildId)
  }
  object IntegrationCreate extends DiscordObjectCompanion[IntegrationCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): IntegrationCreate = new IntegrationCreate(json, cache)

    def make20(integration: Integration, guildId: GuildId): IntegrationCreate =
      makeRawFromFields(DiscordObjectFrom.FromExtension("integration", integration), "guild_id" := guildId)

  }

  /**
    * Sent when an integration is updated. The inner payload is an integration
    * object with an additional guild_id key:
    */
  class IntegrationUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def integration: Integration = Integration.makeRaw(json, extensionCache("integration"))

    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    override def values: Seq[() => Any] = Seq(() => integration, () => guildId)
  }
  object IntegrationUpdate extends DiscordObjectCompanion[IntegrationUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): IntegrationUpdate = new IntegrationUpdate(json, cache)

    def make20(integration: Integration, guildId: GuildId): IntegrationUpdate =
      makeRawFromFields(DiscordObjectFrom.FromExtension("integration", integration), "guild_id" := guildId)

  }

  /** Sent when an integration is deleted. */
  class IntegrationDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Integration ID */
    @inline def id: Snowflake[Integration] = selectDynamic[Snowflake[Integration]]("id")

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** ID of the bot/OAuth2 application for this discord integration */
    @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

    override def values: Seq[() => Any] = Seq(() => id, () => guildId, () => applicationId)
  }
  object IntegrationDelete extends DiscordObjectCompanion[IntegrationDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): IntegrationDelete = new IntegrationDelete(json, cache)

    /**
      * @param id
      *   Integration ID
      * @param guildId
      *   ID of the guild
      * @param applicationId
      *   ID of the bot/OAuth2 application for this discord integration
      */
    def make20(
        id: Snowflake[Integration],
        guildId: GuildId,
        applicationId: UndefOr[ApplicationId] = UndefOrUndefined
    ): IntegrationDelete = makeRawFromFields("id" := id, "guild_id" := guildId, "application_id" :=? applicationId)

  }

  /** Sent when a new invite to a channel is created. */
  class InviteCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Channel the invite is for */
    @inline def channelId: GuildChannelId = selectDynamic[GuildChannelId]("channel_id")

    /** Unique invite code */
    @inline def code: String = selectDynamic[String]("code")

    /** Time at which the invite was created */
    @inline def createdAt: OffsetDateTime = selectDynamic[OffsetDateTime]("created_at")

    /** Guild of the invite */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** User that created the invite */
    @inline def inviter: UndefOr[User] = selectDynamic[UndefOr[User]]("inviter")

    /** How long the invite is valid for (in seconds) */
    @inline def maxAge: Int = selectDynamic[Int]("max_age")

    /** Maximum number of times the invite can be used */
    @inline def maxUses: Int = selectDynamic[Int]("max_uses")

    /** Type of target for this voice channel invite */
    @inline def targetType: UndefOr[Invite.InviteTargetType] =
      selectDynamic[UndefOr[Invite.InviteTargetType]]("target_type")

    /** User whose stream to display for this voice channel stream invite */
    @inline def targetUser: UndefOr[User] = selectDynamic[UndefOr[User]]("target_user")

    /**
      * Embedded application to open for this voice channel embedded application
      * invite
      */
    @inline def targetApplication: UndefOr[Invite.InviteApplication] =
      selectDynamic[UndefOr[Invite.InviteApplication]]("target_application")

    /**
      * Whether or not the invite is temporary (invited users will be kicked on
      * disconnect unless they're assigned a role)
      */
    @inline def temporary: Boolean = selectDynamic[Boolean]("temporary")

    /** How many times the invite has been used (always will be 0) */
    @inline def uses: Int = selectDynamic[Int]("uses")

    override def values: Seq[() => Any] = Seq(
      () => channelId,
      () => code,
      () => createdAt,
      () => guildId,
      () => inviter,
      () => maxAge,
      () => maxUses,
      () => targetType,
      () => targetUser,
      () => targetApplication,
      () => temporary,
      () => uses
    )
  }
  object InviteCreate extends DiscordObjectCompanion[InviteCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): InviteCreate = new InviteCreate(json, cache)

    /**
      * @param channelId
      *   Channel the invite is for
      * @param code
      *   Unique invite code
      * @param createdAt
      *   Time at which the invite was created
      * @param guildId
      *   Guild of the invite
      * @param inviter
      *   User that created the invite
      * @param maxAge
      *   How long the invite is valid for (in seconds)
      * @param maxUses
      *   Maximum number of times the invite can be used
      * @param targetType
      *   Type of target for this voice channel invite
      * @param targetUser
      *   User whose stream to display for this voice channel stream invite
      * @param targetApplication
      *   Embedded application to open for this voice channel embedded
      *   application invite
      * @param temporary
      *   Whether or not the invite is temporary (invited users will be kicked
      *   on disconnect unless they're assigned a role)
      * @param uses
      *   How many times the invite has been used (always will be 0)
      */
    def make20(
        channelId: GuildChannelId,
        code: String,
        createdAt: OffsetDateTime,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        inviter: UndefOr[User] = UndefOrUndefined,
        maxAge: Int,
        maxUses: Int,
        targetType: UndefOr[Invite.InviteTargetType] = UndefOrUndefined,
        targetUser: UndefOr[User] = UndefOrUndefined,
        targetApplication: UndefOr[Invite.InviteApplication] = UndefOrUndefined,
        temporary: Boolean,
        uses: Int
    ): InviteCreate = makeRawFromFields(
      "channel_id"          := channelId,
      "code"                := code,
      "created_at"          := createdAt,
      "guild_id"           :=? guildId,
      "inviter"            :=? inviter,
      "max_age"             := maxAge,
      "max_uses"            := maxUses,
      "target_type"        :=? targetType,
      "target_user"        :=? targetUser,
      "target_application" :=? targetApplication,
      "temporary"           := temporary,
      "uses"                := uses
    )

  }

  /** Sent when an invite is deleted. */
  class InviteDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Channel of the invite */
    @inline def channelId: GuildChannelId = selectDynamic[GuildChannelId]("channel_id")

    /** Guild of the invite */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** Unique invite code */
    @inline def code: String = selectDynamic[String]("code")

    override def values: Seq[() => Any] = Seq(() => channelId, () => guildId, () => code)
  }
  object InviteDelete extends DiscordObjectCompanion[InviteDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): InviteDelete = new InviteDelete(json, cache)

    /**
      * @param channelId
      *   Channel of the invite
      * @param guildId
      *   Guild of the invite
      * @param code
      *   Unique invite code
      */
    def make20(channelId: GuildChannelId, guildId: UndefOr[GuildId] = UndefOrUndefined, code: String): InviteDelete =
      makeRawFromFields("channel_id" := channelId, "guild_id" :=? guildId, "code" := code)

  }

  /**
    * Sent when a message is created. The inner payload is a message object with
    * the following extra fields:
    */
  class MessageCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def message: Message = Message.makeRaw(json, extensionCache("message"))

    /**
      * ID of the guild the message was sent in - unless it is an ephemeral
      * message
      */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /**
      * Member properties for this message's author. Missing for ephemeral
      * messages and messages from webhooks
      */
    @inline def member: UndefOr[MessageCreate.MessageCreateGuildMember] =
      selectDynamic[UndefOr[MessageCreate.MessageCreateGuildMember]]("member")

    /**
      * Users specifically mentioned in the message. Array of user objects, with
      * an additional partial member field
      */
    @inline def mentions: Seq[User] = selectDynamic[Seq[User]]("mentions")

    override def values: Seq[() => Any] = Seq(() => message, () => guildId, () => member, () => mentions)
  }
  object MessageCreate extends DiscordObjectCompanion[MessageCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageCreate = new MessageCreate(json, cache)

    /**
      * @param guildId
      *   ID of the guild the message was sent in - unless it is an ephemeral
      *   message
      * @param member
      *   Member properties for this message's author. Missing for ephemeral
      *   messages and messages from webhooks
      * @param mentions
      *   Users specifically mentioned in the message. Array of user objects,
      *   with an additional partial member field
      */
    def make20(
        message: Message,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        member: UndefOr[MessageCreate.MessageCreateGuildMember] = UndefOrUndefined,
        mentions: Seq[User]
    ): MessageCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("message", message),
      "guild_id" :=? guildId,
      "member"   :=? member,
      "mentions"  := mentions
    )

    class MessageCreateGuildMember(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object MessageCreateGuildMember extends DiscordObjectCompanion[MessageCreateGuildMember] {
      def makeRaw(json: Json, cache: Map[String, Any]): MessageCreateGuildMember =
        new MessageCreateGuildMember(json, cache)

      def make20(): MessageCreateGuildMember = makeRawFromFields()

    }
  }

  /**
    * Sent when a message is updated. The inner payload is a message object with
    * the same extra fields as MESSAGE_CREATE.
    */
  class MessageUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def message: Message.Partial = Message.Partial.makeRaw(json, extensionCache("message"))

    @inline def id: MessageId = selectDynamic[MessageId]("id")

    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /**
      * ID of the guild the message was sent in - unless it is an ephemeral
      * message
      */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /**
      * Member properties for this message's author. Missing for ephemeral
      * messages and messages from webhooks
      */
    @inline def member: UndefOr[MessageCreate.MessageCreateGuildMember] =
      selectDynamic[UndefOr[MessageCreate.MessageCreateGuildMember]]("member")

    /**
      * Users specifically mentioned in the message. Array of user objects, with
      * an additional partial member field
      */
    @inline def mentions: UndefOr[Seq[User]] = selectDynamic[UndefOr[Seq[User]]]("mentions")

    override def values: Seq[() => Any] =
      Seq(() => message, () => id, () => channelId, () => guildId, () => member, () => mentions)
  }
  object MessageUpdate extends DiscordObjectCompanion[MessageUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageUpdate = new MessageUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild the message was sent in - unless it is an ephemeral
      *   message
      * @param member
      *   Member properties for this message's author. Missing for ephemeral
      *   messages and messages from webhooks
      * @param mentions
      *   Users specifically mentioned in the message. Array of user objects,
      *   with an additional partial member field
      */
    def make20(
        message: Message.Partial,
        id: MessageId,
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        member: UndefOr[MessageCreate.MessageCreateGuildMember] = UndefOrUndefined,
        mentions: UndefOr[Seq[User]] = UndefOrUndefined
    ): MessageUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("message", message),
      "id"         := id,
      "channel_id" := channelId,
      "guild_id"  :=? guildId,
      "member"    :=? member,
      "mentions"  :=? mentions
    )

  }

  /** Sent when a message is deleted. */
  class MessageDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the message */
    @inline def id: MessageId = selectDynamic[MessageId]("id")

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    override def values: Seq[() => Any] = Seq(() => id, () => channelId, () => guildId)
  }
  object MessageDelete extends DiscordObjectCompanion[MessageDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageDelete = new MessageDelete(json, cache)

    /**
      * @param id
      *   ID of the message
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      */
    def make20(id: MessageId, channelId: TextChannelId, guildId: UndefOr[GuildId] = UndefOrUndefined): MessageDelete =
      makeRawFromFields("id" := id, "channel_id" := channelId, "guild_id" :=? guildId)

  }

  /** Sent when multiple messages are deleted at once. */
  class MessageDeleteBulk(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** IDs of the messages */
    @inline def ids: Seq[MessageId] = selectDynamic[Seq[MessageId]]("ids")

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    override def values: Seq[() => Any] = Seq(() => ids, () => channelId, () => guildId)
  }
  object MessageDeleteBulk extends DiscordObjectCompanion[MessageDeleteBulk] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageDeleteBulk = new MessageDeleteBulk(json, cache)

    /**
      * @param ids
      *   IDs of the messages
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      */
    def make20(
        ids: Seq[MessageId],
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined
    ): MessageDeleteBulk = makeRawFromFields("ids" := ids, "channel_id" := channelId, "guild_id" :=? guildId)

  }

  /** Sent when a user adds a reaction to a message. */
  class MessageReactionAdd(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** Member who reacted if this happened in a guild */
    @inline def member: UndefOr[GuildMember] = selectDynamic[UndefOr[GuildMember]]("member")

    /** Emoji used to react - example */
    @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

    /** ID of the user who authored the message which was reacted to */
    @inline def messageAuthorId: UndefOr[UserId] = selectDynamic[UndefOr[UserId]]("message_author_id")

    override def values: Seq[() => Any] = Seq(
      () => userId,
      () => channelId,
      () => messageId,
      () => guildId,
      () => member,
      () => emoji,
      () => messageAuthorId
    )
  }
  object MessageReactionAdd extends DiscordObjectCompanion[MessageReactionAdd] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionAdd = new MessageReactionAdd(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param channelId
      *   ID of the channel
      * @param messageId
      *   ID of the message
      * @param guildId
      *   ID of the guild
      * @param member
      *   Member who reacted if this happened in a guild
      * @param emoji
      *   Emoji used to react - example
      * @param messageAuthorId
      *   ID of the user who authored the message which was reacted to
      */
    def make20(
        userId: UserId,
        channelId: TextChannelId,
        messageId: MessageId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        member: UndefOr[GuildMember] = UndefOrUndefined,
        emoji: Emoji,
        messageAuthorId: UndefOr[UserId] = UndefOrUndefined
    ): MessageReactionAdd = makeRawFromFields(
      "user_id"            := userId,
      "channel_id"         := channelId,
      "message_id"         := messageId,
      "guild_id"          :=? guildId,
      "member"            :=? member,
      "emoji"              := emoji,
      "message_author_id" :=? messageAuthorId
    )

  }

  /** Sent when a user removes a reaction from a message. */
  class MessageReactionRemove(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** Emoji used to react - example */
    @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

    override def values: Seq[() => Any] =
      Seq(() => userId, () => channelId, () => messageId, () => guildId, () => emoji)
  }
  object MessageReactionRemove extends DiscordObjectCompanion[MessageReactionRemove] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionRemove = new MessageReactionRemove(json, cache)

    /**
      * @param userId
      *   ID of the user
      * @param channelId
      *   ID of the channel
      * @param messageId
      *   ID of the message
      * @param guildId
      *   ID of the guild
      * @param emoji
      *   Emoji used to react - example
      */
    def make20(
        userId: UserId,
        channelId: TextChannelId,
        messageId: MessageId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        emoji: Emoji
    ): MessageReactionRemove = makeRawFromFields(
      "user_id"    := userId,
      "channel_id" := channelId,
      "message_id" := messageId,
      "guild_id"  :=? guildId,
      "emoji"      := emoji
    )

  }

  /** Sent when a user explicitly removes all reactions from a message. */
  class MessageReactionRemoveAll(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    override def values: Seq[() => Any] = Seq(() => channelId, () => messageId, () => guildId)
  }
  object MessageReactionRemoveAll extends DiscordObjectCompanion[MessageReactionRemoveAll] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionRemoveAll =
      new MessageReactionRemoveAll(json, cache)

    /**
      * @param channelId
      *   ID of the channel
      * @param messageId
      *   ID of the message
      * @param guildId
      *   ID of the guild
      */
    def make20(
        channelId: TextChannelId,
        messageId: MessageId,
        guildId: UndefOr[GuildId] = UndefOrUndefined
    ): MessageReactionRemoveAll =
      makeRawFromFields("channel_id" := channelId, "message_id" := messageId, "guild_id" :=? guildId)

  }

  /**
    * Sent when a bot removes all instances of a given emoji from the reactions
    * of a message.
    */
  class MessageReactionRemoveEmoji(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** ID of the message */
    @inline def messageId: MessageId = selectDynamic[MessageId]("message_id")

    /** Emoji that was removed */
    @inline def emoji: Emoji = selectDynamic[Emoji]("emoji")

    override def values: Seq[() => Any] = Seq(() => channelId, () => guildId, () => messageId, () => emoji)
  }
  object MessageReactionRemoveEmoji extends DiscordObjectCompanion[MessageReactionRemoveEmoji] {
    def makeRaw(json: Json, cache: Map[String, Any]): MessageReactionRemoveEmoji =
      new MessageReactionRemoveEmoji(json, cache)

    /**
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      * @param messageId
      *   ID of the message
      * @param emoji
      *   Emoji that was removed
      */
    def make20(
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        messageId: MessageId,
        emoji: Emoji
    ): MessageReactionRemoveEmoji =
      makeRawFromFields("channel_id" := channelId, "guild_id" :=? guildId, "message_id" := messageId, "emoji" := emoji)

  }

  /**
    * A user's presence is their current state on a guild. This event is sent
    * when a user's presence or info, such as name or avatar, is updated.
    */
  class PresenceUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** User whose presence is being updated */
    @inline def user: User.Partial = User.Partial.makeRaw(json, extensionCache("user"))

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** Either "idle", "dnd", "online", or "offline" */
    @inline def status: UndefOr[Status] = selectDynamic[UndefOr[Status]]("status")

    /** User's current activities */
    @inline def activities: UndefOr[Seq[Activity]] = selectDynamic[UndefOr[Seq[Activity]]]("activities")

    /** User's platform-dependent status */
    @inline def clientStatus: UndefOr[PresenceUpdate.ClientStatus] =
      selectDynamic[UndefOr[PresenceUpdate.ClientStatus]]("client_status")

    override def values: Seq[() => Any] =
      Seq(() => user, () => guildId, () => status, () => activities, () => clientStatus)
  }
  object PresenceUpdate extends DiscordObjectCompanion[PresenceUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): PresenceUpdate = new PresenceUpdate(json, cache)

    /**
      * @param user
      *   User whose presence is being updated
      * @param guildId
      *   ID of the guild
      * @param status
      *   Either "idle", "dnd", "online", or "offline"
      * @param activities
      *   User's current activities
      * @param clientStatus
      *   User's platform-dependent status
      */
    def make20(
        user: User.Partial,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        status: UndefOr[Status] = UndefOrUndefined,
        activities: UndefOr[Seq[Activity]] = UndefOrUndefined,
        clientStatus: UndefOr[PresenceUpdate.ClientStatus] = UndefOrUndefined
    ): PresenceUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("user", user),
      "guild_id"      :=? guildId,
      "status"        :=? status,
      "activities"    :=? activities,
      "client_status" :=? clientStatus
    )

    /**
      * Active sessions are indicated with an "online", "idle", or "dnd" string
      * per platform. If a user is offline or invisible, the corresponding field
      * is not present.
      */
    class ClientStatus(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /**
        * User's status set for an active desktop (Windows, Linux, Mac)
        * application session
        */
      @inline def desktop: UndefOr[Status] = selectDynamic[UndefOr[Status]]("desktop")

      /**
        * User's status set for an active mobile (iOS, Android) application
        * session
        */
      @inline def mobile: UndefOr[Status] = selectDynamic[UndefOr[Status]]("mobile")

      /**
        * User's status set for an active web (browser, bot user) application
        * session
        */
      @inline def web: UndefOr[Status] = selectDynamic[UndefOr[Status]]("web")

      override def values: Seq[() => Any] = Seq(() => desktop, () => mobile, () => web)
    }
    object ClientStatus extends DiscordObjectCompanion[ClientStatus] {
      def makeRaw(json: Json, cache: Map[String, Any]): ClientStatus = new ClientStatus(json, cache)

      /**
        * @param desktop
        *   User's status set for an active desktop (Windows, Linux, Mac)
        *   application session
        * @param mobile
        *   User's status set for an active mobile (iOS, Android) application
        *   session
        * @param web
        *   User's status set for an active web (browser, bot user) application
        *   session
        */
      def make20(
          desktop: UndefOr[Status] = UndefOrUndefined,
          mobile: UndefOr[Status] = UndefOrUndefined,
          web: UndefOr[Status] = UndefOrUndefined
      ): ClientStatus = makeRawFromFields("desktop" :=? desktop, "mobile" :=? mobile, "web" :=? web)

    }
  }

  class Activity(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Activity's name */
    @inline def name: String = selectDynamic[String]("name")

    /** Activity type */
    @inline def tpe: Activity.ActivityType = selectDynamic[Activity.ActivityType]("type")

    /** Stream URL, is validated when type is 1 */
    @inline def url: JsonOption[String] = selectDynamic[JsonOption[String]]("url")

    /**
      * Unix timestamp (in milliseconds) of when the activity was added to the
      * user's session
      */
    @inline def createdAt: Int = selectDynamic[Int]("created_at")

    /** Unix timestamps for start and/or end of the game */
    @inline def timestamps: UndefOr[Activity.ActivityTimestamps] =
      selectDynamic[UndefOr[Activity.ActivityTimestamps]]("timestamps")

    /** Application ID for the game */
    @inline def applicationId: UndefOr[ApplicationId] = selectDynamic[UndefOr[ApplicationId]]("application_id")

    /** What the player is currently doing */
    @inline def details: JsonOption[String] = selectDynamic[JsonOption[String]]("details")

    /** User's current party status */
    @inline def state: JsonOption[String] = selectDynamic[JsonOption[String]]("state")

    /** Emoji used for a custom status */
    @inline def emoji: JsonOption[Activity.ActivityEmoji] = selectDynamic[JsonOption[Activity.ActivityEmoji]]("emoji")

    /** Information for the current party of the player */
    @inline def party: UndefOr[Activity.ActivityParty] = selectDynamic[UndefOr[Activity.ActivityParty]]("party")

    /** Images for the presence and their hover texts */
    @inline def assets: UndefOr[Activity.ActivityAssets] = selectDynamic[UndefOr[Activity.ActivityAssets]]("assets")

    /** Secrets for Rich Presence joining and spectating */
    @inline def secrets: UndefOr[Activity.ActivitySecrets] = selectDynamic[UndefOr[Activity.ActivitySecrets]]("secrets")

    /** Whether or not the activity is an instanced game session */
    @inline def instance: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("instance")

    /** Activity flags ORd together, describes what the payload includes */
    @inline def flags: UndefOr[Activity.ActivityFlags] = selectDynamic[UndefOr[Activity.ActivityFlags]]("flags")

    /** Custom buttons shown in the Rich Presence (max 2) */
    @inline def buttons: UndefOr[Seq[Activity.ActivityButtons]] =
      selectDynamic[UndefOr[Seq[Activity.ActivityButtons]]]("buttons")

    override def values: Seq[() => Any] = Seq(
      () => name,
      () => tpe,
      () => url,
      () => createdAt,
      () => timestamps,
      () => applicationId,
      () => details,
      () => state,
      () => emoji,
      () => party,
      () => assets,
      () => secrets,
      () => instance,
      () => flags,
      () => buttons
    )
  }
  object Activity extends DiscordObjectCompanion[Activity] {
    def makeRaw(json: Json, cache: Map[String, Any]): Activity = new Activity(json, cache)

    /**
      * @param name
      *   Activity's name
      * @param tpe
      *   Activity type
      * @param url
      *   Stream URL, is validated when type is 1
      * @param createdAt
      *   Unix timestamp (in milliseconds) of when the activity was added to the
      *   user's session
      * @param timestamps
      *   Unix timestamps for start and/or end of the game
      * @param applicationId
      *   Application ID for the game
      * @param details
      *   What the player is currently doing
      * @param state
      *   User's current party status
      * @param emoji
      *   Emoji used for a custom status
      * @param party
      *   Information for the current party of the player
      * @param assets
      *   Images for the presence and their hover texts
      * @param secrets
      *   Secrets for Rich Presence joining and spectating
      * @param instance
      *   Whether or not the activity is an instanced game session
      * @param flags
      *   Activity flags ORd together, describes what the payload includes
      * @param buttons
      *   Custom buttons shown in the Rich Presence (max 2)
      */
    def make20(
        name: String,
        tpe: Activity.ActivityType,
        url: JsonOption[String] = JsonUndefined,
        createdAt: Int,
        timestamps: UndefOr[Activity.ActivityTimestamps] = UndefOrUndefined,
        applicationId: UndefOr[ApplicationId] = UndefOrUndefined,
        details: JsonOption[String] = JsonUndefined,
        state: JsonOption[String] = JsonUndefined,
        emoji: JsonOption[Activity.ActivityEmoji] = JsonUndefined,
        party: UndefOr[Activity.ActivityParty] = UndefOrUndefined,
        assets: UndefOr[Activity.ActivityAssets] = UndefOrUndefined,
        secrets: UndefOr[Activity.ActivitySecrets] = UndefOrUndefined,
        instance: UndefOr[Boolean] = UndefOrUndefined,
        flags: UndefOr[Activity.ActivityFlags] = UndefOrUndefined,
        buttons: UndefOr[Seq[Activity.ActivityButtons]] = UndefOrUndefined
    ): Activity = makeRawFromFields(
      "name"            := name,
      "type"            := tpe,
      "url"            :=? url,
      "created_at"      := createdAt,
      "timestamps"     :=? timestamps,
      "application_id" :=? applicationId,
      "details"        :=? details,
      "state"          :=? state,
      "emoji"          :=? emoji,
      "party"          :=? party,
      "assets"         :=? assets,
      "secrets"        :=? secrets,
      "instance"       :=? instance,
      "flags"          :=? flags,
      "buttons"        :=? buttons
    )

    sealed case class ActivityType private (value: Int) extends DiscordEnum[Int]
    object ActivityType                                 extends DiscordEnumCompanion[Int, ActivityType] {

      /** Playing {name} */
      val Game: ActivityType = ActivityType(0)

      /** Streaming {details} */
      val Streaming: ActivityType = ActivityType(1)

      /** Listening to {name} */
      val Listening: ActivityType = ActivityType(2)

      /** Watching {name} */
      val Watching: ActivityType = ActivityType(3)

      /** {emoji} {name} */
      val Custom: ActivityType = ActivityType(4)

      /** Competing in {name} */
      val Competing: ActivityType = ActivityType(5)

      def unknown(value: Int): ActivityType = new ActivityType(value)

      def values: Seq[ActivityType] = Seq(Game, Streaming, Listening, Watching, Custom, Competing)

    }

    class ActivityTimestamps(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Unix time (in milliseconds) of when the activity started */
      @inline def start: UndefOr[Int] = selectDynamic[UndefOr[Int]]("start")

      /** Unix time (in milliseconds) of when the activity ends */
      @inline def end: UndefOr[Int] = selectDynamic[UndefOr[Int]]("end")

      override def values: Seq[() => Any] = Seq(() => start, () => end)
    }
    object ActivityTimestamps extends DiscordObjectCompanion[ActivityTimestamps] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityTimestamps = new ActivityTimestamps(json, cache)

      /**
        * @param start
        *   Unix time (in milliseconds) of when the activity started
        * @param end
        *   Unix time (in milliseconds) of when the activity ends
        */
      def make20(start: UndefOr[Int] = UndefOrUndefined, end: UndefOr[Int] = UndefOrUndefined): ActivityTimestamps =
        makeRawFromFields("start" :=? start, "end" :=? end)

    }

    class ActivityEmoji(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Name of the emoji */
      @inline def name: String = selectDynamic[String]("name")

      /** ID of the emoji */
      @inline def id: UndefOr[Snowflake[Emoji]] = selectDynamic[UndefOr[Snowflake[Emoji]]]("id")

      /** Whether the emoji is animated */
      @inline def animated: UndefOr[Boolean] = selectDynamic[UndefOr[Boolean]]("animated")

      override def values: Seq[() => Any] = Seq(() => name, () => id, () => animated)
    }
    object ActivityEmoji extends DiscordObjectCompanion[ActivityEmoji] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityEmoji = new ActivityEmoji(json, cache)

      /**
        * @param name
        *   Name of the emoji
        * @param id
        *   ID of the emoji
        * @param animated
        *   Whether the emoji is animated
        */
      def make20(
          name: String,
          id: UndefOr[Snowflake[Emoji]] = UndefOrUndefined,
          animated: UndefOr[Boolean] = UndefOrUndefined
      ): ActivityEmoji = makeRawFromFields("name" := name, "id" :=? id, "animated" :=? animated)

    }

    class ActivityParty(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** ID of the party */
      @inline def id: UndefOr[String] = selectDynamic[UndefOr[String]]("id")

      /**
        * Array of two integers (current_size, max_size). Used to show the
        * party's current and maximum size
        */
      @inline def size: UndefOr[Seq[Int]] = selectDynamic[UndefOr[Seq[Int]]]("size")

      override def values: Seq[() => Any] = Seq(() => id, () => size)
    }
    object ActivityParty extends DiscordObjectCompanion[ActivityParty] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityParty = new ActivityParty(json, cache)

      /**
        * @param id
        *   ID of the party
        * @param size
        *   Array of two integers (current_size, max_size). Used to show the
        *   party's current and maximum size
        */
      def make20(id: UndefOr[String] = UndefOrUndefined, size: UndefOr[Seq[Int]] = UndefOrUndefined): ActivityParty =
        makeRawFromFields("id" :=? id, "size" :=? size)

    }

    class ActivityAssets(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** See Activity Asset Image */
      @inline def largeImage: UndefOr[String] = selectDynamic[UndefOr[String]]("large_image")

      /** Text displayed when hovering over the large image of the activity */
      @inline def largeText: UndefOr[String] = selectDynamic[UndefOr[String]]("large_text")

      /** See Activity Asset Image */
      @inline def smallImage: UndefOr[String] = selectDynamic[UndefOr[String]]("small_image")

      /** Text displayed when hovering over the small image of the activity */
      @inline def smallText: UndefOr[String] = selectDynamic[UndefOr[String]]("small_text")

      override def values: Seq[() => Any] = Seq(() => largeImage, () => largeText, () => smallImage, () => smallText)
    }
    object ActivityAssets extends DiscordObjectCompanion[ActivityAssets] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityAssets = new ActivityAssets(json, cache)

      /**
        * @param largeImage
        *   See Activity Asset Image
        * @param largeText
        *   Text displayed when hovering over the large image of the activity
        * @param smallImage
        *   See Activity Asset Image
        * @param smallText
        *   Text displayed when hovering over the small image of the activity
        */
      def make20(
          largeImage: UndefOr[String] = UndefOrUndefined,
          largeText: UndefOr[String] = UndefOrUndefined,
          smallImage: UndefOr[String] = UndefOrUndefined,
          smallText: UndefOr[String] = UndefOrUndefined
      ): ActivityAssets = makeRawFromFields(
        "large_image" :=? largeImage,
        "large_text"  :=? largeText,
        "small_image" :=? smallImage,
        "small_text"  :=? smallText
      )

    }

    class ActivitySecrets(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      /** Secret for joining a party */
      @inline def join: UndefOr[String] = selectDynamic[UndefOr[String]]("join")

      /** Secret for spectating a game */
      @inline def spectate: UndefOr[String] = selectDynamic[UndefOr[String]]("spectate")

      /** Secret for a specific instanced match */
      @inline def matchSecret: UndefOr[String] = selectDynamic[UndefOr[String]]("match")

      override def values: Seq[() => Any] = Seq(() => join, () => spectate, () => matchSecret)
    }
    object ActivitySecrets extends DiscordObjectCompanion[ActivitySecrets] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivitySecrets = new ActivitySecrets(json, cache)

      /**
        * @param join
        *   Secret for joining a party
        * @param spectate
        *   Secret for spectating a game
        * @param matchSecret
        *   Secret for a specific instanced match
        */
      def make20(
          join: UndefOr[String] = UndefOrUndefined,
          spectate: UndefOr[String] = UndefOrUndefined,
          matchSecret: UndefOr[String] = UndefOrUndefined
      ): ActivitySecrets = makeRawFromFields("join" :=? join, "spectate" :=? spectate, "match" :=? matchSecret)

    }

    sealed case class ActivityFlags private (value: Int) extends DiscordEnum[Int]
    object ActivityFlags                                 extends DiscordEnumCompanion[Int, ActivityFlags] {

      /** 1 << 0 */
      val INSTANCE: ActivityFlags = ActivityFlags(1 << 0)

      /** 1 << 1 */
      val JOIN: ActivityFlags = ActivityFlags(1 << 1)

      /** 1 << 2 */
      val SPECTATE: ActivityFlags = ActivityFlags(1 << 2)

      /** 1 << 3 */
      val JOIN_REQUEST: ActivityFlags = ActivityFlags(1 << 3)

      /** 1 << 4 */
      val SYNC: ActivityFlags = ActivityFlags(1 << 4)

      /** 1 << 5 */
      val PLAY: ActivityFlags = ActivityFlags(1 << 5)

      /** 1 << 6 */
      val PARTY_PRIVACY_FRIENDS: ActivityFlags = ActivityFlags(1 << 6)

      /** 1 << 7 */
      val PARTY_PRIVACY_VOICE_CHANNEL: ActivityFlags = ActivityFlags(1 << 7)

      /** 1 << 8 */
      val EMBEDDED: ActivityFlags = ActivityFlags(1 << 8)

      def unknown(value: Int): ActivityFlags = new ActivityFlags(value)

      def values: Seq[ActivityFlags] = Seq(
        INSTANCE,
        JOIN,
        SPECTATE,
        JOIN_REQUEST,
        SYNC,
        PLAY,
        PARTY_PRIVACY_FRIENDS,
        PARTY_PRIVACY_VOICE_CHANNEL,
        EMBEDDED
      )

    }

    /**
      * When received over the gateway, the buttons field is an array of
      * strings, which are the button labels. Bots cannot access a user's
      * activity button URLs. When sending, the buttons field must be an array
      * of the below object:
      */
    class ActivityButtons(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

      override def values: Seq[() => Any] = Seq()
    }
    object ActivityButtons extends DiscordObjectCompanion[ActivityButtons] {
      def makeRaw(json: Json, cache: Map[String, Any]): ActivityButtons = new ActivityButtons(json, cache)

      def make20(): ActivityButtons = makeRawFromFields()

    }
  }

  /** Sent when a user starts typing in a channel. */
  class TypingStart(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the channel */
    @inline def channelId: TextChannelId = selectDynamic[TextChannelId]("channel_id")

    /** ID of the guild */
    @inline def guildId: UndefOr[GuildId] = selectDynamic[UndefOr[GuildId]]("guild_id")

    /** ID of the user */
    @inline def userId: UserId = selectDynamic[UserId]("user_id")

    /** Unix time (in seconds) of when the user started typing */
    @inline def timestamp: Int = selectDynamic[Int]("timestamp")

    /** Member who started typing if this happened in a guild */
    @inline def member: UndefOr[GuildMember] = selectDynamic[UndefOr[GuildMember]]("member")

    override def values: Seq[() => Any] =
      Seq(() => channelId, () => guildId, () => userId, () => timestamp, () => member)
  }
  object TypingStart extends DiscordObjectCompanion[TypingStart] {
    def makeRaw(json: Json, cache: Map[String, Any]): TypingStart = new TypingStart(json, cache)

    /**
      * @param channelId
      *   ID of the channel
      * @param guildId
      *   ID of the guild
      * @param userId
      *   ID of the user
      * @param timestamp
      *   Unix time (in seconds) of when the user started typing
      * @param member
      *   Member who started typing if this happened in a guild
      */
    def make20(
        channelId: TextChannelId,
        guildId: UndefOr[GuildId] = UndefOrUndefined,
        userId: UserId,
        timestamp: Int,
        member: UndefOr[GuildMember] = UndefOrUndefined
    ): TypingStart = makeRawFromFields(
      "channel_id" := channelId,
      "guild_id"  :=? guildId,
      "user_id"    := userId,
      "timestamp"  := timestamp,
      "member"    :=? member
    )

  }

  /**
    * Sent when properties about the current bot's user change. Inner payload is
    * a user object.
    */
  class UserUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def user: User = User.makeRaw(json, extensionCache("user"))

    override def values: Seq[() => Any] = Seq(() => user)
  }
  object UserUpdate extends DiscordObjectCompanion[UserUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): UserUpdate = new UserUpdate(json, cache)

    def make20(user: User): UserUpdate = makeRawFromFields(DiscordObjectFrom.FromExtension("user", user))

  }

  /**
    * Sent when someone joins/leaves/moves voice channels. Inner payload is a
    * voice state object.
    */
  class VoiceStateUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def voiceState: VoiceState = VoiceState.makeRaw(json, extensionCache("voice_state"))

    override def values: Seq[() => Any] = Seq(() => voiceState)
  }
  object VoiceStateUpdate extends DiscordObjectCompanion[VoiceStateUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): VoiceStateUpdate = new VoiceStateUpdate(json, cache)

    def make20(voiceState: VoiceState): VoiceStateUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("voice_state", voiceState)
    )

  }

  /**
    * Sent when a guild's voice server is updated. This is sent when initially
    * connecting to voice, and when the current voice instance fails over to a
    * new server.
    */
  class VoiceServerUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** Voice connection token */
    @inline def token: String = selectDynamic[String]("token")

    /** Guild this voice server update is for */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** Voice server host */
    @inline def endpoint: Option[String] = selectDynamic[Option[String]]("endpoint")

    override def values: Seq[() => Any] = Seq(() => token, () => guildId, () => endpoint)
  }
  object VoiceServerUpdate extends DiscordObjectCompanion[VoiceServerUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): VoiceServerUpdate = new VoiceServerUpdate(json, cache)

    /**
      * @param token
      *   Voice connection token
      * @param guildId
      *   Guild this voice server update is for
      * @param endpoint
      *   Voice server host
      */
    def make20(token: String, guildId: GuildId, endpoint: Option[String]): VoiceServerUpdate =
      makeRawFromFields("token" := token, "guild_id" := guildId, "endpoint" := endpoint)

  }

  /** Sent when a guild channel's webhook is created, updated, or deleted. */
  class WebhooksUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    /** ID of the guild */
    @inline def guildId: GuildId = selectDynamic[GuildId]("guild_id")

    /** ID of the channel */
    @inline def channelId: GuildChannelId = selectDynamic[GuildChannelId]("channel_id")

    override def values: Seq[() => Any] = Seq(() => guildId, () => channelId)
  }
  object WebhooksUpdate extends DiscordObjectCompanion[WebhooksUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): WebhooksUpdate = new WebhooksUpdate(json, cache)

    /**
      * @param guildId
      *   ID of the guild
      * @param channelId
      *   ID of the channel
      */
    def make20(guildId: GuildId, channelId: GuildChannelId): WebhooksUpdate =
      makeRawFromFields("guild_id" := guildId, "channel_id" := channelId)

  }

  /**
    * Sent when a user uses an Application Command or Message Component. Inner
    * payload is an Interaction. This is intentionally a stub. A proper type can
    * be found in the interactions module.
    */
  class InteractionCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {

    override def values: Seq[() => Any] = Seq()
  }
  object InteractionCreate extends DiscordObjectCompanion[InteractionCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): InteractionCreate = new InteractionCreate(json, cache)

    def make20(): InteractionCreate = makeRawFromFields()

  }

  /**
    * Sent when a Stage instance is created (i.e. the Stage is now "live").
    * Inner payload is a Stage instance
    */
  class StageInstanceCreate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def stageInstance: StageInstance = StageInstance.makeRaw(json, extensionCache("stage_instance"))

    override def values: Seq[() => Any] = Seq(() => stageInstance)
  }
  object StageInstanceCreate extends DiscordObjectCompanion[StageInstanceCreate] {
    def makeRaw(json: Json, cache: Map[String, Any]): StageInstanceCreate = new StageInstanceCreate(json, cache)

    def make20(stageInstance: StageInstance): StageInstanceCreate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("stage_instance", stageInstance)
    )

  }

  /**
    * Sent when a Stage instance has been updated. Inner payload is a Stage
    * instance
    */
  class StageInstanceUpdate(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def stageInstance: StageInstance = StageInstance.makeRaw(json, extensionCache("stage_instance"))

    override def values: Seq[() => Any] = Seq(() => stageInstance)
  }
  object StageInstanceUpdate extends DiscordObjectCompanion[StageInstanceUpdate] {
    def makeRaw(json: Json, cache: Map[String, Any]): StageInstanceUpdate = new StageInstanceUpdate(json, cache)

    def make20(stageInstance: StageInstance): StageInstanceUpdate = makeRawFromFields(
      DiscordObjectFrom.FromExtension("stage_instance", stageInstance)
    )

  }

  /**
    * Sent when a Stage instance has been deleted (i.e. the Stage has been
    * closed). Inner payload is a Stage instance
    */
  class StageInstanceDelete(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) {
    @inline def stageInstance: StageInstance = StageInstance.makeRaw(json, extensionCache("stage_instance"))

    override def values: Seq[() => Any] = Seq(() => stageInstance)
  }
  object StageInstanceDelete extends DiscordObjectCompanion[StageInstanceDelete] {
    def makeRaw(json: Json, cache: Map[String, Any]): StageInstanceDelete = new StageInstanceDelete(json, cache)

    def make20(stageInstance: StageInstance): StageInstanceDelete = makeRawFromFields(
      DiscordObjectFrom.FromExtension("stage_instance", stageInstance)
    )

  }
}
