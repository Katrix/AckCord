import java.nio.file.{Files, Path}

import scala.collection.JavaConverters._

import CodeGenTypes._
import io.circe._

object AckCordCodeGen {

  def generateCodeFromFile(generatedRoot: Path, yamlFile: Path): String = {
    val relativeYamlPath = generatedRoot.relativize(yamlFile).iterator.asScala.map(_.toString).toList.init

    val typeDef =
      yaml.parser.parse(Files.readAllLines(yamlFile).asScala.mkString("\n")).flatMap(_.as[TypeDef]).toTry.get

    val packagePath = relativeYamlPath.mkString(".")
    val packageLine = s"//noinspection ScalaWeakerAccess, ScalaUnusedSymbol, DuplicatedCode\npackage $packagePath"
    val disclaimer =
      s"""// THIS FILE IS MACHINE GENERATED!
         |//
         |// Do not edit this file directly.
         |// Instead, edit the file generated/${relativeYamlPath.mkString("/")}/${yamlFile.getFileName.toString}
         |""".stripMargin

    val code            = codeFromTypeDef(typeDef, extraImports = Seq("io.circe.Json", "ackcord.data.base._"))
    val codeWithPackage = packageLine :: disclaimer :: code

    codeWithPackage.mkString("\n\n")
  }

  def codeFromTypeDef(typeDef: TypeDef, extraImports: Seq[String] = Nil): List[String] = {
    val imports = (extraImports ++ typeDef.imports).map(s => s"import $s")

    val res = typeDef match {
      case classTypeDef: TypeDef.ClassTypeDef   => List(codeFromClassTypeDef(classTypeDef))
      case enumTypeDef: TypeDef.EnumTypeDef     => List(codeFromEnumTypeDef(enumTypeDef))
      case opaqueTypeDef: TypeDef.OpaqueTypeDef => List(codeFromOpaqueTypeDef(opaqueTypeDef))
      case requestDef: TypeDef.RequestDef       => codeFromRequestDef(requestDef)
      case multiple: TypeDef.MultipleDefs       => multiple.innerTypes.toList.flatMap(codeFromTypeDef(_))
      case objectOnly: TypeDef.ObjectOnlyDef    => List(codeFromObjectOnly(objectOnly))
      case freeform: TypeDef.FreeformDef        => List(codeFromFreeform(freeform))
    }

    imports.mkString("\n") :: res
  }

  def camelCase(s: String): String = {
    val arr = s.split("_")
    arr.head + arr.iterator.drop(1).map(_.capitalize).mkString
  }

  def docString(s: String, extra: Seq[String] = Nil): String = {
    val lines         = s.linesIterator.toList
    val linesWithStar = if (lines.size <= 1) lines.mkString else lines.map("* " + _).mkString("\n")
    val extraWithStar = extra.map("*" + _).mkString("\n")
    s"/** $linesWithStar\n$extraWithStar\n */"
  }

  case class FieldWithType(field: FieldDef, tpe: String)
  case class FieldWithTypeVersionAndName(field: FieldDef, tpe: String, version: Int, name: String)

  def codeFromClassTypeDef(classTypeDef: TypeDef.ClassTypeDef): String = {
    val tpeName      = classTypeDef.name
    val allUndefined = classTypeDef.anonPart.allUndefined

    val fieldsWithTypes = classTypeDef.anonPart.fields.map { case (version, fields) =>
      version -> fields.map { case (name, field) =>
        val fieldType = (allUndefined || field.withUndefined, field.withNull) match {
          case (true, true)   => s"JsonOption[${field.tpe}]"
          case (true, false)  => s"UndefOr[${field.tpe}]"
          case (false, true)  => s"Option[${field.tpe}]"
          case (false, false) => field.tpe
        }

        name -> FieldWithType(field, fieldType)
      }
    }

    val makeRaw =
      if (classTypeDef.anonPart.customMakeRaw) ""
      else s"def makeRaw(json: Json, cache: Map[String, Any]): $tpeName = new $tpeName(json, cache)"

    val makeDefs = fieldsWithTypes.map { case (version, fields) =>
      val defName = s"make${version.replace("x", "").replace(".", "")}"

      val params = fields.map { case (field, FieldWithType(fieldInfo, tpe)) =>
        val undef       = allUndefined || fieldInfo.withUndefined
        val realDefault = if (undef) fieldInfo.default.orElse(Some("undefined")) else fieldInfo.default

        val defaultStr = realDefault.fold("") { s =>
          (s, undef, fieldInfo.withNull) match {
            case ("null", true, true)       => "= JsonNull"
            case ("undefined", true, true)  => "= JsonUndefined"
            case ("null", false, true)      => "= None"
            case ("undefined", true, false) => "= UndefOrUndefined"
            case (d, true, true)            => s"= JsonSome($d)"
            case (d, false, true)           => s"= Some($d)"
            case (d, true, false)           => s"= UndefOrSome($d)"
            case (d, false, false)          => s"= $d"
          }
        }
        s"${camelCase(field)}: $tpe$defaultStr"
      }

      val args = fields.map { case (field, FieldWithType(fieldInfo, _)) =>
        val jsonName = fieldInfo.jsonName.getOrElse(field)
        val fieldLit = "\"" + jsonName + "\""
        if (fieldInfo.isExtension) {
          s"DiscordObjectFrom.FromExtension($fieldLit, ${camelCase(field)})"
        } else {
          if (fieldInfo.withUndefined || allUndefined) s"$fieldLit :=? ${camelCase(field)}"
          else s"$fieldLit := ${camelCase(field)}"
        }
      }

      val fieldDocs = fields.collect {
        case (name, FieldWithType(f, _)) if f.documentation.isDefined =>
          s"@param ${camelCase(name)} ${f.documentation.get}"
      }.toSeq

      val docs = if (fieldDocs.nonEmpty) docString("", fieldDocs) else ""

      s"$docs def $defName(${params.mkString(", ")}): $tpeName = makeRawFromFields(${args.mkString(", ")})"
    }

    val allClassFields = fieldsWithTypes.toSeq.flatMap { case (version, fields) =>
      val intVersion = version.replace("x", "").replace(".", "").toInt
      fields.map(field => FieldWithTypeVersionAndName(field._2.field, field._2.tpe, intVersion, field._1))
    }
    val highestVersionAll = fieldsWithTypes.keys.map(s => s.replace("x", "").replace(".", "").toInt).max

    val groupedClassFields = allClassFields.zipWithIndex
      .groupBy(_._1.name)
      .map { case (name, fields) =>
        val (field, idx) = fields.maxBy(_._1.version)
        name -> (field, idx)
      }
      .toSeq
      .sortBy(_._2._2)
      .map { case (_, v) => v._1 }

    val classDefs = groupedClassFields.map { case FieldWithTypeVersionAndName(fieldDef, tpe, highestVersion, name) =>
      val mods = {
        val base =
          if (highestVersion < highestVersionAll)
            List(
              "@inline",
              s"""@deprecated(message = "Value might be missing", since = "${highestVersionAll.toString}")""",
              s"private[ackcord]"
            )
          else List("@inline")

        if (fieldDef.overrides) base :+ "override" else base
      }

      val jsonName = fieldDef.jsonName.getOrElse(name)

      val defBody =
        if (fieldDef.isExtension) s"""$tpe.makeRaw(json, extensionCache("$jsonName"))"""
        else s"""selectDynamic[$tpe]("$jsonName")"""
      val defdef = s"""${mods.mkString(" ")} def ${camelCase(name)}: $tpe = $defBody"""

      (fieldDef.documentation.map(docString(_)).toList :+ defdef).mkString("\n")
    }

    val values = groupedClassFields.map(t => s"() => ${camelCase(t.name)}").mkString(", ")

    val withs    = classTypeDef.anonPart.`extends`.map(w => s"with $w").mkString(" ")
    val objWiths = classTypeDef.anonPart.objectExtends.map(w => s"with $w").mkString(" ")

    val tpeCode =
      s"""|class $tpeName(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) $withs {
          |   ${classDefs.mkString("\n\n")}
          |
          |   override def values: Seq[() => Any] = Seq($values)
          |}
          |object ${classTypeDef.name} extends DiscordObjectCompanion[$tpeName] $objWiths {
          |  $makeRaw
          |
          |  ${makeDefs.mkString("\n\n")}
          |
          |  ${classTypeDef.anonPart.innerTypes.flatMap(codeFromTypeDef(_)).mkString("\n\n")}
          |}""".stripMargin

    (classTypeDef.anonPart.documentation.map(docString(_)).toList :+ tpeCode).mkString("\n")
  }

  def codeFromObjectOnly(objectOnlyDef: TypeDef.ObjectOnlyDef): String = {
    val extend =
      if (objectOnlyDef.objectExtends.nonEmpty) "extends " + objectOnlyDef.objectExtends.mkString(" with ") else ""
    s"""|object ${objectOnlyDef.name} $extend {
        |  ${objectOnlyDef.innerTypes.flatMap(codeFromTypeDef(_)).mkString("\n\n")}
        |}""".stripMargin
  }

  def codeFromFreeform(freeformDef: CodeGenTypes.TypeDef.FreeformDef): String =
    (freeformDef.documentation.map(docString(_)).toList :+ freeformDef.content).mkString("\n")

  def codeFromEnumTypeDef(enumTypeDef: TypeDef.EnumTypeDef): String = {
    val tpeName = enumTypeDef.name

    val underlyingType = enumTypeDef.tpe

    def wrap(value: String): String = underlyingType match {
      case "String" => "\"" + value + "\""
      case _        => value
    }

    val values = enumTypeDef.values
      .map { case (name, value) =>
        (value.documentation.map(docString(_)).toList :+ s"val $name: $tpeName = $tpeName(${wrap(value.value)})")
          .mkString("\n")
      }
      .mkString("\n  ")

    val objWiths = enumTypeDef.objectExtends.map(w => s"with $w").mkString(" ")

    val bitfieldMembers = if (enumTypeDef.name == "BitfieldIntEnum") {

      List(
        s"""|implicit class ${tpeName}BitFieldOps(private val here: $tpeName) extends AnyVal {
            |  def to$underlyingType: $underlyingType = here.value
            |
            |  def ++(there: $tpeName): $tpeName = $tpeName(here.value | there.value)
            |
            |  def --(there: $tpeName): $tpeName = $tpeName(here.value & ~there.value)
            |
            |  def isNone: Boolean = here.value == 0
            |}""".stripMargin
      )

    } else Nil

    val tpeCode =
      s"""|sealed case class $tpeName private(value: $underlyingType) extends DiscordEnum[$underlyingType]
          |object $tpeName extends DiscordEnumCompanion[$underlyingType, $tpeName] $objWiths {
          |
          |  $values
          |  
          |  def unknown(value: $underlyingType): $tpeName = new $tpeName(value)
          |  
          |  def values: Seq[$tpeName] = Seq(${enumTypeDef.values.keys.mkString(", ")})
          |  
          |  ${(bitfieldMembers ++ enumTypeDef.innerTypes.flatMap(codeFromTypeDef(_))).mkString("\n\n")}
          |}""".stripMargin

    (enumTypeDef.documentation.map(docString(_)).toList :+ tpeCode).mkString("\n")
  }

  def codeFromOpaqueTypeDef(opaqueTypeDef: TypeDef.OpaqueTypeDef): String = {
    val tpeName = opaqueTypeDef.name

    val aliasCode = s"type $tpeName = $tpeName.$tpeName" + "\n"

    val objWiths = opaqueTypeDef.objectExtends.map(w => s"with $w").mkString(" ")

    val companionCode =
      s"""|object $tpeName extends DiscordOpaqueCompanion[${opaqueTypeDef.underlying}] $objWiths {
          |  type $tpeName = OpaqueType
          |
          |  ${opaqueTypeDef.innerTypes.flatMap(codeFromTypeDef(_)).mkString("\n\n")}
          |}""".stripMargin

    val tpeCode = if (opaqueTypeDef.includeAlias) aliasCode + companionCode else companionCode

    (opaqueTypeDef.documentation.map(docString(_)).toList :+ tpeCode).mkString("\n")
  }

  def knownArgPathElemToCustom(elem: PathElem.ArgPathElem): PathElem.CustomArgPathElem = {
    def custom(tpe: String, name: Option[String] = None, majorParameter: Boolean = false) =
      PathElem.CustomArgPathElem(
        elem.name.orElse(name).getOrElse(tpe.charAt(0).toLower.toString + tpe.substring(1)),
        tpe,
        majorParameter,
        elem.documentation
      )

    val allowedNormal = Set(
      "GuildId",
      "ChannelId",
      "ApplicationId",
      "CommandId",
      "EmojiId",
      "MessageId",
      "UserId",
      "Emoji",
      "RoleId",
      "WebhookId"
    )

    elem.argOf match {
      case "webhookToken"                 => custom("String", Some("webhookToken"))
      case s if allowedNormal.contains(s) => custom(s)
      case _ =>
        sys.error(s"Unknown path arg element ${elem.argOf}")
    }
  }

  def codeFromRequestDef(requestDef: TypeDef.RequestDef): List[String] = {
    val uncapitalizedName = requestDef.name.charAt(0).toLower.toString + requestDef.name.substring(1)
    val capitalizedName   = uncapitalizedName.capitalize
    val queryClass = requestDef.query.fold("")(q => codeFromClassTypeDef(q.named(capitalizedName + "Query")) + "\n")
    val bodyClass = requestDef.body.fold("") {
      case AnonymousClassTypeDefOrType.TypeRef(_) => ""
      case AnonymousClassTypeDefOrType.AnonType(anon) =>
        codeFromClassTypeDef(anon.named(capitalizedName + "Body")) + "\n"
    }
    val returnClass = requestDef.returnTpe.fold("") {
      case AnonymousClassTypeDefOrType.TypeRef(_) => ""
      case AnonymousClassTypeDefOrType.AnonType(anon) =>
        codeFromClassTypeDef(anon.named(capitalizedName + "Result")) + "\n"
    }

    val allCustomPathElems = requestDef.path.map {
      case argPathElem: PathElem.ArgPathElem => knownArgPathElemToCustom(argPathElem)
      case other                             => other
    }

    val pathParamNames = allCustomPathElems.collect { case PathElem.CustomArgPathElem(name, _, _, _) =>
      name
    }

    val duplicatePathParamNames = pathParamNames.collect {
      case name if pathParamNames.count(_ == name) > 1 => name
    }
    require(
      duplicatePathParamNames.isEmpty,
      s"Found duplicated name for request ${requestDef.name}. Duplicated: ${duplicatePathParamNames.mkString(", ")}"
    )

    val pathDocs = allCustomPathElems.collect { case PathElem.CustomArgPathElem(name, _, _, Some(documentation)) =>
      s"@param $name $documentation"
    }

    val typeParams =
      if (requestDef.additionalTypeParams.nonEmpty) requestDef.additionalTypeParams.mkString("[", ", ", "]") else ""

    val pathParams = allCustomPathElems
      .collect { case PathElem.CustomArgPathElem(name, tpe, _, _) =>
        s"$name: $tpe, "
      }
      .mkString("\n")

    val queryParam =
      if (requestDef.query.isDefined) {
        val highestVersion = requestDef.query.get.fields.keys.map(_.replace(".", "").replace("x", "").toInt).max
        val queryDefault =
          if (requestDef.query.get.allUndefined) s"= ${capitalizedName}Query.make$highestVersion()" else ""
        s"query: ${capitalizedName}Query$queryDefault, "
      } else ""

    val paramsType = {
      val tpe = requestDef.body.fold("Unit") {
        case AnonymousClassTypeDefOrType.TypeRef(name) => name
        case AnonymousClassTypeDefOrType.AnonType(_)   => s"${capitalizedName}Body"
      }
      if (requestDef.arrayOfBody) s"Seq[$tpe]" else tpe
    }

    val bodyParam   = requestDef.body.fold("")(_ => s"body: $paramsType,")
    val reasonParam = if (requestDef.allowsReason) "reason: Option[String]," else ""
    val additionalParams =
      requestDef.additionalParams
        .map(t => s"${t._1}: ${t._2.tpe}${t._2.default.fold("")(d => s" = $d")},")
        .mkString("\n")

    val returnTpe = {
      val tpe = requestDef.returnTpe.fold("Unit") {
        case AnonymousClassTypeDefOrType.TypeRef(name)  => name
        case AnonymousClassTypeDefOrType.AnonType(anon) => s"${capitalizedName}Result"
      }
      if (requestDef.arrayOfReturn) s"Seq[$tpe]" else tpe
    }

    val requestType =
      if (requestDef.complexType.isEmpty) s"Request[$paramsType, $returnTpe]"
      else s"ComplexRequest[$paramsType, $returnTpe, ${requestDef.complexType.r1}, ${requestDef.complexType.r2}]"

    val pathArg = requestDef.path
      .foldLeft(("", true)) { case ((acc, firstArg), arg) =>
        def handleCustom(custom: PathElem.CustomArgPathElem): (String, Boolean) = {
          val name       = custom.name
          val majorTypes = Set("GuildId", "ChannelId", "WebhookId")
          val major =
            if (custom.major || (majorTypes.contains(custom.tpe) && firstArg)) ", major = true" else ""
          (s"""/ Parameters[${custom.tpe}]("$name", $name$major)""", false)
        }

        arg match {
          case PathElem.StringPathElem(elem)      => (s"""/ "$elem"""", firstArg)
          case arg: PathElem.ArgPathElem          => handleCustom(knownArgPathElemToCustom(arg))
          case custom: PathElem.CustomArgPathElem => handleCustom(custom)
        }
      }
      ._1

    val queryArg = requestDef.query.filter(_.fields.nonEmpty).fold("") { q =>
      val highestVersion = q.fields.keys.maxBy(_.replace(".", "").replace("x", "").toInt)
      q
        .fields(highestVersion)
        .map { case (k, v) =>
          val queryParam =
            if (q.allUndefined || v.withUndefined) s"""Parameters.query("$k", query.${camelCase(k)})"""
            else s"""Parameters.queryAlways("$k", query.${camelCase(k)})"""

          s" +? $queryParam"
        }
        .mkString
    }

    val pathArgWithQuery = s"Route.Empty $pathArg$queryArg"

    val extraHeaders =
      if (requestDef.allowsReason)
        """extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r)),"""
      else ""

    val hasParams     = Seq(pathParams, queryParam, bodyParam, reasonParam, additionalParams).exists(_.nonEmpty)
    val hasTypeParams = typeParams.nonEmpty

    val defDocs  = requestDef.documentation.fold("")(docString(_, pathDocs) + "\n")
    val valOrDef = if (!hasParams && !hasTypeParams) "val" else "def"
    val params =
      if (hasParams)
        s"""|(
            |  $pathParams
            |  $queryParam
            |  $bodyParam
            |  $reasonParam
            |  $additionalParams
            |)""".stripMargin
      else ""

    val requestDefDef =
      s"""|$defDocs $valOrDef $uncapitalizedName$typeParams$params: $requestType =
          |  Request.${if (requestDef.complexType.isEmpty) "restRequest" else "complexRestRequest"}(
          |    route = ($pathArgWithQuery).toRequest(Method.${requestDef.method}),
          |    ${if (bodyParam.nonEmpty) "params = body," else ""}
          |    $extraHeaders
          |    ${requestDef.encodeBody.fold("")(e => s"requestBody = Some($e),")}
          |    ${requestDef.parseResponse.fold("")(r => s"parseResponse = Some($r),")}
          |  )
          |""".stripMargin

    List(queryClass, bodyClass, returnClass, requestDefDef).filter(_.nonEmpty)
  }
}
