import java.nio.file.{Files, Path}

import scala.collection.JavaConverters._

import CodeGenTypes._
import io.circe._

object AckCordCodeGen {

  def generateCodeFromFile(generatedRoot: Path, yamlFile: Path): String = {
    val relativeYamlPath = generatedRoot.relativize(yamlFile).iterator.asScala.map(_.toString).toList.init

    val typeDef =
      yaml.parser.parse(Files.readAllLines(yamlFile).asScala.mkString("\n")).flatMap(_.as[TypeDef]).toTry.get

    val packagePath = relativeYamlPath.mkString(".")
    val packageLine = s"package $packagePath"
    val disclaimer =
      s"""// THIS FILE IS MACHINE GENERATED!
         |//
         |// Do not edit this file directly.
         |// Instead, edit the file ${relativeYamlPath.mkString("/")}/${yamlFile.getFileName.toString}
         |""".stripMargin

    val code            = codeFromTypeDef(typeDef)
    val codeWithPackage = packageLine :: disclaimer :: code

    codeWithPackage.mkString("\n\n")
  }

  def codeFromTypeDef(typeDef: TypeDef): List[String] = {
    val imports = typeDef.imports.map(s => s"import $s")

    val res = typeDef match {
      case classTypeDef: TypeDef.ClassTypeDef   => List(codeFromClassTypeDef(classTypeDef))
      case enumTypeDef: TypeDef.EnumTypeDef     => List(codeFromEnumTypeDef(enumTypeDef))
      case opaqueTypeDef: TypeDef.OpaqueTypeDef => List(codeFromOpaqueTypeDef(opaqueTypeDef))
      case requestDef: TypeDef.RequestDef       => codeFromRequestDef(requestDef)
      case multiple: TypeDef.MultipleDefs       => multiple.innerTypes.toList.flatMap(codeFromTypeDef)
      case objectOnly: TypeDef.ObjectOnlyDef    => List(codeFromObjectOnly(objectOnly))
      case freeform: TypeDef.FreeformDef        => List(codeFromFreeform(freeform))
    }

    imports.mkString("\n") :: res
  }

  def camelCase(s: String): String = {
    val arr = s.split("_")
    arr.head + arr.iterator.drop(1).map(_.capitalize).mkString
  }

  def docString(s: String, extra: Seq[String] = Nil): String = {
    val lines         = s.linesIterator.toList
    val linesWithStar = if (lines.size <= 1) lines.mkString else lines.map("* " + _).mkString("\n")
    val extraWithStar = extra.map("*" + _).mkString("\n")
    s"/** $linesWithStar\n$extraWithStar\n */"
  }

  def codeFromClassTypeDef(classTypeDef: TypeDef.ClassTypeDef): String = {
    val tpeName      = classTypeDef.name
    val allUndefined = classTypeDef.anonPart.allUndefined

    val fieldsWithTypes = classTypeDef.anonPart.fields.map { case (version, fields) =>
      version -> fields.map { case (name, field) =>
        val fieldType = (field.withUndefined, field.withNull) match {
          case (true, true)   => s"JsonOption[${field.tpe}]"
          case (true, false)  => s"UndefOr[${field.tpe}]"
          case (false, true)  => s"Option[${field.tpe}]"
          case (false, false) => field.tpe
        }

        name -> (field, fieldType)
      }
    }

    val makeDefs = fieldsWithTypes.map { case (version, fields) =>
      val defName = s"make${version.replace("x", "").replace(".", "")}"

      val params = fields.map { case (field, (fieldInfo, tpe)) =>
        val defaultStr = fieldInfo.default.fold("") { s =>
          (s, allUndefined || fieldInfo.withUndefined, fieldInfo.withNull) match {
            case ("null", true, true)       => "= JsonNull"
            case ("undefined", true, true)  => "= JsonUndefined"
            case ("null", false, true)      => "= None"
            case ("undefined", true, false) => "= UndefOrUndefined"
            case (d, true, true)            => s"= JsonSome($d)"
            case (d, false, true)           => s"= Some($d)"
            case (d, true, false)           => s"= UndefOrSome($d)"
            case (d, false, false)          => s"= $d"
          }
        }
        s"${camelCase(field)}: $tpe$defaultStr"
      }

      val args = fields.map { case (field, (fieldInfo, _)) =>
        val jsonName = fieldInfo.jsonName.getOrElse(field)
        val fieldLit = "\"" + jsonName + "\""
        if (fieldInfo.isExtension) {
          s"DiscordObjectFrom.FromExtension($fieldLit, ${camelCase(field)})"
        } else {
          if (fieldInfo.withUndefined) s"$fieldLit :=? ${camelCase(field)}"
          else s"$fieldLit := ${camelCase(field)}"
        }
      }

      val fieldDocs = fields.collect { case (name, (FieldDef(_, _, _, Some(documentation), _, _, _, _), _)) =>
        s"@param $name $documentation"
      }.toSeq

      val docs = if (fieldDocs.nonEmpty) docString("", fieldDocs) else ""

      s"$docs def $defName(${params.mkString(", ")}): $tpeName = makeRawFromFields(${args.mkString(", ")})"
    }

    val allClassFields = fieldsWithTypes.toSeq.flatMap { case (version, fields) =>
      val intVersion = version.replace("x", "").replace(".", "").toInt
      fields.map(field => (intVersion, field._1, field._2))
    }.zipWithIndex
    val highestVersionAll = allClassFields.maxBy(_._1._1)._1._1

    val groupedClassFields = allClassFields
      .groupBy(_._1._2)
      .map { case (k, v) =>
        val (t, idx) = v.maxBy(_._1._1)
        k -> (t._3, t._1, idx)
      }
      .toSeq
      .sortBy(_._2._3)
      .map { case (k, v) =>
        k -> (v._1, v._2)
      }

    val classDefs = groupedClassFields.map { case (k, ((fieldDef, tpe), highestVersion)) =>
      val mods =
        if (highestVersion < highestVersionAll)
          List(
            "@inline",
            s"""@deprecated(message = "Value might be missing", since = "${highestVersionAll.toString}")""",
            s"private[ackcord]"
          )
        else List("@inline")

      val jsonName = fieldDef.jsonName.getOrElse(k)

      val defBody =
        if (fieldDef.isExtension) s"""$tpe.makeRaw(json, extensionCache("$jsonName"))"""
        else s"""selectDynamic[$tpe]("$jsonName")"""
      val defdef = s"""${mods.mkString(" ")} def ${camelCase(k)}: $tpe = $defBody"""

      (fieldDef.documentation.map(docString(_)).toList :+ defdef).mkString("\n")
    }

    val values = groupedClassFields.map(t => s"() => ${t._1}").mkString(", ")

    val withs    = classTypeDef.anonPart.`extends`.map(w => s"with $w").mkString(" ")
    val objWiths = classTypeDef.anonPart.objectExtends.map(w => s"with $w").mkString(" ")

    val tpeCode =
      s"""|class $tpeName(json: Json, cache: Map[String, Any] = Map.empty) extends DiscordObject(json, cache) $withs {
          |   ${classDefs.mkString("\n\n")}
          |
          |   override def values: Seq[() => Any] = Seq($values)
          |}
          |object ${classTypeDef.name} extends DiscordObjectCompanion[$tpeName] $objWiths {
          |  def makeRaw(json: Json, cache: Map[String, Any]): $tpeName = new $tpeName(json, cache)
          |
          |  ${makeDefs.mkString("\n\n")}
          |
          |  ${classTypeDef.anonPart.innerTypes.flatMap(codeFromTypeDef).mkString("\n\n")}
          |}""".stripMargin

    (classTypeDef.anonPart.documentation.map(docString(_)).toList :+ tpeCode).mkString("\n")
  }

  def codeFromObjectOnly(objectOnlyDef: TypeDef.ObjectOnlyDef): String = {
    val extend =
      if (objectOnlyDef.objectExtends.nonEmpty) "extends " + objectOnlyDef.objectExtends.mkString(" with ") else ""
    s"""|object ${objectOnlyDef.name} $extend {
        |  ${objectOnlyDef.innerTypes.flatMap(codeFromTypeDef).mkString("\n\n")}
        |}""".stripMargin
  }

  def codeFromFreeform(freeformDef: CodeGenTypes.TypeDef.FreeformDef): String =
    (freeformDef.documentation.map(docString(_)).toList :+ freeformDef.content).mkString("\n")

  def codeFromEnumTypeDef(enumTypeDef: TypeDef.EnumTypeDef): String = {
    val tpeName = enumTypeDef.name

    val underlyingType = enumTypeDef.tpe

    def wrap(value: String): String = underlyingType match {
      case "String" => "\"" + value + "\""
      case _        => value
    }

    val values = enumTypeDef.values
      .map { case (name, value) =>
        (value.documentation.map(docString(_)).toList :+ s"val $name: $tpeName = $tpeName(${wrap(value.value)})")
          .mkString("\n")
      }
      .mkString("\n  ")

    val objWiths = enumTypeDef.objectExtends.map(w => s"with $w").mkString(" ")

    val bitfieldMembers = if (enumTypeDef.name == "BitfieldIntEnum") {

      List(
        s"""|implicit class ${tpeName}BitFieldOps(private val here: $tpeName) extends AnyVal {
            |  def to$underlyingType: $underlyingType = here.value
            |
            |  def ++(there: $tpeName): $tpeName = $tpeName(here.value | there.value)
            |
            |  def --(there: $tpeName): $tpeName = $tpeName(here.value & ~there.value)
            |
            |  def isNone: Boolean = here.value == 0
            |}""".stripMargin
      )

    } else Nil

    val tpeCode =
      s"""|sealed case class $tpeName private(value: $underlyingType) extends DiscordEnum[$underlyingType]
          |object $tpeName extends DiscordEnumCompanion[$underlyingType, $tpeName] $objWiths {
          |
          |  $values
          |  
          |  def unknown(value: $underlyingType): $tpeName = new $tpeName(value)
          |  
          |  def values: Seq[$tpeName] = Seq(${enumTypeDef.values.keys.mkString(", ")})
          |  
          |  ${(bitfieldMembers :+ enumTypeDef.innerTypes.flatMap(codeFromTypeDef)).mkString("\n\n")}
          |}""".stripMargin

    (enumTypeDef.documentation.map(docString(_)).toList :+ tpeCode).mkString("\n")
  }

  def codeFromOpaqueTypeDef(opaqueTypeDef: TypeDef.OpaqueTypeDef): String = {
    val tpeName = opaqueTypeDef.name

    val aliasCode = s"type $tpeName = $tpeName.$tpeName" + "\n"

    val objWiths = opaqueTypeDef.objectExtends.map(w => s"with $w").mkString(" ")

    val companionCode =
      s"""|object $tpeName extends DiscordOpaqueCompanion[${opaqueTypeDef.underlying}] $objWiths {
          |  type $tpeName = OpaqueType
          |
          |  ${opaqueTypeDef.innerTypes.flatMap(codeFromTypeDef).mkString("\n\n")}
          |}""".stripMargin

    val tpeCode = if (opaqueTypeDef.includeAlias) aliasCode + companionCode else companionCode

    (opaqueTypeDef.documentation.map(docString(_)).toList :+ tpeCode).mkString("\n")
  }

  def knownArgPathElemToCustom(elem: PathElem.ArgPathElem): PathElem.CustomArgPathElem = elem.argOf match {
    case "GuildId" =>
      PathElem.CustomArgPathElem(
        elem.name.getOrElse("guildId"),
        "GuildId",
        majorParameter = true,
        elem.documentation
      )

    case "ChannelId" =>
      PathElem.CustomArgPathElem(
        elem.name.getOrElse("channelId"),
        "ChannelId",
        majorParameter = false,
        elem.documentation
      )

    case _ =>
      sys.error(s"Unknown path arg element ${elem.argOf}")
  }

  def codeFromRequestDef(requestDef: TypeDef.RequestDef): List[String] = {
    val uncapitalizedName = requestDef.name.charAt(0).toLower.toString + requestDef.name.substring(1)
    val capitalizedName   = uncapitalizedName.capitalize
    val queryClass = requestDef.query.fold("")(q => codeFromClassTypeDef(q.named(capitalizedName + "Query")) + "\n")
    val bodyClass = requestDef.body.fold("") {
      case AnonymousClassTypeDefOrType.TypeRef(_) => ""
      case AnonymousClassTypeDefOrType.AnonType(anon) =>
        codeFromClassTypeDef(anon.named(capitalizedName + "Body")) + "\n"
    }
    val returnClass = requestDef.returnTpe.fold("") {
      case AnonymousClassTypeDefOrType.TypeRef(_) => ""
      case AnonymousClassTypeDefOrType.AnonType(anon) =>
        codeFromClassTypeDef(anon.named(capitalizedName + "Result")) + "\n"
    }

    val allCustomPathElems = requestDef.path.map {
      case argPathElem: PathElem.ArgPathElem => knownArgPathElemToCustom(argPathElem)
      case other                             => other
    }

    val pathParamNames = allCustomPathElems.collect { case PathElem.CustomArgPathElem(name, _, _, _) =>
      name
    }

    val duplicatePathParamNames = pathParamNames.collect {
      case name if pathParamNames.count(_ == name) > 1 => name
    }
    require(
      duplicatePathParamNames.isEmpty,
      s"Found duplicated name for request ${requestDef.name}. Duplicated: ${duplicatePathParamNames.mkString(", ")}"
    )

    val pathDocs = allCustomPathElems.collect { case PathElem.CustomArgPathElem(name, _, _, Some(documentation)) =>
      s"@param $name $documentation"
    }

    val typeParams =
      if (requestDef.additionalTypeParams.nonEmpty) requestDef.additionalTypeParams.mkString("[", ", ", "]") else ""

    val pathParams = allCustomPathElems
      .collect { case PathElem.CustomArgPathElem(name, tpe, _, _) =>
        s"$name: $tpe, "
      }
      .mkString("\n")

    val queryParam =
      if (requestDef.query.isDefined) s"query: ${capitalizedName}Query = ${capitalizedName}Query(), " else ""

    val paramsType = {
      val tpe = requestDef.body.fold("Unit") {
        case AnonymousClassTypeDefOrType.TypeRef(name) => name
        case AnonymousClassTypeDefOrType.AnonType(_)   => s"${capitalizedName}Body"
      }
      if (requestDef.arrayOfBody) s"Seq[$tpe]" else tpe
    }

    val bodyParam   = requestDef.body.fold("")(_ => s"body: $paramsType,")
    val reasonParam = if (requestDef.allowsReason) "reason: Option[String]," else ""
    val additionalParams =
      requestDef.additionalParams
        .map(t => s"${t._1}: ${t._2.tpe}${t._2.default.fold("")(d => s" = $d")},")
        .mkString("\n")

    val returnTpe = {
      val tpe = requestDef.returnTpe.fold("Unit") {
        case AnonymousClassTypeDefOrType.TypeRef(name)  => name
        case AnonymousClassTypeDefOrType.AnonType(anon) => s"${capitalizedName}Result"
      }
      if (requestDef.arrayOfReturn) s"Seq[$tpe]" else tpe
    }

    val requestType =
      if (requestDef.complexType.isEmpty) s"Request[$paramsType, $returnTpe]"
      else s"ComplexRequest[$paramsType, $returnTpe, ${requestDef.complexType.r1}, ${requestDef.complexType.r2}]"

    val pathArg = requestDef.path
      .map {
        case arg @ PathElem.ArgPathElem(_, argOf, _) =>
          val custom = knownArgPathElemToCustom(arg)
          s"Parameters.of${argOf.capitalize}(${custom.name})"
        case PathElem.StringPathElem(elem) => s""""$elem""""
        case PathElem.CustomArgPathElem(name, tpe, majorParameter, documentation) =>
          if (majorParameter) s"""Parameters.MajorParameter[$tpe]("$name", $name)"""
          else s"""Parameters.MinorParameter[$tpe]("$name", $name)"""
      }
      .mkString(" / ")

    val queryArg = requestDef.query.filter(_.fields.nonEmpty).fold("") { q =>
      val highestVersion = q.fields.keys.maxBy(_.replace(".", "").replace("x", "").toInt)
      q
        .fields(highestVersion)
        .map { case (k, v) =>
          s""" +? Parameters.query("$k", query.$k)"""
        }
        .mkString
    }

    val pathArgWithQuery = "Route.Empty" + (if (pathArg.isEmpty) "" else s"/ $pathArg") + queryArg

    val extraHeaders =
      if (requestDef.allowsReason) """extraHeaders = reason.fold(Map.empty)(r => Map("X-Audit-Log-Reason" -> r)),"""
      else ""

    val requestDefDef =
      s"""|${requestDef.documentation.fold("")(docString(_, pathDocs) + "\n")} def $uncapitalizedName$typeParams(
          |  $pathParams
          |  $queryParam
          |  $bodyParam
          |  $reasonParam
          |  $additionalParams
          |): $requestType =
          |  Request.complexRestRequest(
          |    route = ($pathArgWithQuery).toRequest(Method.${requestDef.method}),
          |    ${if (bodyParam.nonEmpty) "params = body," else ""},
          |    $extraHeaders,
          |    ${requestDef.encodeBody.fold("")(e => s"encodeBody = Some($e),")}
          |    ${requestDef.parseResponse.fold("")(r => s"parseResponse = Some($r),")}
          |  )
          |""".stripMargin

    List(queryClass, bodyClass, returnClass, requestDefDef).filter(_.nonEmpty)
  }
}
