import java.nio.file.{Files, Path}

import scala.collection.JavaConverters.*

import CodeGenTypes.*
import io.circe.*

object AckCordCodeGen {

  def isUndefined(allUndefined: Boolean, withUndefined: Boolean, alwaysPresent: Boolean): Boolean =
    !alwaysPresent && (allUndefined || withUndefined)

  def isFieldUndefined(field: FieldDef, allUndefined: Boolean): Boolean =
    isUndefined(allUndefined, field.withUndefined, field.alwaysPresent)

  def generateCodeFromFile(generatedRoot: Path, yamlFile: Path): String = {
    val relativeYamlPath = generatedRoot.relativize(yamlFile).iterator.asScala.map(_.toString).toList.init

    val typeDef =
      yaml.parser.parse(Files.readAllLines(yamlFile).asScala.mkString("\n")).flatMap(_.as[TypeDef]).toTry.get

    GenAST.printFile(
      GenAST.ScalaFile(
        packageLoc = relativeYamlPath.mkString("."),
        intelliJIgnoredInspections = Seq("ScalaWeakerAccess", "ScalaUnusedSymbol", "DuplicatedCode"),
        disclaimer = s"""|THIS FILE IS MACHINE GENERATED!
              |
              |Do not edit this file directly.
              |Instead, edit the file generated/${relativeYamlPath.mkString("/")}/${yamlFile.getFileName.toString}
              |""".stripMargin,
        definitions = codeFromTypeDef(typeDef, extraImports = Seq("io.circe.Json", "ackcord.data.base._"))
      )
    )
  }

  def codeFromTypeDef(typeDef: TypeDef, extraImports: Seq[String] = Nil): List[GenAST.Definition] = {
    val res: List[GenAST.Definition] = typeDef match {
      case classTypeDef: TypeDef.ClassTypeDef   => List(codeFromClassTypeDef(classTypeDef))
      case enumTypeDef: TypeDef.EnumTypeDef     => List(codeFromEnumTypeDef(enumTypeDef))
      case opaqueTypeDef: TypeDef.OpaqueTypeDef => List(codeFromOpaqueTypeDef(opaqueTypeDef))
      case requestDef: TypeDef.RequestDef       => codeFromRequestDef(requestDef)
      case multiple: TypeDef.MultipleDefs       => multiple.innerTypes.toList.flatMap(codeFromTypeDef(_))
      case objectOnly: TypeDef.ObjectOnlyDef    => List(codeFromObjectOnly(objectOnly))
      case freeform: TypeDef.FreeformDef        => List(codeFromFreeform(freeform))
    }

    GenAST.Imports(extraImports ++ typeDef.imports) :: res
  }

  def camelCaseFromSnakecase(s: String): String = {
    val arr = s.split("_")
    arr.head + arr.iterator.drop(1).map(_.capitalize).mkString
  }

  def pascalCaseFromSnakecase(s: String): String = {
    val base = camelCaseFromSnakecase(s)
    base.charAt(0).toUpper.toString + base.substring(1)
  }

  def docString(s: String, extra: Seq[String] = Nil): String = {
    val lines         = s.linesIterator.toList
    val linesWithStar = if (lines.size <= 1) lines.mkString else lines.map("* " + _).mkString("\n")
    val extraWithStar = extra.map("*" + _).mkString("\n")
    s"/** $linesWithStar\n$extraWithStar\n */"
  }

  case class FieldWithType(field: FieldDef, tpe: String)
  case class FieldWithTypeVersionAndName(field: FieldDef, tpe: String, version: Int, name: String)

  def codeFromClassTypeDef(classTypeDef: TypeDef.ClassTypeDef): GenAST.Definition = {
    val tpeName      = classTypeDef.name
    val allUndefined = classTypeDef.anonPart.allUndefined

    val fieldsWithTypes = classTypeDef.anonPart.fields.map { case (version, fields) =>
      version -> fields.map { case (name, field) =>
        val fieldType = (isFieldUndefined(field, allUndefined), field.withNull) match {
          case (true, true)   => s"JsonOption[${field.tpe}]"
          case (true, false)  => s"UndefOr[${field.tpe}]"
          case (false, true)  => s"Option[${field.tpe}]"
          case (false, false) => field.tpe
        }

        name -> FieldWithType(field, fieldType)
      }
    }

    val makeRaw =
      if (classTypeDef.anonPart.customMakeRaw) Nil
      else
        List(
          GenAST.DefDef(
            name = "makeRaw",
            parameters = Seq(
              Seq(
                GenAST.Parameter(name = "json", tpe = "Json"),
                GenAST.Parameter(name = "cache", tpe = "Map[String, Any]")
              )
            ),
            returnType = tpeName,
            rhs = s"new $tpeName(json, cache)"
          )
        )

    val makeDefs = fieldsWithTypes.map { case (version, fields) =>
      val defName = s"make${version.replace("x", "").replace(".", "")}"

      val params = fields.map { case (field, FieldWithType(fieldInfo, tpe)) =>
        val undef       = isFieldUndefined(fieldInfo, allUndefined)
        val realDefault = if (undef) fieldInfo.default.orElse(Some("undefined")) else fieldInfo.default

        GenAST.Parameter(
          docs = fieldInfo.documentation,
          name = camelCaseFromSnakecase(field),
          tpe = tpe,
          default = realDefault.map { s =>
            (s, undef, fieldInfo.withNull) match {
              case ("null", true, true)       => "JsonNull"
              case ("undefined", true, true)  => s"""JsonUndefined(Some("$field"))"""
              case ("null", false, true)      => "None"
              case ("undefined", true, false) => s"""UndefOrUndefined(Some("$field"))"""
              case (d, true, true)            => s"JsonSome($d)"
              case (d, false, true)           => s"Some($d)"
              case (d, true, false)           => s"UndefOrSome($d)"
              case (d, false, false)          => d
            }
          }
        )
      }.toSeq

      val args = fields.map { case (field, FieldWithType(fieldInfo, _)) =>
        val jsonName = fieldInfo.jsonName.getOrElse(field)
        val fieldLit = "\"" + jsonName + "\""
        if (fieldInfo.isExtension) {
          s"DiscordObjectFrom.FromExtension($fieldLit, ${camelCaseFromSnakecase(field)})"
        } else {
          if (isFieldUndefined(fieldInfo, allUndefined)) s"$fieldLit :=? ${camelCaseFromSnakecase(field)}"
          else s"$fieldLit := ${camelCaseFromSnakecase(field)}"
        }
      }

      GenAST.DefDef(
        name = defName,
        parameters = Seq(params),
        returnType = tpeName,
        rhs = s"makeRawFromFields(${args.mkString(", ")})"
      )
    }.toSeq

    val allClassFields = fieldsWithTypes.toSeq.flatMap { case (version, fields) =>
      val intVersion = version.replace("x", "").replace(".", "").toInt
      fields.map(field => FieldWithTypeVersionAndName(field._2.field, field._2.tpe, intVersion, field._1))
    }
    val highestVersionAll = fieldsWithTypes.keys.map(s => s.replace("x", "").replace(".", "").toInt).max

    val groupedClassFields = allClassFields.zipWithIndex
      .groupBy(_._1.name)
      .map { case (name, fields) =>
        val (field, idx) = fields.maxBy(_._1.version)
        name -> (field, idx)
      }
      .toSeq
      .sortBy(_._2._2)
      .map { case (_, v) => v._1 }

    val classDefs = groupedClassFields.flatMap {
      case FieldWithTypeVersionAndName(fieldDef, tpe, highestVersion, name) =>
        val undef = isFieldUndefined(fieldDef, allUndefined)
        val baseMods =
          if (highestVersion < highestVersionAll)
            List(
              "@inline",
              s"""@deprecated(message = "Value might be missing", since = "${highestVersionAll.toString}")""",
              s"private[ackcord]"
            )
          else List("@inline")

        val accessorDefMods = if (fieldDef.overrides) baseMods :+ "override" else baseMods

        val jsonName = fieldDef.jsonName.getOrElse(name)

        Seq(
          GenAST.DefDef(
            docs = fieldDef.documentation,
            mods = accessorDefMods,
            name = camelCaseFromSnakecase(name),
            returnType = tpe,
            rhs =
              if (fieldDef.isExtension) s"""$tpe.makeRaw(json, extensionCache("$jsonName"))"""
              else s"""selectDynamic[$tpe]("$jsonName")"""
          ),
          GenAST.DefDef(
            mods = baseMods,
            name = s"with${pascalCaseFromSnakecase(name)}",
            parameters = Seq(Seq(GenAST.Parameter(name = "newValue", tpe = tpe))),
            returnType = tpeName,
            rhs =
              if (fieldDef.isExtension) s"objWithJson($tpeName, newValue.json, newValue.cacheCopy)"
              else if (undef) s"""objWithUndef($tpeName, "$jsonName", newValue)"""
              else s"""objWith($tpeName, "$jsonName", newValue)"""
          )
        )
    }

    val values = groupedClassFields.map(t => s"() => ${camelCaseFromSnakecase(t.name)}").mkString(", ")

    val partialDef =
      if (classTypeDef.anonPart.makePartial)
        List(classTypeDef.anonPart.copy(allUndefined = true, makePartial = false, innerTypes = Nil).named("Partial"))
      else Nil
    val allInnerTypes = partialDef ++ classTypeDef.anonPart.innerTypes

    val classCode = GenAST.Class(
      docs = classTypeDef.anonPart.documentation,
      name = tpeName,
      constructors = Seq(
        GenAST.Constructor(parameters =
          Seq(
            Seq(
              GenAST.Parameter(name = "json", tpe = "Json"),
              GenAST.Parameter(name = "cache", tpe = "Map[String, Any]", default = Some("Map.empty"))
            )
          )
        )
      ),
      extend = "DiscordObject(json, cache)" +: classTypeDef.anonPart.`extends`,
      members = classDefs :+ GenAST.DefDef(
        mods = Seq("override"),
        name = "values",
        returnType = "Seq[() => Any]",
        rhs = s"Seq($values)"
      )
    )

    val companionCode = GenAST.Module(
      name = tpeName,
      extend = s"DiscordObjectCompanion[$tpeName]" +: classTypeDef.anonPart.objectExtends,
      members = makeRaw ++ makeDefs ++ allInnerTypes.flatMap(codeFromTypeDef(_))
    )

    GenAST.Grouped(classCode, companionCode)
  }

  def codeFromObjectOnly(objectOnlyDef: TypeDef.ObjectOnlyDef): GenAST.Definition =
    GenAST.Module(
      name = objectOnlyDef.name,
      extend = objectOnlyDef.objectExtends,
      members = objectOnlyDef.innerTypes.flatMap(codeFromTypeDef(_))
    )

  def codeFromFreeform(freeformDef: CodeGenTypes.TypeDef.FreeformDef): GenAST.Definition =
    GenAST.FreeformDefinition(freeformDef.documentation, freeformDef.content)

  def codeFromEnumTypeDef(enumTypeDef: TypeDef.EnumTypeDef): GenAST.Definition = {
    val tpeName        = enumTypeDef.name
    val underlyingType = enumTypeDef.tpe

    def wrap(value: String): String = underlyingType match {
      case "String" => "\"" + value + "\""
      case _        => value
    }

    val classCode = GenAST.Class(
      docs = enumTypeDef.documentation,
      mods = Seq("sealed", "case"),
      name = tpeName,
      constructors = Seq(
        GenAST.Constructor(
          mods = Seq("private"),
          parameters = Seq(Seq(GenAST.Parameter(name = "value", tpe = underlyingType)))
        )
      ),
      extend = Seq(s"DiscordEnum[$underlyingType]")
    )

    val bitfieldMember =
      if (enumTypeDef.isBitField)
        Seq(
          GenAST.Class(
            mods = Seq("implicit"),
            name = s"${tpeName}BitFieldOps",
            constructors = Seq(
              GenAST.Constructor(parameters =
                Seq(Seq(GenAST.Parameter(mods = Seq("private", "val"), name = "here", tpe = tpeName)))
              )
            ),
            extend = Seq("AnyVal"),
            members = Seq(
              GenAST.DefDef(
                name = s"to$underlyingType",
                returnType = underlyingType,
                rhs = "here.value"
              ),
              GenAST.DefDef(
                name = "++",
                parameters = Seq(Seq(GenAST.Parameter(name = "there", tpe = tpeName))),
                returnType = tpeName,
                rhs = s"$tpeName(here.value | there.value)"
              ),
              GenAST.DefDef(
                name = "--",
                parameters = Seq(Seq(GenAST.Parameter(name = "there", tpe = tpeName))),
                returnType = tpeName,
                rhs = s"$tpeName(here.value & ~there.value)"
              ),
              GenAST.DefDef(
                name = s"isNone",
                returnType = "Boolean",
                rhs = "here.value == 0"
              )
            )
          )
        )
      else Nil

    val companionCode = GenAST.Module(
      name = tpeName,
      extend = Seq(s"DiscordEnumCompanion[$underlyingType, $tpeName]") ++ enumTypeDef.objectExtends,
      members = (enumTypeDef.values.map { case (name, value) =>
        GenAST.ValDef(
          docs = value.documentation,
          name = name,
          returnType = tpeName,
          rhs = s"$tpeName(${wrap(value.value)})"
        )
      }.toSeq :+ GenAST.DefDef(
        name = "unknown",
        parameters = Seq(Seq(GenAST.Parameter(name = "value", tpe = underlyingType))),
        returnType = tpeName,
        rhs = s"new $tpeName(value)"
      ) :+ GenAST.ValDef(
        name = "values",
        returnType = s"Seq[$tpeName]",
        rhs = s"Seq(${enumTypeDef.values.keys.mkString(", ")})"
      )) ++ bitfieldMember ++ enumTypeDef.innerTypes.flatMap(codeFromTypeDef(_))
    )

    GenAST.Grouped(classCode, companionCode)
  }

  def codeFromOpaqueTypeDef(opaqueTypeDef: TypeDef.OpaqueTypeDef): GenAST.Definition = {
    val tpeName = opaqueTypeDef.name

    val companion = GenAST.Module(
      docs = opaqueTypeDef.documentation,
      name = tpeName,
      extend = Seq(s"DiscordOpaqueCompanion[${opaqueTypeDef.underlying}]") ++ opaqueTypeDef.objectExtends,
      members = Seq(
        GenAST.TypeDef(name = tpeName, rhs = Some("OpaqueType"))
      ) ++ opaqueTypeDef.innerTypes.flatMap(codeFromTypeDef(_))
    )

    if (opaqueTypeDef.includeAlias)
      GenAST.Grouped(GenAST.TypeDef(name = tpeName, rhs = Some(s"$tpeName.$tpeName")), companion)
    else companion
  }

  def knownArgPathElemToCustom(elem: PathElem.ArgPathElem): PathElem.CustomArgPathElem = {
    def custom(tpe: String, name: Option[String] = None, majorParameter: Boolean = false) =
      PathElem.CustomArgPathElem(
        elem.name.orElse(name).getOrElse(tpe.charAt(0).toLower.toString + tpe.substring(1)),
        tpe,
        majorParameter,
        elem.documentation
      )

    val allowedNormal = Set(
      "GuildId",
      "ChannelId",
      "ApplicationId",
      "CommandId",
      "EmojiId",
      "MessageId",
      "UserId",
      "Emoji",
      "RoleId",
      "WebhookId",
      "GuildScheduledEventId"
    )

    elem.argOf match {
      case "webhookToken"                 => custom("String", Some("webhookToken"))
      case s if allowedNormal.contains(s) => custom(s)
      case _ =>
        sys.error(s"Unknown path arg element ${elem.argOf}")
    }
  }

  def codeFromRequestDef(requestDef: TypeDef.RequestDef): List[GenAST.Definition] = {
    val rhs = {
      val pathArg = requestDef.path
        .foldLeft(("", true)) { case ((acc, firstArg), arg) =>
          def handleCustom(custom: PathElem.CustomArgPathElem): (String, Boolean) = {
            val name       = custom.name
            val majorTypes = Set("GuildId", "ChannelId", "WebhookId")
            val major =
              if (custom.major || (majorTypes.contains(custom.tpe) && firstArg)) ", major = true" else ""
            (s"""$acc / Parameters[${custom.tpe}]("$name", $name$major)""", false)
          }

          arg match {
            case PathElem.StringPathElem(elem)      => (s"""$acc / "$elem"""", firstArg)
            case arg: PathElem.ArgPathElem          => handleCustom(knownArgPathElemToCustom(arg))
            case custom: PathElem.CustomArgPathElem => handleCustom(custom)
          }
        }
        ._1

      val queryArg = requestDef.query.filter(_.fields.nonEmpty).fold("") { q =>
        val highestVersion = q.fields.keys.maxBy(_.replace(".", "").replace("x", "").toInt)
        q
          .fields(highestVersion)
          .map { case (k, v) =>
            val queryParam =
              if (isFieldUndefined(v, q.allUndefined)) s"""Parameters.query("$k", query.${camelCaseFromSnakecase(k)})"""
              else s"""Parameters.queryAlways("$k", query.${camelCaseFromSnakecase(k)})"""

            s" +? $queryParam"
          }
          .mkString
      }

      val pathArgWithQuery = s"Route.Empty$pathArg$queryArg"

      val extraHeaders =
        if (requestDef.allowsReason)
          """extraHeaders = reason.fold(Map.empty[String, String])(r => Map("X-Audit-Log-Reason" -> r)),"""
        else ""

      s"""|Request.${if (requestDef.complexType.isEmpty) "restRequest" else "complexRestRequest"}(
          |  route = ($pathArgWithQuery).toRequest(Method.${requestDef.method}),
          |  ${if (requestDef.body.nonEmpty) "params = body," else ""}
          |  $extraHeaders
          |  ${requestDef.encodeBody.fold("")(e => s"requestBody = Some($e),")}
          |  ${requestDef.parseResponse.fold("")(r => s"parseResponse = Some($r),")}
          |)""".stripMargin
    }

    val uncapitalizedName = requestDef.name.charAt(0).toLower.toString + requestDef.name.substring(1)
    val capitalizedName   = uncapitalizedName.capitalize

    val allCustomPathElems = requestDef.path.map {
      case argPathElem: PathElem.ArgPathElem => knownArgPathElemToCustom(argPathElem)
      case other                             => other
    }

    val pathParamNames = allCustomPathElems.collect { case PathElem.CustomArgPathElem(name, _, _, _) =>
      name
    }

    val duplicatePathParamNames = pathParamNames.collect {
      case name if pathParamNames.count(_ == name) > 1 => name
    }
    require(
      duplicatePathParamNames.isEmpty,
      s"Found duplicated name for request ${requestDef.name}. Duplicated: ${duplicatePathParamNames.mkString(", ")}"
    )

    val returnTpe = {
      val tpe = requestDef.returnTpe.fold("Unit") {
        case AnonymousClassTypeDefOrType.TypeRef(name)  => name
        case AnonymousClassTypeDefOrType.AnonType(anon) => s"${capitalizedName}Result"
      }
      if (requestDef.arrayOfReturn) s"Seq[$tpe]" else tpe
    }

    val typeParams = requestDef.additionalTypeParams.map(s => GenAST.TypeParameter(name = s))

    val paramsType = {
      val tpe = requestDef.body.fold("Unit") {
        case AnonymousClassTypeDefOrType.TypeRef(name) => name
        case AnonymousClassTypeDefOrType.AnonType(_)   => s"${capitalizedName}Body"
      }
      if (requestDef.arrayOfBody) s"Seq[$tpe]" else tpe
    }

    val requestType =
      if (requestDef.complexType.isEmpty) s"Request[$paramsType, $returnTpe]"
      else s"ComplexRequest[$paramsType, $returnTpe, ${requestDef.complexType.r1}, ${requestDef.complexType.r2}]"

    val params = {
      val pathParams = allCustomPathElems.collect { case PathElem.CustomArgPathElem(name, tpe, _, documentation) =>
        GenAST.Parameter(docs = documentation, name = name, tpe = tpe)
      }

      val queryParam = requestDef.query.map { query =>
        val highestVersion = query.fields.keys.map(_.replace(".", "").replace("x", "").toInt).max
        GenAST.Parameter(
          name = "query",
          tpe = s"${capitalizedName}Query",
          default =
            if (query.allUndefined) Some(s"${capitalizedName}Query.make$highestVersion()")
            else None
        )
      }.toList

      val bodyParam = requestDef.body.map(_ => GenAST.Parameter(name = "body", tpe = paramsType)).toList
      val reasonParam =
        if (requestDef.allowsReason) List(GenAST.Parameter(name = "reason", tpe = "Option[String]")) else Nil
      val additionalParams =
        requestDef.additionalParams.map(t => GenAST.Parameter(name = t._1, tpe = t._2.tpe, default = t._2.default))

      pathParams ++ queryParam ++ bodyParam ++ reasonParam ++ additionalParams
    }

    val hasParams     = params.nonEmpty
    val hasTypeParams = typeParams.nonEmpty

    val requestDefDef =
      if (!hasTypeParams && !hasParams)
        GenAST.ValDef(
          docs = requestDef.documentation,
          name = uncapitalizedName,
          returnType = requestType,
          rhs = rhs
        )
      else
        GenAST.DefDef(
          docs = requestDef.documentation,
          name = uncapitalizedName,
          typeParameters = typeParams,
          parameters = Seq(params),
          returnType = requestType,
          rhs = rhs
        )

    val queryClass = requestDef.query.map(q => codeFromClassTypeDef(q.named(capitalizedName + "Query")))
    val bodyClass = requestDef.body.collect { case AnonymousClassTypeDefOrType.AnonType(anon) =>
      codeFromClassTypeDef(anon.named(capitalizedName + "Body"))
    }
    val returnClass = requestDef.returnTpe.collect { case AnonymousClassTypeDefOrType.AnonType(anon) =>
      codeFromClassTypeDef(anon.named(capitalizedName + "Result"))
    }

    List(queryClass, bodyClass, returnClass).flatten :+ requestDefDef
  }
}
